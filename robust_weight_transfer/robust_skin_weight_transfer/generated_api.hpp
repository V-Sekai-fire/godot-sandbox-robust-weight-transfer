#pragma once

#include <api.hpp>
#define GENERATED_API 1

struct AnimatedSprite2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(sprite_frames, Object);
    PROPERTY(animation, String);
    PROPERTY(autoplay, String);
    PROPERTY(frame, int64_t);
    PROPERTY(frame_progress, double);
    PROPERTY(speed_scale, double);
    PROPERTY(centered, bool);
    PROPERTY(offset, Vector2);
    PROPERTY(flip_h, bool);
    PROPERTY(flip_v, bool);
    METHOD(void, set_sprite_frames);
    METHOD(Object, get_sprite_frames);
    METHOD(void, set_animation);
    METHOD(String, get_animation);
    METHOD(void, set_autoplay);
    METHOD(String, get_autoplay);
    METHOD(bool, is_playing);
    METHOD(Variant, play);
    METHOD(Variant, play_backwards);
    METHOD(Variant, pause);
    METHOD(Variant, stop);
    METHOD(void, set_centered);
    METHOD(bool, is_centered);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_flip_h);
    METHOD(bool, is_flipped_h);
    METHOD(void, set_flip_v);
    METHOD(bool, is_flipped_v);
    METHOD(void, set_frame);
    METHOD(int64_t, get_frame);
    METHOD(void, set_frame_progress);
    METHOD(double, get_frame_progress);
    METHOD(void, set_frame_and_progress);
    METHOD(void, set_speed_scale);
    METHOD(double, get_speed_scale);
    METHOD(double, get_playing_speed);
};
struct AnimationMixer : public Node {
    using Node::Node;
    PROPERTY(active, bool);
    PROPERTY(deterministic, bool);
    PROPERTY(reset_on_save, bool);
    PROPERTY(root_node, String);
    PROPERTY(root_motion_track, String);
    PROPERTY(audio_max_polyphony, int64_t);
    PROPERTY(callback_mode_process, int64_t);
    PROPERTY(callback_mode_method, int64_t);
    PROPERTY(callback_mode_discrete, int64_t);
    METHOD(Variant, _post_process_key_value);
    METHOD(int64_t, add_animation_library);
    METHOD(Variant, remove_animation_library);
    METHOD(Variant, rename_animation_library);
    METHOD(bool, has_animation_library);
    METHOD(Object, get_animation_library);
    METHOD(Array, get_animation_library_list);
    METHOD(bool, has_animation);
    METHOD(Object, get_animation);
    METHOD(PackedArray<std::string>, get_animation_list);
    METHOD(void, set_active);
    METHOD(bool, is_active);
    METHOD(void, set_deterministic);
    METHOD(bool, is_deterministic);
    METHOD(void, set_root_node);
    METHOD(String, get_root_node);
    METHOD(void, set_callback_mode_process);
    METHOD(int64_t, get_callback_mode_process);
    METHOD(void, set_callback_mode_method);
    METHOD(int64_t, get_callback_mode_method);
    METHOD(void, set_callback_mode_discrete);
    METHOD(int64_t, get_callback_mode_discrete);
    METHOD(void, set_audio_max_polyphony);
    METHOD(int64_t, get_audio_max_polyphony);
    METHOD(void, set_root_motion_track);
    METHOD(String, get_root_motion_track);
    METHOD(Vector3, get_root_motion_position);
    METHOD(Quaternion, get_root_motion_rotation);
    METHOD(Vector3, get_root_motion_scale);
    METHOD(Vector3, get_root_motion_position_accumulator);
    METHOD(Quaternion, get_root_motion_rotation_accumulator);
    METHOD(Vector3, get_root_motion_scale_accumulator);
    METHOD(Variant, clear_caches);
    METHOD(Variant, advance);
    METHOD(Variant, capture);
    METHOD(void, set_reset_on_save_enabled);
    METHOD(bool, is_reset_on_save_enabled);
    METHOD(Variant, _reset);
    METHOD(Variant, _restore);
    METHOD(String, find_animation);
    METHOD(String, find_animation_library);
    static constexpr int64_t ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS = 0;
    static constexpr int64_t ANIMATION_CALLBACK_MODE_PROCESS_IDLE = 1;
    static constexpr int64_t ANIMATION_CALLBACK_MODE_PROCESS_MANUAL = 2;
    static constexpr int64_t ANIMATION_CALLBACK_MODE_METHOD_DEFERRED = 0;
    static constexpr int64_t ANIMATION_CALLBACK_MODE_METHOD_IMMEDIATE = 1;
    static constexpr int64_t ANIMATION_CALLBACK_MODE_DISCRETE_DOMINANT = 0;
    static constexpr int64_t ANIMATION_CALLBACK_MODE_DISCRETE_RECESSIVE = 1;
    static constexpr int64_t ANIMATION_CALLBACK_MODE_DISCRETE_FORCE_CONTINUOUS = 2;
};
struct AnimationPlayer : public AnimationMixer {
    using AnimationMixer::AnimationMixer;
    PROPERTY(current_animation, String);
    PROPERTY(assigned_animation, String);
    PROPERTY(autoplay, String);
    PROPERTY(current_animation_length, double);
    PROPERTY(current_animation_position, double);
    PROPERTY(playback_auto_capture, bool);
    PROPERTY(playback_auto_capture_duration, double);
    PROPERTY(playback_auto_capture_transition_type, int64_t);
    PROPERTY(playback_auto_capture_ease_type, int64_t);
    PROPERTY(playback_default_blend_time, double);
    PROPERTY(speed_scale, double);
    PROPERTY(movie_quit_on_finish, bool);
    METHOD(Variant, animation_set_next);
    METHOD(String, animation_get_next);
    METHOD(void, set_blend_time);
    METHOD(double, get_blend_time);
    METHOD(void, set_default_blend_time);
    METHOD(double, get_default_blend_time);
    METHOD(void, set_auto_capture);
    METHOD(bool, is_auto_capture);
    METHOD(void, set_auto_capture_duration);
    METHOD(double, get_auto_capture_duration);
    METHOD(void, set_auto_capture_transition_type);
    METHOD(int64_t, get_auto_capture_transition_type);
    METHOD(void, set_auto_capture_ease_type);
    METHOD(int64_t, get_auto_capture_ease_type);
    METHOD(Variant, play);
    METHOD(Variant, play_backwards);
    METHOD(Variant, play_with_capture);
    METHOD(Variant, pause);
    METHOD(Variant, stop);
    METHOD(bool, is_playing);
    METHOD(void, set_current_animation);
    METHOD(String, get_current_animation);
    METHOD(void, set_assigned_animation);
    METHOD(String, get_assigned_animation);
    METHOD(Variant, queue);
    METHOD(PackedArray<std::string>, get_queue);
    METHOD(Variant, clear_queue);
    METHOD(void, set_speed_scale);
    METHOD(double, get_speed_scale);
    METHOD(double, get_playing_speed);
    METHOD(void, set_autoplay);
    METHOD(String, get_autoplay);
    METHOD(void, set_movie_quit_on_finish_enabled);
    METHOD(bool, is_movie_quit_on_finish_enabled);
    METHOD(double, get_current_animation_position);
    METHOD(double, get_current_animation_length);
    METHOD(Variant, seek);
    METHOD(void, set_process_callback);
    METHOD(int64_t, get_process_callback);
    METHOD(void, set_method_call_mode);
    METHOD(int64_t, get_method_call_mode);
    METHOD(void, set_root);
    METHOD(String, get_root);
    static constexpr int64_t ANIMATION_PROCESS_PHYSICS = 0;
    static constexpr int64_t ANIMATION_PROCESS_IDLE = 1;
    static constexpr int64_t ANIMATION_PROCESS_MANUAL = 2;
    static constexpr int64_t ANIMATION_METHOD_CALL_DEFERRED = 0;
    static constexpr int64_t ANIMATION_METHOD_CALL_IMMEDIATE = 1;
};
struct AnimationTree : public AnimationMixer {
    using AnimationMixer::AnimationMixer;
    PROPERTY(tree_root, Object);
    PROPERTY(advance_expression_base_node, String);
    PROPERTY(anim_player, String);
    METHOD(void, set_tree_root);
    METHOD(Object, get_tree_root);
    METHOD(void, set_advance_expression_base_node);
    METHOD(String, get_advance_expression_base_node);
    METHOD(void, set_animation_player);
    METHOD(String, get_animation_player);
    METHOD(void, set_process_callback);
    METHOD(int64_t, get_process_callback);
    static constexpr int64_t ANIMATION_PROCESS_PHYSICS = 0;
    static constexpr int64_t ANIMATION_PROCESS_IDLE = 1;
    static constexpr int64_t ANIMATION_PROCESS_MANUAL = 2;
};
struct AtlasTileProxyObject : public Object {
    using Object::Object;
};
struct AudioListener2D : public Node2D {
    using Node2D::Node2D;
    METHOD(Variant, make_current);
    METHOD(Variant, clear_current);
    METHOD(bool, is_current);
};
struct AudioListener3D : public Node3D {
    using Node3D::Node3D;
    METHOD(Variant, make_current);
    METHOD(Variant, clear_current);
    METHOD(bool, is_current);
    METHOD(Transform3D, get_listener_transform);
};
struct AudioServer : public Object {
    using Object::Object;
    PROPERTY(bus_count, int64_t);
    PROPERTY(output_device, String);
    PROPERTY(input_device, String);
    PROPERTY(playback_speed_scale, double);
    METHOD(void, set_bus_count);
    METHOD(int64_t, get_bus_count);
    METHOD(Variant, remove_bus);
    METHOD(Variant, add_bus);
    METHOD(Variant, move_bus);
    METHOD(void, set_bus_name);
    METHOD(String, get_bus_name);
    METHOD(int64_t, get_bus_index);
    METHOD(int64_t, get_bus_channels);
    METHOD(void, set_bus_volume_db);
    METHOD(double, get_bus_volume_db);
    METHOD(void, set_bus_send);
    METHOD(String, get_bus_send);
    METHOD(void, set_bus_solo);
    METHOD(bool, is_bus_solo);
    METHOD(void, set_bus_mute);
    METHOD(bool, is_bus_mute);
    METHOD(void, set_bus_bypass_effects);
    METHOD(bool, is_bus_bypassing_effects);
    METHOD(Variant, add_bus_effect);
    METHOD(Variant, remove_bus_effect);
    METHOD(int64_t, get_bus_effect_count);
    METHOD(Object, get_bus_effect);
    METHOD(Object, get_bus_effect_instance);
    METHOD(Variant, swap_bus_effects);
    METHOD(void, set_bus_effect_enabled);
    METHOD(bool, is_bus_effect_enabled);
    METHOD(double, get_bus_peak_volume_left_db);
    METHOD(double, get_bus_peak_volume_right_db);
    METHOD(void, set_playback_speed_scale);
    METHOD(double, get_playback_speed_scale);
    METHOD(Variant, lock);
    METHOD(Variant, unlock);
    METHOD(int64_t, get_speaker_mode);
    METHOD(double, get_mix_rate);
    METHOD(PackedArray<std::string>, get_output_device_list);
    METHOD(String, get_output_device);
    METHOD(void, set_output_device);
    METHOD(double, get_time_to_next_mix);
    METHOD(double, get_time_since_last_mix);
    METHOD(double, get_output_latency);
    METHOD(PackedArray<std::string>, get_input_device_list);
    METHOD(String, get_input_device);
    METHOD(void, set_input_device);
    METHOD(void, set_bus_layout);
    METHOD(Object, generate_bus_layout);
    METHOD(void, set_enable_tagging_used_audio_streams);
    METHOD(bool, is_stream_registered_as_sample);
    METHOD(Variant, register_stream_as_sample);
    static constexpr int64_t SPEAKER_MODE_STEREO = 0;
    static constexpr int64_t SPEAKER_SURROUND_31 = 1;
    static constexpr int64_t SPEAKER_SURROUND_51 = 2;
    static constexpr int64_t SPEAKER_SURROUND_71 = 3;
    static constexpr int64_t PLAYBACK_TYPE_DEFAULT = 0;
    static constexpr int64_t PLAYBACK_TYPE_STREAM = 1;
    static constexpr int64_t PLAYBACK_TYPE_SAMPLE = 2;
    static constexpr int64_t PLAYBACK_TYPE_MAX = 3;
    static AudioServer get_singleton() { return AudioServer(Object("AudioServer").address()); }
};
struct AudioStreamPlayer : public Node {
    using Node::Node;
    PROPERTY(stream, Object);
    PROPERTY(volume_db, double);
    PROPERTY(pitch_scale, double);
    PROPERTY(playing, bool);
    PROPERTY(autoplay, bool);
    PROPERTY(stream_paused, bool);
    PROPERTY(mix_target, int64_t);
    PROPERTY(max_polyphony, int64_t);
    PROPERTY(bus, String);
    PROPERTY(playback_type, int64_t);
    METHOD(void, set_stream);
    METHOD(Object, get_stream);
    METHOD(void, set_volume_db);
    METHOD(double, get_volume_db);
    METHOD(void, set_pitch_scale);
    METHOD(double, get_pitch_scale);
    METHOD(Variant, play);
    METHOD(Variant, seek);
    METHOD(Variant, stop);
    METHOD(bool, is_playing);
    METHOD(double, get_playback_position);
    METHOD(void, set_bus);
    METHOD(String, get_bus);
    METHOD(void, set_autoplay);
    METHOD(bool, is_autoplay_enabled);
    METHOD(void, set_mix_target);
    METHOD(int64_t, get_mix_target);
    METHOD(Variant, _set_playing);
    METHOD(bool, _is_active);
    METHOD(void, set_stream_paused);
    METHOD(bool, get_stream_paused);
    METHOD(void, set_max_polyphony);
    METHOD(int64_t, get_max_polyphony);
    METHOD(bool, has_stream_playback);
    METHOD(Object, get_stream_playback);
    METHOD(void, set_playback_type);
    METHOD(int64_t, get_playback_type);
    static constexpr int64_t MIX_TARGET_STEREO = 0;
    static constexpr int64_t MIX_TARGET_SURROUND = 1;
    static constexpr int64_t MIX_TARGET_CENTER = 2;
};
struct AudioStreamPlayer2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(stream, Object);
    PROPERTY(volume_db, double);
    PROPERTY(pitch_scale, double);
    PROPERTY(playing, bool);
    PROPERTY(autoplay, bool);
    PROPERTY(stream_paused, bool);
    PROPERTY(max_distance, double);
    PROPERTY(attenuation, double);
    PROPERTY(max_polyphony, int64_t);
    PROPERTY(panning_strength, double);
    PROPERTY(bus, String);
    PROPERTY(area_mask, int64_t);
    PROPERTY(playback_type, int64_t);
    METHOD(void, set_stream);
    METHOD(Object, get_stream);
    METHOD(void, set_volume_db);
    METHOD(double, get_volume_db);
    METHOD(void, set_pitch_scale);
    METHOD(double, get_pitch_scale);
    METHOD(Variant, play);
    METHOD(Variant, seek);
    METHOD(Variant, stop);
    METHOD(bool, is_playing);
    METHOD(double, get_playback_position);
    METHOD(void, set_bus);
    METHOD(String, get_bus);
    METHOD(void, set_autoplay);
    METHOD(bool, is_autoplay_enabled);
    METHOD(Variant, _set_playing);
    METHOD(bool, _is_active);
    METHOD(void, set_max_distance);
    METHOD(double, get_max_distance);
    METHOD(void, set_attenuation);
    METHOD(double, get_attenuation);
    METHOD(void, set_area_mask);
    METHOD(int64_t, get_area_mask);
    METHOD(void, set_stream_paused);
    METHOD(bool, get_stream_paused);
    METHOD(void, set_max_polyphony);
    METHOD(int64_t, get_max_polyphony);
    METHOD(void, set_panning_strength);
    METHOD(double, get_panning_strength);
    METHOD(bool, has_stream_playback);
    METHOD(Object, get_stream_playback);
    METHOD(void, set_playback_type);
    METHOD(int64_t, get_playback_type);
};
struct AudioStreamPlayer3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(stream, Object);
    PROPERTY(attenuation_model, int64_t);
    PROPERTY(volume_db, double);
    PROPERTY(unit_size, double);
    PROPERTY(max_db, double);
    PROPERTY(pitch_scale, double);
    PROPERTY(playing, bool);
    PROPERTY(autoplay, bool);
    PROPERTY(stream_paused, bool);
    PROPERTY(max_distance, double);
    PROPERTY(max_polyphony, int64_t);
    PROPERTY(panning_strength, double);
    PROPERTY(bus, String);
    PROPERTY(area_mask, int64_t);
    PROPERTY(playback_type, int64_t);
    PROPERTY(emission_angle_enabled, bool);
    PROPERTY(emission_angle_degrees, double);
    PROPERTY(emission_angle_filter_attenuation_db, double);
    PROPERTY(attenuation_filter_cutoff_hz, double);
    PROPERTY(attenuation_filter_db, double);
    PROPERTY(doppler_tracking, int64_t);
    METHOD(void, set_stream);
    METHOD(Object, get_stream);
    METHOD(void, set_volume_db);
    METHOD(double, get_volume_db);
    METHOD(void, set_unit_size);
    METHOD(double, get_unit_size);
    METHOD(void, set_max_db);
    METHOD(double, get_max_db);
    METHOD(void, set_pitch_scale);
    METHOD(double, get_pitch_scale);
    METHOD(Variant, play);
    METHOD(Variant, seek);
    METHOD(Variant, stop);
    METHOD(bool, is_playing);
    METHOD(double, get_playback_position);
    METHOD(void, set_bus);
    METHOD(String, get_bus);
    METHOD(void, set_autoplay);
    METHOD(bool, is_autoplay_enabled);
    METHOD(Variant, _set_playing);
    METHOD(bool, _is_active);
    METHOD(void, set_max_distance);
    METHOD(double, get_max_distance);
    METHOD(void, set_area_mask);
    METHOD(int64_t, get_area_mask);
    METHOD(void, set_emission_angle);
    METHOD(double, get_emission_angle);
    METHOD(void, set_emission_angle_enabled);
    METHOD(bool, is_emission_angle_enabled);
    METHOD(void, set_emission_angle_filter_attenuation_db);
    METHOD(double, get_emission_angle_filter_attenuation_db);
    METHOD(void, set_attenuation_filter_cutoff_hz);
    METHOD(double, get_attenuation_filter_cutoff_hz);
    METHOD(void, set_attenuation_filter_db);
    METHOD(double, get_attenuation_filter_db);
    METHOD(void, set_attenuation_model);
    METHOD(int64_t, get_attenuation_model);
    METHOD(void, set_doppler_tracking);
    METHOD(int64_t, get_doppler_tracking);
    METHOD(void, set_stream_paused);
    METHOD(bool, get_stream_paused);
    METHOD(void, set_max_polyphony);
    METHOD(int64_t, get_max_polyphony);
    METHOD(void, set_panning_strength);
    METHOD(double, get_panning_strength);
    METHOD(bool, has_stream_playback);
    METHOD(Object, get_stream_playback);
    METHOD(void, set_playback_type);
    METHOD(int64_t, get_playback_type);
    static constexpr int64_t ATTENUATION_INVERSE_DISTANCE = 0;
    static constexpr int64_t ATTENUATION_INVERSE_SQUARE_DISTANCE = 1;
    static constexpr int64_t ATTENUATION_LOGARITHMIC = 2;
    static constexpr int64_t ATTENUATION_DISABLED = 3;
    static constexpr int64_t DOPPLER_TRACKING_DISABLED = 0;
    static constexpr int64_t DOPPLER_TRACKING_IDLE_STEP = 1;
    static constexpr int64_t DOPPLER_TRACKING_PHYSICS_STEP = 2;
};
struct AudioStreamPlayerInternal : public Object {
    using Object::Object;
};
struct AudioStreamPreviewGenerator : public Node {
    using Node::Node;
    METHOD(Object, generate_preview);
};
struct BackBufferCopy : public Node2D {
    using Node2D::Node2D;
    PROPERTY(copy_mode, int64_t);
    PROPERTY(rect, Rect2);
    METHOD(void, set_rect);
    METHOD(Rect2, get_rect);
    METHOD(void, set_copy_mode);
    METHOD(int64_t, get_copy_mode);
    static constexpr int64_t COPY_MODE_DISABLED = 0;
    static constexpr int64_t COPY_MODE_RECT = 1;
    static constexpr int64_t COPY_MODE_VIEWPORT = 2;
};
struct Bone2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(rest, Transform2D);
    METHOD(void, set_rest);
    METHOD(Transform2D, get_rest);
    METHOD(Variant, apply_rest);
    METHOD(Transform2D, get_skeleton_rest);
    METHOD(int64_t, get_index_in_skeleton);
    METHOD(void, set_autocalculate_length_and_angle);
    METHOD(bool, get_autocalculate_length_and_angle);
    METHOD(void, set_length);
    METHOD(double, get_length);
    METHOD(void, set_bone_angle);
    METHOD(double, get_bone_angle);
};
struct BoneAttachment3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(bone_name, String);
    PROPERTY(bone_idx, int64_t);
    PROPERTY(override_pose, bool);
    METHOD(void, set_bone_name);
    METHOD(String, get_bone_name);
    METHOD(void, set_bone_idx);
    METHOD(int64_t, get_bone_idx);
    METHOD(Variant, on_skeleton_update);
    METHOD(void, set_override_pose);
    METHOD(bool, get_override_pose);
    METHOD(void, set_use_external_skeleton);
    METHOD(bool, get_use_external_skeleton);
    METHOD(void, set_external_skeleton);
    METHOD(String, get_external_skeleton);
};
struct CPUParticles2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(emitting, bool);
    PROPERTY(amount, int64_t);
    PROPERTY(lifetime, double);
    PROPERTY(one_shot, bool);
    PROPERTY(preprocess, double);
    PROPERTY(speed_scale, double);
    PROPERTY(explosiveness, double);
    PROPERTY(randomness, double);
    PROPERTY(lifetime_randomness, double);
    PROPERTY(fixed_fps, int64_t);
    PROPERTY(fract_delta, bool);
    PROPERTY(local_coords, bool);
    PROPERTY(draw_order, int64_t);
    PROPERTY(texture, Object);
    PROPERTY(emission_shape, int64_t);
    PROPERTY(emission_sphere_radius, double);
    PROPERTY(emission_rect_extents, Vector2);
    PROPERTY(emission_points, PackedArray<Vector2>);
    PROPERTY(emission_normals, PackedArray<Vector2>);
    PROPERTY(emission_colors, PackedArray<Color>);
    PROPERTY(particle_flag_align_y, bool);
    PROPERTY(direction, Vector2);
    PROPERTY(spread, double);
    PROPERTY(gravity, Vector2);
    PROPERTY(initial_velocity_min, double);
    PROPERTY(initial_velocity_max, double);
    PROPERTY(angular_velocity_min, double);
    PROPERTY(angular_velocity_max, double);
    PROPERTY(angular_velocity_curve, Object);
    PROPERTY(orbit_velocity_min, double);
    PROPERTY(orbit_velocity_max, double);
    PROPERTY(orbit_velocity_curve, Object);
    PROPERTY(linear_accel_min, double);
    PROPERTY(linear_accel_max, double);
    PROPERTY(linear_accel_curve, Object);
    PROPERTY(radial_accel_min, double);
    PROPERTY(radial_accel_max, double);
    PROPERTY(radial_accel_curve, Object);
    PROPERTY(tangential_accel_min, double);
    PROPERTY(tangential_accel_max, double);
    PROPERTY(tangential_accel_curve, Object);
    PROPERTY(damping_min, double);
    PROPERTY(damping_max, double);
    PROPERTY(damping_curve, Object);
    PROPERTY(angle_min, double);
    PROPERTY(angle_max, double);
    PROPERTY(angle_curve, Object);
    PROPERTY(scale_amount_min, double);
    PROPERTY(scale_amount_max, double);
    PROPERTY(scale_amount_curve, Object);
    PROPERTY(split_scale, bool);
    PROPERTY(scale_curve_x, Object);
    PROPERTY(scale_curve_y, Object);
    PROPERTY(color, Color);
    PROPERTY(color_ramp, Object);
    PROPERTY(color_initial_ramp, Object);
    PROPERTY(hue_variation_min, double);
    PROPERTY(hue_variation_max, double);
    PROPERTY(hue_variation_curve, Object);
    PROPERTY(anim_speed_min, double);
    PROPERTY(anim_speed_max, double);
    PROPERTY(anim_speed_curve, Object);
    PROPERTY(anim_offset_min, double);
    PROPERTY(anim_offset_max, double);
    PROPERTY(anim_offset_curve, Object);
    METHOD(void, set_emitting);
    METHOD(void, set_amount);
    METHOD(void, set_lifetime);
    METHOD(void, set_one_shot);
    METHOD(void, set_pre_process_time);
    METHOD(void, set_explosiveness_ratio);
    METHOD(void, set_randomness_ratio);
    METHOD(void, set_lifetime_randomness);
    METHOD(void, set_use_local_coordinates);
    METHOD(void, set_fixed_fps);
    METHOD(void, set_fractional_delta);
    METHOD(void, set_speed_scale);
    METHOD(bool, is_emitting);
    METHOD(int64_t, get_amount);
    METHOD(double, get_lifetime);
    METHOD(bool, get_one_shot);
    METHOD(double, get_pre_process_time);
    METHOD(double, get_explosiveness_ratio);
    METHOD(double, get_randomness_ratio);
    METHOD(double, get_lifetime_randomness);
    METHOD(bool, get_use_local_coordinates);
    METHOD(int64_t, get_fixed_fps);
    METHOD(bool, get_fractional_delta);
    METHOD(double, get_speed_scale);
    METHOD(void, set_draw_order);
    METHOD(int64_t, get_draw_order);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(Variant, restart);
    METHOD(void, set_direction);
    METHOD(Vector2, get_direction);
    METHOD(void, set_spread);
    METHOD(double, get_spread);
    METHOD(void, set_param_min);
    METHOD(double, get_param_min);
    METHOD(void, set_param_max);
    METHOD(double, get_param_max);
    METHOD(void, set_param_curve);
    METHOD(Object, get_param_curve);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_color_ramp);
    METHOD(Object, get_color_ramp);
    METHOD(void, set_color_initial_ramp);
    METHOD(Object, get_color_initial_ramp);
    METHOD(void, set_particle_flag);
    METHOD(bool, get_particle_flag);
    METHOD(void, set_emission_shape);
    METHOD(int64_t, get_emission_shape);
    METHOD(void, set_emission_sphere_radius);
    METHOD(double, get_emission_sphere_radius);
    METHOD(void, set_emission_rect_extents);
    METHOD(Vector2, get_emission_rect_extents);
    METHOD(void, set_emission_points);
    METHOD(PackedArray<Vector2>, get_emission_points);
    METHOD(void, set_emission_normals);
    METHOD(PackedArray<Vector2>, get_emission_normals);
    METHOD(void, set_emission_colors);
    METHOD(PackedArray<Color>, get_emission_colors);
    METHOD(Vector2, get_gravity);
    METHOD(void, set_gravity);
    METHOD(bool, get_split_scale);
    METHOD(void, set_split_scale);
    METHOD(Object, get_scale_curve_x);
    METHOD(void, set_scale_curve_x);
    METHOD(Object, get_scale_curve_y);
    METHOD(void, set_scale_curve_y);
    METHOD(Variant, convert_from_particles);
    static constexpr int64_t DRAW_ORDER_INDEX = 0;
    static constexpr int64_t DRAW_ORDER_LIFETIME = 1;
    static constexpr int64_t PARAM_INITIAL_LINEAR_VELOCITY = 0;
    static constexpr int64_t PARAM_ANGULAR_VELOCITY = 1;
    static constexpr int64_t PARAM_ORBIT_VELOCITY = 2;
    static constexpr int64_t PARAM_LINEAR_ACCEL = 3;
    static constexpr int64_t PARAM_RADIAL_ACCEL = 4;
    static constexpr int64_t PARAM_TANGENTIAL_ACCEL = 5;
    static constexpr int64_t PARAM_DAMPING = 6;
    static constexpr int64_t PARAM_ANGLE = 7;
    static constexpr int64_t PARAM_SCALE = 8;
    static constexpr int64_t PARAM_HUE_VARIATION = 9;
    static constexpr int64_t PARAM_ANIM_SPEED = 10;
    static constexpr int64_t PARAM_ANIM_OFFSET = 11;
    static constexpr int64_t PARAM_MAX = 12;
    static constexpr int64_t PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY = 0;
    static constexpr int64_t PARTICLE_FLAG_ROTATE_Y = 1;
    static constexpr int64_t PARTICLE_FLAG_DISABLE_Z = 2;
    static constexpr int64_t PARTICLE_FLAG_MAX = 3;
    static constexpr int64_t EMISSION_SHAPE_POINT = 0;
    static constexpr int64_t EMISSION_SHAPE_SPHERE = 1;
    static constexpr int64_t EMISSION_SHAPE_SPHERE_SURFACE = 2;
    static constexpr int64_t EMISSION_SHAPE_RECTANGLE = 3;
    static constexpr int64_t EMISSION_SHAPE_POINTS = 4;
    static constexpr int64_t EMISSION_SHAPE_DIRECTED_POINTS = 5;
    static constexpr int64_t EMISSION_SHAPE_MAX = 6;
};
struct Camera2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(offset, Vector2);
    PROPERTY(anchor_mode, int64_t);
    PROPERTY(ignore_rotation, bool);
    PROPERTY(enabled, bool);
    PROPERTY(zoom, Vector2);
    PROPERTY(custom_viewport, Object);
    PROPERTY(process_callback, int64_t);
    PROPERTY(limit_left, int64_t);
    PROPERTY(limit_top, int64_t);
    PROPERTY(limit_right, int64_t);
    PROPERTY(limit_bottom, int64_t);
    PROPERTY(limit_smoothed, bool);
    PROPERTY(position_smoothing_enabled, bool);
    PROPERTY(position_smoothing_speed, double);
    PROPERTY(rotation_smoothing_enabled, bool);
    PROPERTY(rotation_smoothing_speed, double);
    PROPERTY(drag_horizontal_enabled, bool);
    PROPERTY(drag_vertical_enabled, bool);
    PROPERTY(drag_horizontal_offset, double);
    PROPERTY(drag_vertical_offset, double);
    PROPERTY(drag_left_margin, double);
    PROPERTY(drag_top_margin, double);
    PROPERTY(drag_right_margin, double);
    PROPERTY(drag_bottom_margin, double);
    PROPERTY(editor_draw_screen, bool);
    PROPERTY(editor_draw_limits, bool);
    PROPERTY(editor_draw_drag_margin, bool);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_anchor_mode);
    METHOD(int64_t, get_anchor_mode);
    METHOD(void, set_ignore_rotation);
    METHOD(bool, is_ignoring_rotation);
    METHOD(Variant, _update_scroll);
    METHOD(void, set_process_callback);
    METHOD(int64_t, get_process_callback);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(Variant, make_current);
    METHOD(bool, is_current);
    METHOD(Variant, _make_current);
    METHOD(void, set_limit);
    METHOD(int64_t, get_limit);
    METHOD(void, set_limit_smoothing_enabled);
    METHOD(bool, is_limit_smoothing_enabled);
    METHOD(void, set_drag_vertical_enabled);
    METHOD(bool, is_drag_vertical_enabled);
    METHOD(void, set_drag_horizontal_enabled);
    METHOD(bool, is_drag_horizontal_enabled);
    METHOD(void, set_drag_vertical_offset);
    METHOD(double, get_drag_vertical_offset);
    METHOD(void, set_drag_horizontal_offset);
    METHOD(double, get_drag_horizontal_offset);
    METHOD(void, set_drag_margin);
    METHOD(double, get_drag_margin);
    METHOD(Vector2, get_target_position);
    METHOD(Vector2, get_screen_center_position);
    METHOD(void, set_zoom);
    METHOD(Vector2, get_zoom);
    METHOD(void, set_custom_viewport);
    METHOD(Object, get_custom_viewport);
    METHOD(void, set_position_smoothing_speed);
    METHOD(double, get_position_smoothing_speed);
    METHOD(void, set_position_smoothing_enabled);
    METHOD(bool, is_position_smoothing_enabled);
    METHOD(void, set_rotation_smoothing_enabled);
    METHOD(bool, is_rotation_smoothing_enabled);
    METHOD(void, set_rotation_smoothing_speed);
    METHOD(double, get_rotation_smoothing_speed);
    METHOD(Variant, force_update_scroll);
    METHOD(Variant, reset_smoothing);
    METHOD(Variant, align);
    METHOD(Variant, _set_old_smoothing);
    METHOD(void, set_screen_drawing_enabled);
    METHOD(bool, is_screen_drawing_enabled);
    METHOD(void, set_limit_drawing_enabled);
    METHOD(bool, is_limit_drawing_enabled);
    METHOD(void, set_margin_drawing_enabled);
    METHOD(bool, is_margin_drawing_enabled);
    static constexpr int64_t ANCHOR_MODE_FIXED_TOP_LEFT = 0;
    static constexpr int64_t ANCHOR_MODE_DRAG_CENTER = 1;
    static constexpr int64_t CAMERA2D_PROCESS_PHYSICS = 0;
    static constexpr int64_t CAMERA2D_PROCESS_IDLE = 1;
};
struct Camera3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(keep_aspect, int64_t);
    PROPERTY(cull_mask, int64_t);
    PROPERTY(environment, Object);
    PROPERTY(attributes, Object);
    PROPERTY(compositor, Object);
    PROPERTY(h_offset, double);
    PROPERTY(v_offset, double);
    PROPERTY(doppler_tracking, int64_t);
    PROPERTY(projection, int64_t);
    PROPERTY(current, bool);
    PROPERTY(fov, double);
    PROPERTY(size, double);
    PROPERTY(frustum_offset, Vector2);
    PROPERTY(near, double);
    PROPERTY(far, double);
    METHOD(Vector3, project_ray_normal);
    METHOD(Vector3, project_local_ray_normal);
    METHOD(Vector3, project_ray_origin);
    METHOD(Vector2, unproject_position);
    METHOD(bool, is_position_behind);
    METHOD(Vector3, project_position);
    METHOD(void, set_perspective);
    METHOD(void, set_orthogonal);
    METHOD(void, set_frustum);
    METHOD(Variant, make_current);
    METHOD(Variant, clear_current);
    METHOD(void, set_current);
    METHOD(bool, is_current);
    METHOD(Transform3D, get_camera_transform);
    METHOD(Variant, get_camera_projection);
    METHOD(double, get_fov);
    METHOD(Vector2, get_frustum_offset);
    METHOD(double, get_size);
    METHOD(double, get_far);
    METHOD(double, get_near);
    METHOD(void, set_fov);
    METHOD(void, set_frustum_offset);
    METHOD(void, set_size);
    METHOD(void, set_far);
    METHOD(void, set_near);
    METHOD(int64_t, get_projection);
    METHOD(void, set_projection);
    METHOD(void, set_h_offset);
    METHOD(double, get_h_offset);
    METHOD(void, set_v_offset);
    METHOD(double, get_v_offset);
    METHOD(void, set_cull_mask);
    METHOD(int64_t, get_cull_mask);
    METHOD(void, set_environment);
    METHOD(Object, get_environment);
    METHOD(void, set_attributes);
    METHOD(Object, get_attributes);
    METHOD(void, set_compositor);
    METHOD(Object, get_compositor);
    METHOD(void, set_keep_aspect_mode);
    METHOD(int64_t, get_keep_aspect_mode);
    METHOD(void, set_doppler_tracking);
    METHOD(int64_t, get_doppler_tracking);
    METHOD(Array, get_frustum);
    METHOD(bool, is_position_in_frustum);
    METHOD(::RID, get_camera_rid);
    METHOD(::RID, get_pyramid_shape_rid);
    METHOD(void, set_cull_mask_value);
    METHOD(bool, get_cull_mask_value);
    static constexpr int64_t PROJECTION_PERSPECTIVE = 0;
    static constexpr int64_t PROJECTION_ORTHOGONAL = 1;
    static constexpr int64_t PROJECTION_FRUSTUM = 2;
    static constexpr int64_t KEEP_WIDTH = 0;
    static constexpr int64_t KEEP_HEIGHT = 1;
    static constexpr int64_t DOPPLER_TRACKING_DISABLED = 0;
    static constexpr int64_t DOPPLER_TRACKING_IDLE_STEP = 1;
    static constexpr int64_t DOPPLER_TRACKING_PHYSICS_STEP = 2;
};
struct CameraServer : public Object {
    using Object::Object;
    METHOD(Object, get_feed);
    METHOD(int64_t, get_feed_count);
    METHOD(Array, feeds);
    METHOD(Variant, add_feed);
    METHOD(Variant, remove_feed);
    static constexpr int64_t FEED_RGBA_IMAGE = 0;
    static constexpr int64_t FEED_YCBCR_IMAGE = 0;
    static constexpr int64_t FEED_Y_IMAGE = 0;
    static constexpr int64_t FEED_CBCR_IMAGE = 1;
    static CameraServer get_singleton() { return CameraServer(Object("CameraServer").address()); }
};
struct CanvasGroup : public Node2D {
    using Node2D::Node2D;
    PROPERTY(fit_margin, double);
    PROPERTY(clear_margin, double);
    PROPERTY(use_mipmaps, bool);
    METHOD(void, set_fit_margin);
    METHOD(double, get_fit_margin);
    METHOD(void, set_clear_margin);
    METHOD(double, get_clear_margin);
    METHOD(void, set_use_mipmaps);
    METHOD(bool, is_using_mipmaps);
};
struct CanvasLayer : public Node {
    using Node::Node;
    PROPERTY(layer, int64_t);
    PROPERTY(visible, bool);
    PROPERTY(offset, Vector2);
    PROPERTY(rotation, double);
    PROPERTY(scale, Vector2);
    PROPERTY(transform, Transform2D);
    PROPERTY(custom_viewport, Object);
    PROPERTY(follow_viewport_enabled, bool);
    PROPERTY(follow_viewport_scale, double);
    METHOD(void, set_layer);
    METHOD(int64_t, get_layer);
    METHOD(void, set_visible);
    METHOD(bool, is_visible);
    METHOD(Variant, show);
    METHOD(Variant, hide);
    METHOD(void, set_transform);
    METHOD(Transform2D, get_transform);
    METHOD(Transform2D, get_final_transform);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_rotation);
    METHOD(double, get_rotation);
    METHOD(void, set_scale);
    METHOD(Vector2, get_scale);
    METHOD(void, set_follow_viewport);
    METHOD(bool, is_following_viewport);
    METHOD(void, set_follow_viewport_scale);
    METHOD(double, get_follow_viewport_scale);
    METHOD(void, set_custom_viewport);
    METHOD(Object, get_custom_viewport);
    METHOD(::RID, get_canvas);
};
struct CanvasModulate : public Node2D {
    using Node2D::Node2D;
    PROPERTY(color, Color);
    METHOD(void, set_color);
    METHOD(Color, get_color);
};
struct CollisionObject2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(disable_mode, int64_t);
    PROPERTY(collision_layer, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(collision_priority, double);
    PROPERTY(input_pickable, bool);
    METHOD(Variant, _input_event);
    METHOD(Variant, _mouse_enter);
    METHOD(Variant, _mouse_exit);
    METHOD(Variant, _mouse_shape_enter);
    METHOD(Variant, _mouse_shape_exit);
    METHOD(::RID, get_rid);
    METHOD(void, set_collision_layer);
    METHOD(int64_t, get_collision_layer);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_layer_value);
    METHOD(bool, get_collision_layer_value);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_collision_priority);
    METHOD(double, get_collision_priority);
    METHOD(void, set_disable_mode);
    METHOD(int64_t, get_disable_mode);
    METHOD(void, set_pickable);
    METHOD(bool, is_pickable);
    METHOD(int64_t, create_shape_owner);
    METHOD(Variant, remove_shape_owner);
    METHOD(PackedArray<int32_t>, get_shape_owners);
    METHOD(Variant, shape_owner_set_transform);
    METHOD(Transform2D, shape_owner_get_transform);
    METHOD(Object, shape_owner_get_owner);
    METHOD(Variant, shape_owner_set_disabled);
    METHOD(bool, is_shape_owner_disabled);
    METHOD(Variant, shape_owner_set_one_way_collision);
    METHOD(bool, is_shape_owner_one_way_collision_enabled);
    METHOD(Variant, shape_owner_set_one_way_collision_margin);
    METHOD(double, get_shape_owner_one_way_collision_margin);
    METHOD(Variant, shape_owner_add_shape);
    METHOD(int64_t, shape_owner_get_shape_count);
    METHOD(Object, shape_owner_get_shape);
    METHOD(int64_t, shape_owner_get_shape_index);
    METHOD(Variant, shape_owner_remove_shape);
    METHOD(Variant, shape_owner_clear_shapes);
    METHOD(int64_t, shape_find_owner);
    static constexpr int64_t DISABLE_MODE_REMOVE = 0;
    static constexpr int64_t DISABLE_MODE_MAKE_STATIC = 1;
    static constexpr int64_t DISABLE_MODE_KEEP_ACTIVE = 2;
};
struct CollisionObject3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(disable_mode, int64_t);
    PROPERTY(collision_layer, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(collision_priority, double);
    PROPERTY(input_ray_pickable, bool);
    PROPERTY(input_capture_on_drag, bool);
    METHOD(Variant, _input_event);
    METHOD(Variant, _mouse_enter);
    METHOD(Variant, _mouse_exit);
    METHOD(void, set_collision_layer);
    METHOD(int64_t, get_collision_layer);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_layer_value);
    METHOD(bool, get_collision_layer_value);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_collision_priority);
    METHOD(double, get_collision_priority);
    METHOD(void, set_disable_mode);
    METHOD(int64_t, get_disable_mode);
    METHOD(void, set_ray_pickable);
    METHOD(bool, is_ray_pickable);
    METHOD(void, set_capture_input_on_drag);
    METHOD(bool, get_capture_input_on_drag);
    METHOD(::RID, get_rid);
    METHOD(int64_t, create_shape_owner);
    METHOD(Variant, remove_shape_owner);
    METHOD(PackedArray<int32_t>, get_shape_owners);
    METHOD(Variant, shape_owner_set_transform);
    METHOD(Transform3D, shape_owner_get_transform);
    METHOD(Object, shape_owner_get_owner);
    METHOD(Variant, shape_owner_set_disabled);
    METHOD(bool, is_shape_owner_disabled);
    METHOD(Variant, shape_owner_add_shape);
    METHOD(int64_t, shape_owner_get_shape_count);
    METHOD(Object, shape_owner_get_shape);
    METHOD(int64_t, shape_owner_get_shape_index);
    METHOD(Variant, shape_owner_remove_shape);
    METHOD(Variant, shape_owner_clear_shapes);
    METHOD(int64_t, shape_find_owner);
    static constexpr int64_t DISABLE_MODE_REMOVE = 0;
    static constexpr int64_t DISABLE_MODE_MAKE_STATIC = 1;
    static constexpr int64_t DISABLE_MODE_KEEP_ACTIVE = 2;
};
struct CollisionPolygon2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(build_mode, int64_t);
    PROPERTY(polygon, PackedArray<Vector2>);
    PROPERTY(disabled, bool);
    PROPERTY(one_way_collision, bool);
    PROPERTY(one_way_collision_margin, double);
    METHOD(void, set_polygon);
    METHOD(PackedArray<Vector2>, get_polygon);
    METHOD(void, set_build_mode);
    METHOD(int64_t, get_build_mode);
    METHOD(void, set_disabled);
    METHOD(bool, is_disabled);
    METHOD(void, set_one_way_collision);
    METHOD(bool, is_one_way_collision_enabled);
    METHOD(void, set_one_way_collision_margin);
    METHOD(double, get_one_way_collision_margin);
    static constexpr int64_t BUILD_SOLIDS = 0;
    static constexpr int64_t BUILD_SEGMENTS = 1;
};
struct CollisionPolygon3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(depth, double);
    PROPERTY(disabled, bool);
    PROPERTY(polygon, PackedArray<Vector2>);
    PROPERTY(margin, double);
    METHOD(void, set_depth);
    METHOD(double, get_depth);
    METHOD(void, set_polygon);
    METHOD(PackedArray<Vector2>, get_polygon);
    METHOD(void, set_disabled);
    METHOD(bool, is_disabled);
    METHOD(void, set_margin);
    METHOD(double, get_margin);
    METHOD(bool, _is_editable_3d_polygon);
};
struct CollisionShape2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(shape, Object);
    PROPERTY(disabled, bool);
    PROPERTY(one_way_collision, bool);
    PROPERTY(one_way_collision_margin, double);
    PROPERTY(debug_color, Color);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(void, set_disabled);
    METHOD(bool, is_disabled);
    METHOD(void, set_one_way_collision);
    METHOD(bool, is_one_way_collision_enabled);
    METHOD(void, set_one_way_collision_margin);
    METHOD(double, get_one_way_collision_margin);
    METHOD(void, set_debug_color);
    METHOD(Color, get_debug_color);
};
struct CollisionShape3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(shape, Object);
    PROPERTY(disabled, bool);
    METHOD(Variant, resource_changed);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(void, set_disabled);
    METHOD(bool, is_disabled);
    METHOD(Variant, make_convex_from_siblings);
};
struct ConnectDialogBinds : public Object {
    using Object::Object;
};
struct Control : public CanvasItem {
    using CanvasItem::CanvasItem;
    PROPERTY(clip_contents, bool);
    PROPERTY(custom_minimum_size, Vector2);
    PROPERTY(layout_direction, int64_t);
    PROPERTY(layout_mode, int64_t);
    PROPERTY(anchors_preset, int64_t);
    PROPERTY(anchor_left, double);
    PROPERTY(anchor_top, double);
    PROPERTY(anchor_right, double);
    PROPERTY(anchor_bottom, double);
    PROPERTY(offset_left, int64_t);
    PROPERTY(offset_top, int64_t);
    PROPERTY(offset_right, int64_t);
    PROPERTY(offset_bottom, int64_t);
    PROPERTY(grow_horizontal, int64_t);
    PROPERTY(grow_vertical, int64_t);
    PROPERTY(size, Vector2);
    PROPERTY(position, Vector2);
    PROPERTY(global_position, Vector2);
    PROPERTY(rotation, double);
    PROPERTY(rotation_degrees, double);
    PROPERTY(scale, Vector2);
    PROPERTY(pivot_offset, Vector2);
    PROPERTY(size_flags_horizontal, int64_t);
    PROPERTY(size_flags_vertical, int64_t);
    PROPERTY(size_flags_stretch_ratio, double);
    PROPERTY(localize_numeral_system, bool);
    PROPERTY(auto_translate, bool);
    PROPERTY(tooltip_text, String);
    PROPERTY(focus_neighbor_left, String);
    PROPERTY(focus_neighbor_top, String);
    PROPERTY(focus_neighbor_right, String);
    PROPERTY(focus_neighbor_bottom, String);
    PROPERTY(focus_next, String);
    PROPERTY(focus_previous, String);
    PROPERTY(focus_mode, int64_t);
    PROPERTY(mouse_filter, int64_t);
    PROPERTY(mouse_force_pass_scroll_events, bool);
    PROPERTY(mouse_default_cursor_shape, int64_t);
    PROPERTY(shortcut_context, Object);
    PROPERTY(theme, Object);
    PROPERTY(theme_type_variation, String);
    METHOD(bool, _has_point);
    METHOD(Array, _structured_text_parser);
    METHOD(Vector2, _get_minimum_size);
    METHOD(String, _get_tooltip);
    METHOD(Variant, _get_drag_data);
    METHOD(bool, _can_drop_data);
    METHOD(Variant, _drop_data);
    METHOD(Object, _make_custom_tooltip);
    METHOD(Variant, _gui_input);
    METHOD(Variant, accept_event);
    METHOD(Vector2, get_minimum_size);
    METHOD(Vector2, get_combined_minimum_size);
    METHOD(Variant, _set_layout_mode);
    METHOD(int64_t, _get_layout_mode);
    METHOD(Variant, _set_anchors_layout_preset);
    METHOD(int64_t, _get_anchors_layout_preset);
    METHOD(void, set_anchors_preset);
    METHOD(void, set_offsets_preset);
    METHOD(void, set_anchors_and_offsets_preset);
    METHOD(Variant, _set_anchor);
    METHOD(void, set_anchor);
    METHOD(double, get_anchor);
    METHOD(void, set_offset);
    METHOD(double, get_offset);
    METHOD(void, set_anchor_and_offset);
    METHOD(void, set_begin);
    METHOD(void, set_end);
    METHOD(void, set_position);
    METHOD(Variant, _set_position);
    METHOD(void, set_size);
    METHOD(Variant, reset_size);
    METHOD(Variant, _set_size);
    METHOD(void, set_custom_minimum_size);
    METHOD(void, set_global_position);
    METHOD(Variant, _set_global_position);
    METHOD(void, set_rotation);
    METHOD(void, set_rotation_degrees);
    METHOD(void, set_scale);
    METHOD(void, set_pivot_offset);
    METHOD(Vector2, get_begin);
    METHOD(Vector2, get_end);
    METHOD(Vector2, get_position);
    METHOD(Vector2, get_size);
    METHOD(double, get_rotation);
    METHOD(double, get_rotation_degrees);
    METHOD(Vector2, get_scale);
    METHOD(Vector2, get_pivot_offset);
    METHOD(Vector2, get_custom_minimum_size);
    METHOD(Vector2, get_parent_area_size);
    METHOD(Vector2, get_global_position);
    METHOD(Vector2, get_screen_position);
    METHOD(Rect2, get_rect);
    METHOD(Rect2, get_global_rect);
    METHOD(void, set_focus_mode);
    METHOD(int64_t, get_focus_mode);
    METHOD(bool, has_focus);
    METHOD(Variant, grab_focus);
    METHOD(Variant, release_focus);
    METHOD(Object, find_prev_valid_focus);
    METHOD(Object, find_next_valid_focus);
    METHOD(Object, find_valid_focus_neighbor);
    METHOD(void, set_h_size_flags);
    METHOD(int64_t, get_h_size_flags);
    METHOD(void, set_stretch_ratio);
    METHOD(double, get_stretch_ratio);
    METHOD(void, set_v_size_flags);
    METHOD(int64_t, get_v_size_flags);
    METHOD(void, set_theme);
    METHOD(Object, get_theme);
    METHOD(void, set_theme_type_variation);
    METHOD(String, get_theme_type_variation);
    METHOD(Variant, begin_bulk_theme_override);
    METHOD(Variant, end_bulk_theme_override);
    METHOD(Variant, add_theme_icon_override);
    METHOD(Variant, add_theme_stylebox_override);
    METHOD(Variant, add_theme_font_override);
    METHOD(Variant, add_theme_font_size_override);
    METHOD(Variant, add_theme_color_override);
    METHOD(Variant, add_theme_constant_override);
    METHOD(Variant, remove_theme_icon_override);
    METHOD(Variant, remove_theme_stylebox_override);
    METHOD(Variant, remove_theme_font_override);
    METHOD(Variant, remove_theme_font_size_override);
    METHOD(Variant, remove_theme_color_override);
    METHOD(Variant, remove_theme_constant_override);
    METHOD(Object, get_theme_icon);
    METHOD(Object, get_theme_stylebox);
    METHOD(Object, get_theme_font);
    METHOD(int64_t, get_theme_font_size);
    METHOD(Color, get_theme_color);
    METHOD(int64_t, get_theme_constant);
    METHOD(bool, has_theme_icon_override);
    METHOD(bool, has_theme_stylebox_override);
    METHOD(bool, has_theme_font_override);
    METHOD(bool, has_theme_font_size_override);
    METHOD(bool, has_theme_color_override);
    METHOD(bool, has_theme_constant_override);
    METHOD(bool, has_theme_icon);
    METHOD(bool, has_theme_stylebox);
    METHOD(bool, has_theme_font);
    METHOD(bool, has_theme_font_size);
    METHOD(bool, has_theme_color);
    METHOD(bool, has_theme_constant);
    METHOD(double, get_theme_default_base_scale);
    METHOD(Object, get_theme_default_font);
    METHOD(int64_t, get_theme_default_font_size);
    METHOD(Object, get_parent_control);
    METHOD(void, set_h_grow_direction);
    METHOD(int64_t, get_h_grow_direction);
    METHOD(void, set_v_grow_direction);
    METHOD(int64_t, get_v_grow_direction);
    METHOD(void, set_tooltip_text);
    METHOD(String, get_tooltip_text);
    METHOD(String, get_tooltip);
    METHOD(void, set_default_cursor_shape);
    METHOD(int64_t, get_default_cursor_shape);
    METHOD(int64_t, get_cursor_shape);
    METHOD(void, set_focus_neighbor);
    METHOD(String, get_focus_neighbor);
    METHOD(void, set_focus_next);
    METHOD(String, get_focus_next);
    METHOD(void, set_focus_previous);
    METHOD(String, get_focus_previous);
    METHOD(Variant, force_drag);
    METHOD(void, set_mouse_filter);
    METHOD(int64_t, get_mouse_filter);
    METHOD(void, set_force_pass_scroll_events);
    METHOD(bool, is_force_pass_scroll_events);
    METHOD(void, set_clip_contents);
    METHOD(bool, is_clipping_contents);
    METHOD(Variant, grab_click_focus);
    METHOD(void, set_drag_forwarding);
    METHOD(void, set_drag_preview);
    METHOD(bool, is_drag_successful);
    METHOD(Variant, warp_mouse);
    METHOD(void, set_shortcut_context);
    METHOD(Object, get_shortcut_context);
    METHOD(Variant, update_minimum_size);
    METHOD(void, set_layout_direction);
    METHOD(int64_t, get_layout_direction);
    METHOD(bool, is_layout_rtl);
    METHOD(void, set_auto_translate);
    METHOD(bool, is_auto_translating);
    METHOD(void, set_localize_numeral_system);
    METHOD(bool, is_localizing_numeral_system);
    static constexpr int64_t FOCUS_NONE = 0;
    static constexpr int64_t FOCUS_CLICK = 1;
    static constexpr int64_t FOCUS_ALL = 2;
    static constexpr int64_t NOTIFICATION_RESIZED = 40;
    static constexpr int64_t NOTIFICATION_MOUSE_ENTER = 41;
    static constexpr int64_t NOTIFICATION_MOUSE_EXIT = 42;
    static constexpr int64_t NOTIFICATION_MOUSE_ENTER_SELF = 60;
    static constexpr int64_t NOTIFICATION_MOUSE_EXIT_SELF = 61;
    static constexpr int64_t NOTIFICATION_FOCUS_ENTER = 43;
    static constexpr int64_t NOTIFICATION_FOCUS_EXIT = 44;
    static constexpr int64_t NOTIFICATION_THEME_CHANGED = 45;
    static constexpr int64_t NOTIFICATION_SCROLL_BEGIN = 47;
    static constexpr int64_t NOTIFICATION_SCROLL_END = 48;
    static constexpr int64_t NOTIFICATION_LAYOUT_DIRECTION_CHANGED = 49;
    static constexpr int64_t CURSOR_ARROW = 0;
    static constexpr int64_t CURSOR_IBEAM = 1;
    static constexpr int64_t CURSOR_POINTING_HAND = 2;
    static constexpr int64_t CURSOR_CROSS = 3;
    static constexpr int64_t CURSOR_WAIT = 4;
    static constexpr int64_t CURSOR_BUSY = 5;
    static constexpr int64_t CURSOR_DRAG = 6;
    static constexpr int64_t CURSOR_CAN_DROP = 7;
    static constexpr int64_t CURSOR_FORBIDDEN = 8;
    static constexpr int64_t CURSOR_VSIZE = 9;
    static constexpr int64_t CURSOR_HSIZE = 10;
    static constexpr int64_t CURSOR_BDIAGSIZE = 11;
    static constexpr int64_t CURSOR_FDIAGSIZE = 12;
    static constexpr int64_t CURSOR_MOVE = 13;
    static constexpr int64_t CURSOR_VSPLIT = 14;
    static constexpr int64_t CURSOR_HSPLIT = 15;
    static constexpr int64_t CURSOR_HELP = 16;
    static constexpr int64_t PRESET_TOP_LEFT = 0;
    static constexpr int64_t PRESET_TOP_RIGHT = 1;
    static constexpr int64_t PRESET_BOTTOM_LEFT = 2;
    static constexpr int64_t PRESET_BOTTOM_RIGHT = 3;
    static constexpr int64_t PRESET_CENTER_LEFT = 4;
    static constexpr int64_t PRESET_CENTER_TOP = 5;
    static constexpr int64_t PRESET_CENTER_RIGHT = 6;
    static constexpr int64_t PRESET_CENTER_BOTTOM = 7;
    static constexpr int64_t PRESET_CENTER = 8;
    static constexpr int64_t PRESET_LEFT_WIDE = 9;
    static constexpr int64_t PRESET_TOP_WIDE = 10;
    static constexpr int64_t PRESET_RIGHT_WIDE = 11;
    static constexpr int64_t PRESET_BOTTOM_WIDE = 12;
    static constexpr int64_t PRESET_VCENTER_WIDE = 13;
    static constexpr int64_t PRESET_HCENTER_WIDE = 14;
    static constexpr int64_t PRESET_FULL_RECT = 15;
    static constexpr int64_t PRESET_MODE_MINSIZE = 0;
    static constexpr int64_t PRESET_MODE_KEEP_WIDTH = 1;
    static constexpr int64_t PRESET_MODE_KEEP_HEIGHT = 2;
    static constexpr int64_t PRESET_MODE_KEEP_SIZE = 3;
    static constexpr int64_t SIZE_SHRINK_BEGIN = 0;
    static constexpr int64_t SIZE_FILL = 1;
    static constexpr int64_t SIZE_EXPAND = 2;
    static constexpr int64_t SIZE_EXPAND_FILL = 3;
    static constexpr int64_t SIZE_SHRINK_CENTER = 4;
    static constexpr int64_t SIZE_SHRINK_END = 8;
    static constexpr int64_t MOUSE_FILTER_STOP = 0;
    static constexpr int64_t MOUSE_FILTER_PASS = 1;
    static constexpr int64_t MOUSE_FILTER_IGNORE = 2;
    static constexpr int64_t GROW_DIRECTION_BEGIN = 0;
    static constexpr int64_t GROW_DIRECTION_END = 1;
    static constexpr int64_t GROW_DIRECTION_BOTH = 2;
    static constexpr int64_t ANCHOR_BEGIN = 0;
    static constexpr int64_t ANCHOR_END = 1;
    static constexpr int64_t LAYOUT_DIRECTION_INHERITED = 0;
    static constexpr int64_t LAYOUT_DIRECTION_LOCALE = 1;
    static constexpr int64_t LAYOUT_DIRECTION_LTR = 2;
    static constexpr int64_t LAYOUT_DIRECTION_RTL = 3;
    static constexpr int64_t TEXT_DIRECTION_INHERITED = 3;
    static constexpr int64_t TEXT_DIRECTION_AUTO = 0;
    static constexpr int64_t TEXT_DIRECTION_LTR = 1;
    static constexpr int64_t TEXT_DIRECTION_RTL = 2;
};
struct DebugAdapterParser : public Object {
    using Object::Object;
    METHOD(Dictionary, req_initialize);
    METHOD(Dictionary, req_disconnect);
    METHOD(Dictionary, req_launch);
    METHOD(Dictionary, req_attach);
    METHOD(Dictionary, req_restart);
    METHOD(Dictionary, req_terminate);
    METHOD(Dictionary, req_configurationDone);
    METHOD(Dictionary, req_pause);
    METHOD(Dictionary, req_continue);
    METHOD(Dictionary, req_threads);
    METHOD(Dictionary, req_stackTrace);
    METHOD(Dictionary, req_setBreakpoints);
    METHOD(Dictionary, req_breakpointLocations);
    METHOD(Dictionary, req_scopes);
    METHOD(Dictionary, req_variables);
    METHOD(Dictionary, req_next);
    METHOD(Dictionary, req_stepIn);
    METHOD(Dictionary, req_evaluate);
};
struct DisplayServer : public Object {
    using Object::Object;
    METHOD(bool, has_feature);
    METHOD(String, get_name);
    METHOD(Variant, help_set_search_callbacks);
    METHOD(Variant, global_menu_set_popup_callbacks);
    METHOD(int64_t, global_menu_add_submenu_item);
    METHOD(int64_t, global_menu_add_item);
    METHOD(int64_t, global_menu_add_check_item);
    METHOD(int64_t, global_menu_add_icon_item);
    METHOD(int64_t, global_menu_add_icon_check_item);
    METHOD(int64_t, global_menu_add_radio_check_item);
    METHOD(int64_t, global_menu_add_icon_radio_check_item);
    METHOD(int64_t, global_menu_add_multistate_item);
    METHOD(int64_t, global_menu_add_separator);
    METHOD(int64_t, global_menu_get_item_index_from_text);
    METHOD(int64_t, global_menu_get_item_index_from_tag);
    METHOD(bool, global_menu_is_item_checked);
    METHOD(bool, global_menu_is_item_checkable);
    METHOD(bool, global_menu_is_item_radio_checkable);
    METHOD(Callable, global_menu_get_item_callback);
    METHOD(Callable, global_menu_get_item_key_callback);
    METHOD(Variant, global_menu_get_item_tag);
    METHOD(String, global_menu_get_item_text);
    METHOD(String, global_menu_get_item_submenu);
    METHOD(int64_t, global_menu_get_item_accelerator);
    METHOD(bool, global_menu_is_item_disabled);
    METHOD(bool, global_menu_is_item_hidden);
    METHOD(String, global_menu_get_item_tooltip);
    METHOD(int64_t, global_menu_get_item_state);
    METHOD(int64_t, global_menu_get_item_max_states);
    METHOD(Object, global_menu_get_item_icon);
    METHOD(int64_t, global_menu_get_item_indentation_level);
    METHOD(Variant, global_menu_set_item_checked);
    METHOD(Variant, global_menu_set_item_checkable);
    METHOD(Variant, global_menu_set_item_radio_checkable);
    METHOD(Variant, global_menu_set_item_callback);
    METHOD(Variant, global_menu_set_item_hover_callbacks);
    METHOD(Variant, global_menu_set_item_key_callback);
    METHOD(Variant, global_menu_set_item_tag);
    METHOD(Variant, global_menu_set_item_text);
    METHOD(Variant, global_menu_set_item_submenu);
    METHOD(Variant, global_menu_set_item_accelerator);
    METHOD(Variant, global_menu_set_item_disabled);
    METHOD(Variant, global_menu_set_item_hidden);
    METHOD(Variant, global_menu_set_item_tooltip);
    METHOD(Variant, global_menu_set_item_state);
    METHOD(Variant, global_menu_set_item_max_states);
    METHOD(Variant, global_menu_set_item_icon);
    METHOD(Variant, global_menu_set_item_indentation_level);
    METHOD(int64_t, global_menu_get_item_count);
    METHOD(Variant, global_menu_remove_item);
    METHOD(Variant, global_menu_clear);
    METHOD(Dictionary, global_menu_get_system_menu_roots);
    METHOD(bool, tts_is_speaking);
    METHOD(bool, tts_is_paused);
    METHOD(Array, tts_get_voices);
    METHOD(PackedArray<std::string>, tts_get_voices_for_language);
    METHOD(Variant, tts_speak);
    METHOD(Variant, tts_pause);
    METHOD(Variant, tts_resume);
    METHOD(Variant, tts_stop);
    METHOD(Variant, tts_set_utterance_callback);
    METHOD(Variant, _tts_post_utterance_event);
    METHOD(bool, is_dark_mode_supported);
    METHOD(bool, is_dark_mode);
    METHOD(Color, get_accent_color);
    METHOD(Color, get_base_color);
    METHOD(void, set_system_theme_change_callback);
    METHOD(Variant, mouse_set_mode);
    METHOD(int64_t, mouse_get_mode);
    METHOD(Variant, warp_mouse);
    METHOD(Vector2i, mouse_get_position);
    METHOD(int64_t, mouse_get_button_state);
    METHOD(Variant, clipboard_set);
    METHOD(String, clipboard_get);
    METHOD(Object, clipboard_get_image);
    METHOD(bool, clipboard_has);
    METHOD(bool, clipboard_has_image);
    METHOD(Variant, clipboard_set_primary);
    METHOD(String, clipboard_get_primary);
    METHOD(Array, get_display_cutouts);
    METHOD(Rect2i, get_display_safe_area);
    METHOD(int64_t, get_screen_count);
    METHOD(int64_t, get_primary_screen);
    METHOD(int64_t, get_keyboard_focus_screen);
    METHOD(int64_t, get_screen_from_rect);
    METHOD(Vector2i, screen_get_position);
    METHOD(Vector2i, screen_get_size);
    METHOD(Rect2i, screen_get_usable_rect);
    METHOD(int64_t, screen_get_dpi);
    METHOD(double, screen_get_scale);
    METHOD(bool, is_touchscreen_available);
    METHOD(double, screen_get_max_scale);
    METHOD(double, screen_get_refresh_rate);
    METHOD(Color, screen_get_pixel);
    METHOD(Object, screen_get_image);
    METHOD(Variant, screen_set_orientation);
    METHOD(int64_t, screen_get_orientation);
    METHOD(Variant, screen_set_keep_on);
    METHOD(bool, screen_is_kept_on);
    METHOD(PackedArray<int32_t>, get_window_list);
    METHOD(int64_t, get_window_at_screen_position);
    METHOD(int64_t, window_get_native_handle);
    METHOD(int64_t, window_get_active_popup);
    METHOD(Variant, window_set_popup_safe_rect);
    METHOD(Rect2i, window_get_popup_safe_rect);
    METHOD(Variant, window_set_title);
    METHOD(Vector2i, window_get_title_size);
    METHOD(Variant, window_set_mouse_passthrough);
    METHOD(int64_t, window_get_current_screen);
    METHOD(Variant, window_set_current_screen);
    METHOD(Vector2i, window_get_position);
    METHOD(Vector2i, window_get_position_with_decorations);
    METHOD(Variant, window_set_position);
    METHOD(Vector2i, window_get_size);
    METHOD(Variant, window_set_size);
    METHOD(Variant, window_set_rect_changed_callback);
    METHOD(Variant, window_set_window_event_callback);
    METHOD(Variant, window_set_input_event_callback);
    METHOD(Variant, window_set_input_text_callback);
    METHOD(Variant, window_set_drop_files_callback);
    METHOD(int64_t, window_get_attached_instance_id);
    METHOD(Vector2i, window_get_max_size);
    METHOD(Variant, window_set_max_size);
    METHOD(Vector2i, window_get_min_size);
    METHOD(Variant, window_set_min_size);
    METHOD(Vector2i, window_get_size_with_decorations);
    METHOD(int64_t, window_get_mode);
    METHOD(Variant, window_set_mode);
    METHOD(Variant, window_set_flag);
    METHOD(bool, window_get_flag);
    METHOD(Variant, window_set_window_buttons_offset);
    METHOD(Vector3i, window_get_safe_title_margins);
    METHOD(Variant, window_request_attention);
    METHOD(Variant, window_move_to_foreground);
    METHOD(bool, window_is_focused);
    METHOD(bool, window_can_draw);
    METHOD(Variant, window_set_transient);
    METHOD(Variant, window_set_exclusive);
    METHOD(Variant, window_set_ime_active);
    METHOD(Variant, window_set_ime_position);
    METHOD(Variant, window_set_vsync_mode);
    METHOD(int64_t, window_get_vsync_mode);
    METHOD(bool, window_is_maximize_allowed);
    METHOD(bool, window_maximize_on_title_dbl_click);
    METHOD(bool, window_minimize_on_title_dbl_click);
    METHOD(Vector2i, ime_get_selection);
    METHOD(String, ime_get_text);
    METHOD(Variant, virtual_keyboard_show);
    METHOD(Variant, virtual_keyboard_hide);
    METHOD(int64_t, virtual_keyboard_get_height);
    METHOD(Variant, cursor_set_shape);
    METHOD(int64_t, cursor_get_shape);
    METHOD(Variant, cursor_set_custom_image);
    METHOD(bool, get_swap_cancel_ok);
    METHOD(Variant, enable_for_stealing_focus);
    METHOD(int64_t, dialog_show);
    METHOD(int64_t, dialog_input_text);
    METHOD(int64_t, file_dialog_show);
    METHOD(int64_t, file_dialog_with_options_show);
    METHOD(int64_t, keyboard_get_layout_count);
    METHOD(int64_t, keyboard_get_current_layout);
    METHOD(Variant, keyboard_set_current_layout);
    METHOD(String, keyboard_get_layout_language);
    METHOD(String, keyboard_get_layout_name);
    METHOD(int64_t, keyboard_get_keycode_from_physical);
    METHOD(int64_t, keyboard_get_label_from_physical);
    METHOD(Variant, process_events);
    METHOD(Variant, force_process_and_drop_events);
    METHOD(void, set_native_icon);
    METHOD(void, set_icon);
    METHOD(int64_t, create_status_indicator);
    METHOD(Variant, status_indicator_set_icon);
    METHOD(Variant, status_indicator_set_tooltip);
    METHOD(Variant, status_indicator_set_menu);
    METHOD(Variant, status_indicator_set_callback);
    METHOD(Rect2, status_indicator_get_rect);
    METHOD(Variant, delete_status_indicator);
    METHOD(int64_t, tablet_get_driver_count);
    METHOD(String, tablet_get_driver_name);
    METHOD(String, tablet_get_current_driver);
    METHOD(Variant, tablet_set_current_driver);
    METHOD(bool, is_window_transparency_available);
    METHOD(Variant, register_additional_output);
    METHOD(Variant, unregister_additional_output);
    METHOD(bool, has_additional_outputs);
    static constexpr int64_t FEATURE_GLOBAL_MENU = 0;
    static constexpr int64_t FEATURE_SUBWINDOWS = 1;
    static constexpr int64_t FEATURE_TOUCHSCREEN = 2;
    static constexpr int64_t FEATURE_MOUSE = 3;
    static constexpr int64_t FEATURE_MOUSE_WARP = 4;
    static constexpr int64_t FEATURE_CLIPBOARD = 5;
    static constexpr int64_t FEATURE_VIRTUAL_KEYBOARD = 6;
    static constexpr int64_t FEATURE_CURSOR_SHAPE = 7;
    static constexpr int64_t FEATURE_CUSTOM_CURSOR_SHAPE = 8;
    static constexpr int64_t FEATURE_NATIVE_DIALOG = 9;
    static constexpr int64_t FEATURE_IME = 10;
    static constexpr int64_t FEATURE_WINDOW_TRANSPARENCY = 11;
    static constexpr int64_t FEATURE_HIDPI = 12;
    static constexpr int64_t FEATURE_ICON = 13;
    static constexpr int64_t FEATURE_NATIVE_ICON = 14;
    static constexpr int64_t FEATURE_ORIENTATION = 15;
    static constexpr int64_t FEATURE_SWAP_BUFFERS = 16;
    static constexpr int64_t FEATURE_CLIPBOARD_PRIMARY = 18;
    static constexpr int64_t FEATURE_TEXT_TO_SPEECH = 19;
    static constexpr int64_t FEATURE_EXTEND_TO_TITLE = 20;
    static constexpr int64_t FEATURE_SCREEN_CAPTURE = 21;
    static constexpr int64_t FEATURE_STATUS_INDICATOR = 22;
    static constexpr int64_t FEATURE_NATIVE_HELP = 23;
    static constexpr int64_t FEATURE_NATIVE_DIALOG_INPUT = 24;
    static constexpr int64_t FEATURE_NATIVE_DIALOG_FILE = 25;
    static constexpr int64_t MOUSE_MODE_VISIBLE = 0;
    static constexpr int64_t MOUSE_MODE_HIDDEN = 1;
    static constexpr int64_t MOUSE_MODE_CAPTURED = 2;
    static constexpr int64_t MOUSE_MODE_CONFINED = 3;
    static constexpr int64_t MOUSE_MODE_CONFINED_HIDDEN = 4;
    static constexpr int64_t SCREEN_WITH_MOUSE_FOCUS = -4;
    static constexpr int64_t SCREEN_WITH_KEYBOARD_FOCUS = -3;
    static constexpr int64_t SCREEN_PRIMARY = -2;
    static constexpr int64_t SCREEN_OF_MAIN_WINDOW = -1;
    static constexpr int64_t MAIN_WINDOW_ID = 0;
    static constexpr int64_t INVALID_WINDOW_ID = -1;
    static constexpr int64_t INVALID_INDICATOR_ID = -1;
    static constexpr int64_t SCREEN_LANDSCAPE = 0;
    static constexpr int64_t SCREEN_PORTRAIT = 1;
    static constexpr int64_t SCREEN_REVERSE_LANDSCAPE = 2;
    static constexpr int64_t SCREEN_REVERSE_PORTRAIT = 3;
    static constexpr int64_t SCREEN_SENSOR_LANDSCAPE = 4;
    static constexpr int64_t SCREEN_SENSOR_PORTRAIT = 5;
    static constexpr int64_t SCREEN_SENSOR = 6;
    static constexpr int64_t KEYBOARD_TYPE_DEFAULT = 0;
    static constexpr int64_t KEYBOARD_TYPE_MULTILINE = 1;
    static constexpr int64_t KEYBOARD_TYPE_NUMBER = 2;
    static constexpr int64_t KEYBOARD_TYPE_NUMBER_DECIMAL = 3;
    static constexpr int64_t KEYBOARD_TYPE_PHONE = 4;
    static constexpr int64_t KEYBOARD_TYPE_EMAIL_ADDRESS = 5;
    static constexpr int64_t KEYBOARD_TYPE_PASSWORD = 6;
    static constexpr int64_t KEYBOARD_TYPE_URL = 7;
    static constexpr int64_t CURSOR_ARROW = 0;
    static constexpr int64_t CURSOR_IBEAM = 1;
    static constexpr int64_t CURSOR_POINTING_HAND = 2;
    static constexpr int64_t CURSOR_CROSS = 3;
    static constexpr int64_t CURSOR_WAIT = 4;
    static constexpr int64_t CURSOR_BUSY = 5;
    static constexpr int64_t CURSOR_DRAG = 6;
    static constexpr int64_t CURSOR_CAN_DROP = 7;
    static constexpr int64_t CURSOR_FORBIDDEN = 8;
    static constexpr int64_t CURSOR_VSIZE = 9;
    static constexpr int64_t CURSOR_HSIZE = 10;
    static constexpr int64_t CURSOR_BDIAGSIZE = 11;
    static constexpr int64_t CURSOR_FDIAGSIZE = 12;
    static constexpr int64_t CURSOR_MOVE = 13;
    static constexpr int64_t CURSOR_VSPLIT = 14;
    static constexpr int64_t CURSOR_HSPLIT = 15;
    static constexpr int64_t CURSOR_HELP = 16;
    static constexpr int64_t CURSOR_MAX = 17;
    static constexpr int64_t FILE_DIALOG_MODE_OPEN_FILE = 0;
    static constexpr int64_t FILE_DIALOG_MODE_OPEN_FILES = 1;
    static constexpr int64_t FILE_DIALOG_MODE_OPEN_DIR = 2;
    static constexpr int64_t FILE_DIALOG_MODE_OPEN_ANY = 3;
    static constexpr int64_t FILE_DIALOG_MODE_SAVE_FILE = 4;
    static constexpr int64_t WINDOW_MODE_WINDOWED = 0;
    static constexpr int64_t WINDOW_MODE_MINIMIZED = 1;
    static constexpr int64_t WINDOW_MODE_MAXIMIZED = 2;
    static constexpr int64_t WINDOW_MODE_FULLSCREEN = 3;
    static constexpr int64_t WINDOW_MODE_EXCLUSIVE_FULLSCREEN = 4;
    static constexpr int64_t WINDOW_FLAG_RESIZE_DISABLED = 0;
    static constexpr int64_t WINDOW_FLAG_BORDERLESS = 1;
    static constexpr int64_t WINDOW_FLAG_ALWAYS_ON_TOP = 2;
    static constexpr int64_t WINDOW_FLAG_TRANSPARENT = 3;
    static constexpr int64_t WINDOW_FLAG_NO_FOCUS = 4;
    static constexpr int64_t WINDOW_FLAG_POPUP = 5;
    static constexpr int64_t WINDOW_FLAG_EXTEND_TO_TITLE = 6;
    static constexpr int64_t WINDOW_FLAG_MOUSE_PASSTHROUGH = 7;
    static constexpr int64_t WINDOW_FLAG_MAX = 8;
    static constexpr int64_t WINDOW_EVENT_MOUSE_ENTER = 0;
    static constexpr int64_t WINDOW_EVENT_MOUSE_EXIT = 1;
    static constexpr int64_t WINDOW_EVENT_FOCUS_IN = 2;
    static constexpr int64_t WINDOW_EVENT_FOCUS_OUT = 3;
    static constexpr int64_t WINDOW_EVENT_CLOSE_REQUEST = 4;
    static constexpr int64_t WINDOW_EVENT_GO_BACK_REQUEST = 5;
    static constexpr int64_t WINDOW_EVENT_DPI_CHANGE = 6;
    static constexpr int64_t WINDOW_EVENT_TITLEBAR_CHANGE = 7;
    static constexpr int64_t VSYNC_DISABLED = 0;
    static constexpr int64_t VSYNC_ENABLED = 1;
    static constexpr int64_t VSYNC_ADAPTIVE = 2;
    static constexpr int64_t VSYNC_MAILBOX = 3;
    static constexpr int64_t DISPLAY_HANDLE = 0;
    static constexpr int64_t WINDOW_HANDLE = 1;
    static constexpr int64_t WINDOW_VIEW = 2;
    static constexpr int64_t OPENGL_CONTEXT = 3;
    static constexpr int64_t TTS_UTTERANCE_STARTED = 0;
    static constexpr int64_t TTS_UTTERANCE_ENDED = 1;
    static constexpr int64_t TTS_UTTERANCE_CANCELED = 2;
    static constexpr int64_t TTS_UTTERANCE_BOUNDARY = 3;
    static DisplayServer get_singleton() { return DisplayServer(Object("DisplayServer").address()); }
};
struct Engine : public Object {
    using Object::Object;
    PROPERTY(print_error_messages, bool);
    PROPERTY(physics_ticks_per_second, int64_t);
    PROPERTY(max_physics_steps_per_frame, int64_t);
    PROPERTY(max_fps, int64_t);
    PROPERTY(time_scale, double);
    PROPERTY(physics_jitter_fix, double);
    METHOD(void, set_physics_ticks_per_second);
    METHOD(int64_t, get_physics_ticks_per_second);
    METHOD(void, set_max_physics_steps_per_frame);
    METHOD(int64_t, get_max_physics_steps_per_frame);
    METHOD(void, set_physics_jitter_fix);
    METHOD(double, get_physics_jitter_fix);
    METHOD(double, get_physics_interpolation_fraction);
    METHOD(void, set_max_fps);
    METHOD(int64_t, get_max_fps);
    METHOD(void, set_time_scale);
    METHOD(double, get_time_scale);
    METHOD(int64_t, get_frames_drawn);
    METHOD(double, get_frames_per_second);
    METHOD(int64_t, get_physics_frames);
    METHOD(int64_t, get_process_frames);
    METHOD(Object, get_main_loop);
    METHOD(Dictionary, get_version_info);
    METHOD(Dictionary, get_author_info);
    METHOD(Array, get_copyright_info);
    METHOD(Dictionary, get_donor_info);
    METHOD(Dictionary, get_license_info);
    METHOD(String, get_license_text);
    METHOD(String, get_architecture_name);
    METHOD(bool, is_in_physics_frame);
    METHOD(bool, has_singleton);
    METHOD(Object, get_singleton);
    METHOD(Variant, register_singleton);
    METHOD(Variant, unregister_singleton);
    METHOD(PackedArray<std::string>, get_singleton_list);
    METHOD(int64_t, register_script_language);
    METHOD(int64_t, unregister_script_language);
    METHOD(int64_t, get_script_language_count);
    METHOD(Object, get_script_language);
    METHOD(bool, is_editor_hint);
    METHOD(String, get_write_movie_path);
    METHOD(void, set_print_error_messages);
    METHOD(bool, is_printing_error_messages);
    static Engine get_singleton() { return Engine(Object("Engine").address()); }
};
struct EngineDebugger : public Object {
    using Object::Object;
    METHOD(bool, is_active);
    METHOD(Variant, register_profiler);
    METHOD(Variant, unregister_profiler);
    METHOD(bool, is_profiling);
    METHOD(bool, has_profiler);
    METHOD(Variant, profiler_add_frame_data);
    METHOD(Variant, profiler_enable);
    METHOD(Variant, register_message_capture);
    METHOD(Variant, unregister_message_capture);
    METHOD(bool, has_capture);
    METHOD(Variant, line_poll);
    METHOD(Variant, send_message);
    METHOD(Variant, debug);
    METHOD(Variant, script_debug);
    METHOD(void, set_lines_left);
    METHOD(int64_t, get_lines_left);
    METHOD(void, set_depth);
    METHOD(int64_t, get_depth);
    METHOD(bool, is_breakpoint);
    METHOD(bool, is_skipping_breakpoints);
    METHOD(Variant, insert_breakpoint);
    METHOD(Variant, remove_breakpoint);
    METHOD(Variant, clear_breakpoints);
    static EngineDebugger get_singleton() { return EngineDebugger(Object("EngineDebugger").address()); }
};
struct FindInFiles : public Node {
    using Node::Node;
};
struct FindInFilesPanel : public Control {
    using Control::Control;
    METHOD(Variant, _on_result_found);
    METHOD(Variant, _on_finished);
};
struct FramebufferCacheRD : public Object {
    using Object::Object;
    METHOD(::RID, get_cache_multipass);
};
struct GDExtensionManager : public Object {
    using Object::Object;
    METHOD(int64_t, load_extension);
    METHOD(int64_t, reload_extension);
    METHOD(int64_t, unload_extension);
    METHOD(bool, is_extension_loaded);
    METHOD(PackedArray<std::string>, get_loaded_extensions);
    METHOD(Object, get_extension);
    static constexpr int64_t LOAD_STATUS_OK = 0;
    static constexpr int64_t LOAD_STATUS_FAILED = 1;
    static constexpr int64_t LOAD_STATUS_ALREADY_LOADED = 2;
    static constexpr int64_t LOAD_STATUS_NOT_LOADED = 3;
    static constexpr int64_t LOAD_STATUS_NEEDS_RESTART = 4;
    static GDExtensionManager get_singleton() { return GDExtensionManager(Object("GDExtensionManager").address()); }
};
struct GPUParticles2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(emitting, bool);
    PROPERTY(amount, int64_t);
    PROPERTY(amount_ratio, double);
    PROPERTY(sub_emitter, String);
    PROPERTY(process_material, Object);
    PROPERTY(texture, Object);
    PROPERTY(lifetime, double);
    PROPERTY(one_shot, bool);
    PROPERTY(preprocess, double);
    PROPERTY(speed_scale, double);
    PROPERTY(explosiveness, double);
    PROPERTY(randomness, double);
    PROPERTY(fixed_fps, int64_t);
    PROPERTY(interpolate, bool);
    PROPERTY(fract_delta, bool);
    PROPERTY(interp_to_end, double);
    PROPERTY(collision_base_size, double);
    PROPERTY(visibility_rect, Rect2);
    PROPERTY(local_coords, bool);
    PROPERTY(draw_order, int64_t);
    PROPERTY(trail_enabled, bool);
    PROPERTY(trail_lifetime, double);
    PROPERTY(trail_sections, int64_t);
    PROPERTY(trail_section_subdivisions, int64_t);
    METHOD(void, set_emitting);
    METHOD(void, set_amount);
    METHOD(void, set_lifetime);
    METHOD(void, set_one_shot);
    METHOD(void, set_pre_process_time);
    METHOD(void, set_explosiveness_ratio);
    METHOD(void, set_randomness_ratio);
    METHOD(void, set_visibility_rect);
    METHOD(void, set_use_local_coordinates);
    METHOD(void, set_fixed_fps);
    METHOD(void, set_fractional_delta);
    METHOD(void, set_interpolate);
    METHOD(void, set_process_material);
    METHOD(void, set_speed_scale);
    METHOD(void, set_collision_base_size);
    METHOD(void, set_interp_to_end);
    METHOD(bool, is_emitting);
    METHOD(int64_t, get_amount);
    METHOD(double, get_lifetime);
    METHOD(bool, get_one_shot);
    METHOD(double, get_pre_process_time);
    METHOD(double, get_explosiveness_ratio);
    METHOD(double, get_randomness_ratio);
    METHOD(Rect2, get_visibility_rect);
    METHOD(bool, get_use_local_coordinates);
    METHOD(int64_t, get_fixed_fps);
    METHOD(bool, get_fractional_delta);
    METHOD(bool, get_interpolate);
    METHOD(Object, get_process_material);
    METHOD(double, get_speed_scale);
    METHOD(double, get_collision_base_size);
    METHOD(double, get_interp_to_end);
    METHOD(void, set_draw_order);
    METHOD(int64_t, get_draw_order);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(Rect2, capture_rect);
    METHOD(Variant, restart);
    METHOD(void, set_sub_emitter);
    METHOD(String, get_sub_emitter);
    METHOD(Variant, emit_particle);
    METHOD(void, set_trail_enabled);
    METHOD(void, set_trail_lifetime);
    METHOD(bool, is_trail_enabled);
    METHOD(double, get_trail_lifetime);
    METHOD(void, set_trail_sections);
    METHOD(int64_t, get_trail_sections);
    METHOD(void, set_trail_section_subdivisions);
    METHOD(int64_t, get_trail_section_subdivisions);
    METHOD(Variant, convert_from_particles);
    METHOD(void, set_amount_ratio);
    METHOD(double, get_amount_ratio);
    static constexpr int64_t DRAW_ORDER_INDEX = 0;
    static constexpr int64_t DRAW_ORDER_LIFETIME = 1;
    static constexpr int64_t DRAW_ORDER_REVERSE_LIFETIME = 2;
    static constexpr int64_t EMIT_FLAG_POSITION = 1;
    static constexpr int64_t EMIT_FLAG_ROTATION_SCALE = 2;
    static constexpr int64_t EMIT_FLAG_VELOCITY = 4;
    static constexpr int64_t EMIT_FLAG_COLOR = 8;
    static constexpr int64_t EMIT_FLAG_CUSTOM = 16;
};
struct Geometry2D : public Object {
    using Object::Object;
    METHOD(bool, is_point_in_circle);
    METHOD(double, segment_intersects_circle);
    METHOD(Variant, segment_intersects_segment);
    METHOD(Variant, line_intersects_line);
    METHOD(PackedArray<Vector2>, get_closest_points_between_segments);
    METHOD(Vector2, get_closest_point_to_segment);
    METHOD(Vector2, get_closest_point_to_segment_uncapped);
    METHOD(bool, point_is_inside_triangle);
    METHOD(bool, is_polygon_clockwise);
    METHOD(bool, is_point_in_polygon);
    METHOD(PackedArray<int32_t>, triangulate_polygon);
    METHOD(PackedArray<int32_t>, triangulate_delaunay);
    METHOD(PackedArray<Vector2>, convex_hull);
    METHOD(Array, decompose_polygon_in_convex);
    METHOD(Array, merge_polygons);
    METHOD(Array, clip_polygons);
    METHOD(Array, intersect_polygons);
    METHOD(Array, exclude_polygons);
    METHOD(Array, clip_polyline_with_polygon);
    METHOD(Array, intersect_polyline_with_polygon);
    METHOD(Array, offset_polygon);
    METHOD(Array, offset_polyline);
    METHOD(Dictionary, make_atlas);
    static constexpr int64_t OPERATION_UNION = 0;
    static constexpr int64_t OPERATION_DIFFERENCE = 1;
    static constexpr int64_t OPERATION_INTERSECTION = 2;
    static constexpr int64_t OPERATION_XOR = 3;
    static constexpr int64_t JOIN_SQUARE = 0;
    static constexpr int64_t JOIN_ROUND = 1;
    static constexpr int64_t JOIN_MITER = 2;
    static constexpr int64_t END_POLYGON = 0;
    static constexpr int64_t END_JOINED = 1;
    static constexpr int64_t END_BUTT = 2;
    static constexpr int64_t END_SQUARE = 3;
    static constexpr int64_t END_ROUND = 4;
    static Geometry2D get_singleton() { return Geometry2D(Object("Geometry2D").address()); }
};
struct Geometry3D : public Object {
    using Object::Object;
    METHOD(PackedArray<Vector3>, compute_convex_mesh_points);
    METHOD(Array, build_box_planes);
    METHOD(Array, build_cylinder_planes);
    METHOD(Array, build_capsule_planes);
    METHOD(PackedArray<Vector3>, get_closest_points_between_segments);
    METHOD(Vector3, get_closest_point_to_segment);
    METHOD(Vector3, get_closest_point_to_segment_uncapped);
    METHOD(Vector3, get_triangle_barycentric_coords);
    METHOD(Variant, ray_intersects_triangle);
    METHOD(Variant, segment_intersects_triangle);
    METHOD(PackedArray<Vector3>, segment_intersects_sphere);
    METHOD(PackedArray<Vector3>, segment_intersects_cylinder);
    METHOD(PackedArray<Vector3>, segment_intersects_convex);
    METHOD(PackedArray<Vector3>, clip_polygon);
    METHOD(PackedArray<int32_t>, tetrahedralize_delaunay);
    static Geometry3D get_singleton() { return Geometry3D(Object("Geometry3D").address()); }
};
struct GraphEdit : public Control {
    using Control::Control;
    PROPERTY(scroll_offset, Vector2);
    PROPERTY(show_grid, bool);
    PROPERTY(grid_pattern, int64_t);
    PROPERTY(snapping_enabled, bool);
    PROPERTY(snapping_distance, int64_t);
    PROPERTY(panning_scheme, int64_t);
    PROPERTY(right_disconnects, bool);
    PROPERTY(connection_lines_curvature, double);
    PROPERTY(connection_lines_thickness, double);
    PROPERTY(connection_lines_antialiased, bool);
    PROPERTY(zoom, double);
    PROPERTY(zoom_min, double);
    PROPERTY(zoom_max, double);
    PROPERTY(zoom_step, double);
    PROPERTY(minimap_enabled, bool);
    PROPERTY(minimap_size, Vector2);
    PROPERTY(minimap_opacity, double);
    PROPERTY(show_menu, bool);
    PROPERTY(show_zoom_label, bool);
    PROPERTY(show_zoom_buttons, bool);
    PROPERTY(show_grid_buttons, bool);
    PROPERTY(show_minimap_button, bool);
    PROPERTY(show_arrange_button, bool);
    METHOD(bool, _is_in_input_hotzone);
    METHOD(bool, _is_in_output_hotzone);
    METHOD(PackedArray<Vector2>, _get_connection_line);
    METHOD(bool, _is_node_hover_valid);
    METHOD(int64_t, connect_node);
    METHOD(bool, is_node_connected);
    METHOD(Variant, disconnect_node);
    METHOD(void, set_connection_activity);
    METHOD(Array, get_connection_list);
    METHOD(Dictionary, get_closest_connection_at_point);
    METHOD(Array, get_connections_intersecting_with_rect);
    METHOD(Variant, clear_connections);
    METHOD(Variant, force_connection_drag_end);
    METHOD(Vector2, get_scroll_offset);
    METHOD(void, set_scroll_offset);
    METHOD(Variant, add_valid_right_disconnect_type);
    METHOD(Variant, remove_valid_right_disconnect_type);
    METHOD(Variant, add_valid_left_disconnect_type);
    METHOD(Variant, remove_valid_left_disconnect_type);
    METHOD(Variant, add_valid_connection_type);
    METHOD(Variant, remove_valid_connection_type);
    METHOD(bool, is_valid_connection_type);
    METHOD(PackedArray<Vector2>, get_connection_line);
    METHOD(Variant, attach_graph_element_to_frame);
    METHOD(Variant, detach_graph_element_from_frame);
    METHOD(Object, get_element_frame);
    METHOD(Array, get_attached_nodes_of_frame);
    METHOD(void, set_panning_scheme);
    METHOD(int64_t, get_panning_scheme);
    METHOD(void, set_zoom);
    METHOD(double, get_zoom);
    METHOD(void, set_zoom_min);
    METHOD(double, get_zoom_min);
    METHOD(void, set_zoom_max);
    METHOD(double, get_zoom_max);
    METHOD(void, set_zoom_step);
    METHOD(double, get_zoom_step);
    METHOD(void, set_show_grid);
    METHOD(bool, is_showing_grid);
    METHOD(void, set_grid_pattern);
    METHOD(int64_t, get_grid_pattern);
    METHOD(void, set_snapping_enabled);
    METHOD(bool, is_snapping_enabled);
    METHOD(void, set_snapping_distance);
    METHOD(int64_t, get_snapping_distance);
    METHOD(void, set_connection_lines_curvature);
    METHOD(double, get_connection_lines_curvature);
    METHOD(void, set_connection_lines_thickness);
    METHOD(double, get_connection_lines_thickness);
    METHOD(void, set_connection_lines_antialiased);
    METHOD(bool, is_connection_lines_antialiased);
    METHOD(void, set_minimap_size);
    METHOD(Vector2, get_minimap_size);
    METHOD(void, set_minimap_opacity);
    METHOD(double, get_minimap_opacity);
    METHOD(void, set_minimap_enabled);
    METHOD(bool, is_minimap_enabled);
    METHOD(void, set_show_menu);
    METHOD(bool, is_showing_menu);
    METHOD(void, set_show_zoom_label);
    METHOD(bool, is_showing_zoom_label);
    METHOD(void, set_show_grid_buttons);
    METHOD(bool, is_showing_grid_buttons);
    METHOD(void, set_show_zoom_buttons);
    METHOD(bool, is_showing_zoom_buttons);
    METHOD(void, set_show_minimap_button);
    METHOD(bool, is_showing_minimap_button);
    METHOD(void, set_show_arrange_button);
    METHOD(bool, is_showing_arrange_button);
    METHOD(void, set_right_disconnects);
    METHOD(bool, is_right_disconnects_enabled);
    METHOD(Object, get_menu_hbox);
    METHOD(Variant, arrange_nodes);
    METHOD(void, set_selected);
    static constexpr int64_t SCROLL_ZOOMS = 0;
    static constexpr int64_t SCROLL_PANS = 1;
    static constexpr int64_t GRID_PATTERN_LINES = 0;
    static constexpr int64_t GRID_PATTERN_DOTS = 1;
};
struct GraphEditFilter : public Control {
    using Control::Control;
};
struct GraphEditMinimap : public Control {
    using Control::Control;
};
struct GridMap : public Node3D {
    using Node3D::Node3D;
    PROPERTY(mesh_library, Object);
    PROPERTY(physics_material, Object);
    PROPERTY(cell_size, Vector3);
    PROPERTY(cell_octant_size, int64_t);
    PROPERTY(cell_center_x, bool);
    PROPERTY(cell_center_y, bool);
    PROPERTY(cell_center_z, bool);
    PROPERTY(cell_scale, double);
    PROPERTY(collision_layer, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(collision_priority, double);
    PROPERTY(bake_navigation, bool);
    METHOD(void, set_collision_layer);
    METHOD(int64_t, get_collision_layer);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_collision_layer_value);
    METHOD(bool, get_collision_layer_value);
    METHOD(void, set_collision_priority);
    METHOD(double, get_collision_priority);
    METHOD(void, set_physics_material);
    METHOD(Object, get_physics_material);
    METHOD(void, set_bake_navigation);
    METHOD(bool, is_baking_navigation);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_mesh_library);
    METHOD(Object, get_mesh_library);
    METHOD(void, set_cell_size);
    METHOD(Vector3, get_cell_size);
    METHOD(void, set_cell_scale);
    METHOD(double, get_cell_scale);
    METHOD(void, set_octant_size);
    METHOD(int64_t, get_octant_size);
    METHOD(void, set_cell_item);
    METHOD(int64_t, get_cell_item);
    METHOD(int64_t, get_cell_item_orientation);
    METHOD(Basis, get_cell_item_basis);
    METHOD(Basis, get_basis_with_orthogonal_index);
    METHOD(int64_t, get_orthogonal_index_from_basis);
    METHOD(Vector3i, local_to_map);
    METHOD(Vector3, map_to_local);
    METHOD(Variant, resource_changed);
    METHOD(void, set_center_x);
    METHOD(bool, get_center_x);
    METHOD(void, set_center_y);
    METHOD(bool, get_center_y);
    METHOD(void, set_center_z);
    METHOD(bool, get_center_z);
    METHOD(Variant, clear);
    METHOD(Array, get_used_cells);
    METHOD(Array, get_used_cells_by_item);
    METHOD(Array, get_meshes);
    METHOD(Array, get_bake_meshes);
    METHOD(::RID, get_bake_mesh_instance);
    METHOD(Variant, clear_baked_meshes);
    METHOD(Variant, make_baked_meshes);
    static constexpr int64_t INVALID_CELL_ITEM = -1;
};
struct HTTPRequest : public Node {
    using Node::Node;
    PROPERTY(download_file, String);
    PROPERTY(download_chunk_size, int64_t);
    PROPERTY(use_threads, bool);
    PROPERTY(accept_gzip, bool);
    PROPERTY(body_size_limit, int64_t);
    PROPERTY(max_redirects, int64_t);
    PROPERTY(timeout, double);
    METHOD(int64_t, request);
    METHOD(int64_t, request_raw);
    METHOD(Variant, cancel_request);
    METHOD(void, set_tls_options);
    METHOD(int64_t, get_http_client_status);
    METHOD(void, set_use_threads);
    METHOD(bool, is_using_threads);
    METHOD(void, set_accept_gzip);
    METHOD(bool, is_accepting_gzip);
    METHOD(void, set_body_size_limit);
    METHOD(int64_t, get_body_size_limit);
    METHOD(void, set_max_redirects);
    METHOD(int64_t, get_max_redirects);
    METHOD(void, set_download_file);
    METHOD(String, get_download_file);
    METHOD(int64_t, get_downloaded_bytes);
    METHOD(int64_t, get_body_size);
    METHOD(void, set_timeout);
    METHOD(double, get_timeout);
    METHOD(void, set_download_chunk_size);
    METHOD(int64_t, get_download_chunk_size);
    METHOD(void, set_http_proxy);
    METHOD(void, set_https_proxy);
    static constexpr int64_t RESULT_SUCCESS = 0;
    static constexpr int64_t RESULT_CHUNKED_BODY_SIZE_MISMATCH = 1;
    static constexpr int64_t RESULT_CANT_CONNECT = 2;
    static constexpr int64_t RESULT_CANT_RESOLVE = 3;
    static constexpr int64_t RESULT_CONNECTION_ERROR = 4;
    static constexpr int64_t RESULT_TLS_HANDSHAKE_ERROR = 5;
    static constexpr int64_t RESULT_NO_RESPONSE = 6;
    static constexpr int64_t RESULT_BODY_SIZE_LIMIT_EXCEEDED = 7;
    static constexpr int64_t RESULT_BODY_DECOMPRESS_FAILED = 8;
    static constexpr int64_t RESULT_REQUEST_FAILED = 9;
    static constexpr int64_t RESULT_DOWNLOAD_FILE_CANT_OPEN = 10;
    static constexpr int64_t RESULT_DOWNLOAD_FILE_WRITE_ERROR = 11;
    static constexpr int64_t RESULT_REDIRECT_LIMIT_REACHED = 12;
    static constexpr int64_t RESULT_TIMEOUT = 13;
};
struct IP : public Object {
    using Object::Object;
    METHOD(String, resolve_hostname);
    METHOD(PackedArray<std::string>, resolve_hostname_addresses);
    METHOD(int64_t, resolve_hostname_queue_item);
    METHOD(int64_t, get_resolve_item_status);
    METHOD(String, get_resolve_item_address);
    METHOD(Array, get_resolve_item_addresses);
    METHOD(Variant, erase_resolve_item);
    METHOD(PackedArray<std::string>, get_local_addresses);
    METHOD(Array, get_local_interfaces);
    METHOD(Variant, clear_cache);
    static constexpr int64_t RESOLVER_STATUS_NONE = 0;
    static constexpr int64_t RESOLVER_STATUS_WAITING = 1;
    static constexpr int64_t RESOLVER_STATUS_DONE = 2;
    static constexpr int64_t RESOLVER_STATUS_ERROR = 3;
    static constexpr int64_t RESOLVER_MAX_QUERIES = 256;
    static constexpr int64_t RESOLVER_INVALID_ID = -1;
    static constexpr int64_t TYPE_NONE = 0;
    static constexpr int64_t TYPE_IPV4 = 1;
    static constexpr int64_t TYPE_IPV6 = 2;
    static constexpr int64_t TYPE_ANY = 3;
    static IP get_singleton() { return IP(Object("IP").address()); }
};
struct IPUnix : public IP {
    using IP::IP;
};
struct ImportDockParameters : public Object {
    using Object::Object;
};
struct ImporterMeshInstance3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(mesh, Object);
    PROPERTY(skin, Object);
    PROPERTY(skeleton_path, String);
    PROPERTY(layer_mask, int64_t);
    PROPERTY(cast_shadow, int64_t);
    PROPERTY(visibility_range_begin, double);
    PROPERTY(visibility_range_begin_margin, double);
    PROPERTY(visibility_range_end, double);
    PROPERTY(visibility_range_end_margin, double);
    PROPERTY(visibility_range_fade_mode, int64_t);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(void, set_skin);
    METHOD(Object, get_skin);
    METHOD(void, set_skeleton_path);
    METHOD(String, get_skeleton_path);
    METHOD(void, set_layer_mask);
    METHOD(int64_t, get_layer_mask);
    METHOD(void, set_cast_shadows_setting);
    METHOD(int64_t, get_cast_shadows_setting);
    METHOD(void, set_visibility_range_end_margin);
    METHOD(double, get_visibility_range_end_margin);
    METHOD(void, set_visibility_range_end);
    METHOD(double, get_visibility_range_end);
    METHOD(void, set_visibility_range_begin_margin);
    METHOD(double, get_visibility_range_begin_margin);
    METHOD(void, set_visibility_range_begin);
    METHOD(double, get_visibility_range_begin);
    METHOD(void, set_visibility_range_fade_mode);
    METHOD(int64_t, get_visibility_range_fade_mode);
};
struct Input : public Object {
    using Object::Object;
    PROPERTY(mouse_mode, int64_t);
    PROPERTY(use_accumulated_input, bool);
    PROPERTY(emulate_mouse_from_touch, bool);
    PROPERTY(emulate_touch_from_mouse, bool);
    METHOD(bool, is_anything_pressed);
    METHOD(bool, is_key_pressed);
    METHOD(bool, is_physical_key_pressed);
    METHOD(bool, is_key_label_pressed);
    METHOD(bool, is_mouse_button_pressed);
    METHOD(bool, is_joy_button_pressed);
    METHOD(bool, is_action_pressed);
    METHOD(bool, is_action_just_pressed);
    METHOD(bool, is_action_just_released);
    METHOD(double, get_action_strength);
    METHOD(double, get_action_raw_strength);
    METHOD(double, get_axis);
    METHOD(Vector2, get_vector);
    METHOD(Variant, add_joy_mapping);
    METHOD(Variant, remove_joy_mapping);
    METHOD(bool, is_joy_known);
    METHOD(double, get_joy_axis);
    METHOD(String, get_joy_name);
    METHOD(String, get_joy_guid);
    METHOD(Dictionary, get_joy_info);
    METHOD(bool, should_ignore_device);
    METHOD(Array, get_connected_joypads);
    METHOD(Vector2, get_joy_vibration_strength);
    METHOD(double, get_joy_vibration_duration);
    METHOD(Variant, start_joy_vibration);
    METHOD(Variant, stop_joy_vibration);
    METHOD(Variant, vibrate_handheld);
    METHOD(Vector3, get_gravity);
    METHOD(Vector3, get_accelerometer);
    METHOD(Vector3, get_magnetometer);
    METHOD(Vector3, get_gyroscope);
    METHOD(void, set_gravity);
    METHOD(void, set_accelerometer);
    METHOD(void, set_magnetometer);
    METHOD(void, set_gyroscope);
    METHOD(Vector2, get_last_mouse_velocity);
    METHOD(Vector2, get_last_mouse_screen_velocity);
    METHOD(int64_t, get_mouse_button_mask);
    METHOD(void, set_mouse_mode);
    METHOD(int64_t, get_mouse_mode);
    METHOD(Variant, warp_mouse);
    METHOD(Variant, action_press);
    METHOD(Variant, action_release);
    METHOD(void, set_default_cursor_shape);
    METHOD(int64_t, get_current_cursor_shape);
    METHOD(void, set_custom_mouse_cursor);
    METHOD(Variant, parse_input_event);
    METHOD(void, set_use_accumulated_input);
    METHOD(bool, is_using_accumulated_input);
    METHOD(Variant, flush_buffered_events);
    METHOD(void, set_emulate_mouse_from_touch);
    METHOD(bool, is_emulating_mouse_from_touch);
    METHOD(void, set_emulate_touch_from_mouse);
    METHOD(bool, is_emulating_touch_from_mouse);
    static constexpr int64_t MOUSE_MODE_VISIBLE = 0;
    static constexpr int64_t MOUSE_MODE_HIDDEN = 1;
    static constexpr int64_t MOUSE_MODE_CAPTURED = 2;
    static constexpr int64_t MOUSE_MODE_CONFINED = 3;
    static constexpr int64_t MOUSE_MODE_CONFINED_HIDDEN = 4;
    static constexpr int64_t CURSOR_ARROW = 0;
    static constexpr int64_t CURSOR_IBEAM = 1;
    static constexpr int64_t CURSOR_POINTING_HAND = 2;
    static constexpr int64_t CURSOR_CROSS = 3;
    static constexpr int64_t CURSOR_WAIT = 4;
    static constexpr int64_t CURSOR_BUSY = 5;
    static constexpr int64_t CURSOR_DRAG = 6;
    static constexpr int64_t CURSOR_CAN_DROP = 7;
    static constexpr int64_t CURSOR_FORBIDDEN = 8;
    static constexpr int64_t CURSOR_VSIZE = 9;
    static constexpr int64_t CURSOR_HSIZE = 10;
    static constexpr int64_t CURSOR_BDIAGSIZE = 11;
    static constexpr int64_t CURSOR_FDIAGSIZE = 12;
    static constexpr int64_t CURSOR_MOVE = 13;
    static constexpr int64_t CURSOR_VSPLIT = 14;
    static constexpr int64_t CURSOR_HSPLIT = 15;
    static constexpr int64_t CURSOR_HELP = 16;
    static Input get_singleton() { return Input(Object("Input").address()); }
};
struct InputMap : public Object {
    using Object::Object;
    METHOD(bool, has_action);
    METHOD(Array, get_actions);
    METHOD(Variant, add_action);
    METHOD(Variant, erase_action);
    METHOD(Variant, action_set_deadzone);
    METHOD(double, action_get_deadzone);
    METHOD(Variant, action_add_event);
    METHOD(bool, action_has_event);
    METHOD(Variant, action_erase_event);
    METHOD(Variant, action_erase_events);
    METHOD(Array, action_get_events);
    METHOD(bool, event_is_action);
    METHOD(Variant, load_from_project_settings);
    static InputMap get_singleton() { return InputMap(Object("InputMap").address()); }
};
struct InstancePlaceholder : public Node {
    using Node::Node;
    METHOD(Dictionary, get_stored_values);
    METHOD(Object, create_instance);
    METHOD(String, get_instance_path);
};
struct ItemList : public Control {
    using Control::Control;
    PROPERTY(select_mode, int64_t);
    PROPERTY(allow_reselect, bool);
    PROPERTY(allow_rmb_select, bool);
    PROPERTY(allow_search, bool);
    PROPERTY(max_text_lines, int64_t);
    PROPERTY(auto_height, bool);
    PROPERTY(text_overrun_behavior, int64_t);
    PROPERTY(item_count, int64_t);
    PROPERTY(max_columns, int64_t);
    PROPERTY(same_column_width, bool);
    PROPERTY(fixed_column_width, int64_t);
    PROPERTY(icon_mode, int64_t);
    PROPERTY(icon_scale, double);
    PROPERTY(fixed_icon_size, Vector2i);
    METHOD(int64_t, add_item);
    METHOD(int64_t, add_icon_item);
    METHOD(void, set_item_text);
    METHOD(String, get_item_text);
    METHOD(void, set_item_icon);
    METHOD(Object, get_item_icon);
    METHOD(void, set_item_text_direction);
    METHOD(int64_t, get_item_text_direction);
    METHOD(void, set_item_language);
    METHOD(String, get_item_language);
    METHOD(void, set_item_icon_transposed);
    METHOD(bool, is_item_icon_transposed);
    METHOD(void, set_item_icon_region);
    METHOD(Rect2, get_item_icon_region);
    METHOD(void, set_item_icon_modulate);
    METHOD(Color, get_item_icon_modulate);
    METHOD(void, set_item_selectable);
    METHOD(bool, is_item_selectable);
    METHOD(void, set_item_disabled);
    METHOD(bool, is_item_disabled);
    METHOD(void, set_item_metadata);
    METHOD(Variant, get_item_metadata);
    METHOD(void, set_item_custom_bg_color);
    METHOD(Color, get_item_custom_bg_color);
    METHOD(void, set_item_custom_fg_color);
    METHOD(Color, get_item_custom_fg_color);
    METHOD(Rect2, get_item_rect);
    METHOD(void, set_item_tooltip_enabled);
    METHOD(bool, is_item_tooltip_enabled);
    METHOD(void, set_item_tooltip);
    METHOD(String, get_item_tooltip);
    METHOD(Variant, select);
    METHOD(Variant, deselect);
    METHOD(Variant, deselect_all);
    METHOD(bool, is_selected);
    METHOD(PackedArray<int32_t>, get_selected_items);
    METHOD(Variant, move_item);
    METHOD(void, set_item_count);
    METHOD(int64_t, get_item_count);
    METHOD(Variant, remove_item);
    METHOD(Variant, clear);
    METHOD(Variant, sort_items_by_text);
    METHOD(void, set_fixed_column_width);
    METHOD(int64_t, get_fixed_column_width);
    METHOD(void, set_same_column_width);
    METHOD(bool, is_same_column_width);
    METHOD(void, set_max_text_lines);
    METHOD(int64_t, get_max_text_lines);
    METHOD(void, set_max_columns);
    METHOD(int64_t, get_max_columns);
    METHOD(void, set_select_mode);
    METHOD(int64_t, get_select_mode);
    METHOD(void, set_icon_mode);
    METHOD(int64_t, get_icon_mode);
    METHOD(void, set_fixed_icon_size);
    METHOD(Vector2i, get_fixed_icon_size);
    METHOD(void, set_icon_scale);
    METHOD(double, get_icon_scale);
    METHOD(void, set_allow_rmb_select);
    METHOD(bool, get_allow_rmb_select);
    METHOD(void, set_allow_reselect);
    METHOD(bool, get_allow_reselect);
    METHOD(void, set_allow_search);
    METHOD(bool, get_allow_search);
    METHOD(void, set_auto_height);
    METHOD(bool, has_auto_height);
    METHOD(bool, is_anything_selected);
    METHOD(int64_t, get_item_at_position);
    METHOD(Variant, ensure_current_is_visible);
    METHOD(Object, get_v_scroll_bar);
    METHOD(void, set_text_overrun_behavior);
    METHOD(int64_t, get_text_overrun_behavior);
    METHOD(Variant, force_update_list_size);
    static constexpr int64_t ICON_MODE_TOP = 0;
    static constexpr int64_t ICON_MODE_LEFT = 1;
    static constexpr int64_t SELECT_SINGLE = 0;
    static constexpr int64_t SELECT_MULTI = 1;
};
struct JNISingleton : public Object {
    using Object::Object;
};
struct JSONRPC : public Object {
    using Object::Object;
    METHOD(void, set_scope);
    METHOD(Variant, process_action);
    METHOD(String, process_string);
    METHOD(Dictionary, make_request);
    METHOD(Dictionary, make_response);
    METHOD(Dictionary, make_notification);
    METHOD(Dictionary, make_response_error);
    static constexpr int64_t PARSE_ERROR = -32700;
    static constexpr int64_t INVALID_REQUEST = -32600;
    static constexpr int64_t METHOD_NOT_FOUND = -32601;
    static constexpr int64_t INVALID_PARAMS = -32602;
    static constexpr int64_t INTERNAL_ERROR = -32603;
};
struct JavaClassWrapper : public Object {
    using Object::Object;
    METHOD(Object, wrap);
    static JavaClassWrapper get_singleton() { return JavaClassWrapper(Object("JavaClassWrapper").address()); }
};
struct JavaScriptBridge : public Object {
    using Object::Object;
    METHOD(Variant, eval);
    METHOD(Object, get_interface);
    METHOD(Object, create_callback);
    METHOD(Variant, create_object);
    METHOD(Variant, download_buffer);
    METHOD(bool, pwa_needs_update);
    METHOD(int64_t, pwa_update);
    METHOD(Variant, force_fs_sync);
    static JavaScriptBridge get_singleton() { return JavaScriptBridge(Object("JavaScriptBridge").address()); }
};
struct Joint2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(node_a, String);
    PROPERTY(node_b, String);
    PROPERTY(bias, double);
    PROPERTY(disable_collision, bool);
    METHOD(void, set_node_a);
    METHOD(String, get_node_a);
    METHOD(void, set_node_b);
    METHOD(String, get_node_b);
    METHOD(void, set_bias);
    METHOD(double, get_bias);
    METHOD(void, set_exclude_nodes_from_collision);
    METHOD(bool, get_exclude_nodes_from_collision);
    METHOD(::RID, get_rid);
};
struct Joint3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(node_a, String);
    PROPERTY(node_b, String);
    PROPERTY(solver_priority, int64_t);
    PROPERTY(exclude_nodes_from_collision, bool);
    METHOD(void, set_node_a);
    METHOD(String, get_node_a);
    METHOD(void, set_node_b);
    METHOD(String, get_node_b);
    METHOD(void, set_solver_priority);
    METHOD(int64_t, get_solver_priority);
    METHOD(void, set_exclude_nodes_from_collision);
    METHOD(bool, get_exclude_nodes_from_collision);
    METHOD(::RID, get_rid);
};
struct Label : public Control {
    using Control::Control;
    PROPERTY(text, String);
    PROPERTY(label_settings, Object);
    PROPERTY(horizontal_alignment, int64_t);
    PROPERTY(vertical_alignment, int64_t);
    PROPERTY(autowrap_mode, int64_t);
    PROPERTY(justification_flags, int64_t);
    PROPERTY(clip_text, bool);
    PROPERTY(text_overrun_behavior, int64_t);
    PROPERTY(ellipsis_char, String);
    PROPERTY(uppercase, bool);
    PROPERTY(tab_stops, PackedArray<float>);
    PROPERTY(lines_skipped, int64_t);
    PROPERTY(max_lines_visible, int64_t);
    PROPERTY(visible_characters, int64_t);
    PROPERTY(visible_characters_behavior, int64_t);
    PROPERTY(visible_ratio, double);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    PROPERTY(structured_text_bidi_override, int64_t);
    PROPERTY(structured_text_bidi_override_options, Array);
    METHOD(void, set_horizontal_alignment);
    METHOD(int64_t, get_horizontal_alignment);
    METHOD(void, set_vertical_alignment);
    METHOD(int64_t, get_vertical_alignment);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(void, set_label_settings);
    METHOD(Object, get_label_settings);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_autowrap_mode);
    METHOD(int64_t, get_autowrap_mode);
    METHOD(void, set_justification_flags);
    METHOD(int64_t, get_justification_flags);
    METHOD(void, set_clip_text);
    METHOD(bool, is_clipping_text);
    METHOD(void, set_tab_stops);
    METHOD(PackedArray<float>, get_tab_stops);
    METHOD(void, set_text_overrun_behavior);
    METHOD(int64_t, get_text_overrun_behavior);
    METHOD(void, set_ellipsis_char);
    METHOD(String, get_ellipsis_char);
    METHOD(void, set_uppercase);
    METHOD(bool, is_uppercase);
    METHOD(int64_t, get_line_height);
    METHOD(int64_t, get_line_count);
    METHOD(int64_t, get_visible_line_count);
    METHOD(int64_t, get_total_character_count);
    METHOD(void, set_visible_characters);
    METHOD(int64_t, get_visible_characters);
    METHOD(int64_t, get_visible_characters_behavior);
    METHOD(void, set_visible_characters_behavior);
    METHOD(void, set_visible_ratio);
    METHOD(double, get_visible_ratio);
    METHOD(void, set_lines_skipped);
    METHOD(int64_t, get_lines_skipped);
    METHOD(void, set_max_lines_visible);
    METHOD(int64_t, get_max_lines_visible);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    METHOD(Rect2, get_character_bounds);
};
struct Light2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(enabled, bool);
    PROPERTY(editor_only, bool);
    PROPERTY(color, Color);
    PROPERTY(energy, double);
    PROPERTY(blend_mode, int64_t);
    PROPERTY(range_z_min, int64_t);
    PROPERTY(range_z_max, int64_t);
    PROPERTY(range_layer_min, int64_t);
    PROPERTY(range_layer_max, int64_t);
    PROPERTY(range_item_cull_mask, int64_t);
    PROPERTY(shadow_enabled, bool);
    PROPERTY(shadow_color, Color);
    PROPERTY(shadow_filter, int64_t);
    PROPERTY(shadow_filter_smooth, double);
    PROPERTY(shadow_item_cull_mask, int64_t);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_editor_only);
    METHOD(bool, is_editor_only);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_energy);
    METHOD(double, get_energy);
    METHOD(void, set_z_range_min);
    METHOD(int64_t, get_z_range_min);
    METHOD(void, set_z_range_max);
    METHOD(int64_t, get_z_range_max);
    METHOD(void, set_layer_range_min);
    METHOD(int64_t, get_layer_range_min);
    METHOD(void, set_layer_range_max);
    METHOD(int64_t, get_layer_range_max);
    METHOD(void, set_item_cull_mask);
    METHOD(int64_t, get_item_cull_mask);
    METHOD(void, set_item_shadow_cull_mask);
    METHOD(int64_t, get_item_shadow_cull_mask);
    METHOD(void, set_shadow_enabled);
    METHOD(bool, is_shadow_enabled);
    METHOD(void, set_shadow_smooth);
    METHOD(double, get_shadow_smooth);
    METHOD(void, set_shadow_filter);
    METHOD(int64_t, get_shadow_filter);
    METHOD(void, set_shadow_color);
    METHOD(Color, get_shadow_color);
    METHOD(void, set_blend_mode);
    METHOD(int64_t, get_blend_mode);
    METHOD(void, set_height);
    METHOD(double, get_height);
    static constexpr int64_t SHADOW_FILTER_NONE = 0;
    static constexpr int64_t SHADOW_FILTER_PCF5 = 1;
    static constexpr int64_t SHADOW_FILTER_PCF13 = 2;
    static constexpr int64_t BLEND_MODE_ADD = 0;
    static constexpr int64_t BLEND_MODE_SUB = 1;
    static constexpr int64_t BLEND_MODE_MIX = 2;
};
struct LightOccluder2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(occluder, Object);
    PROPERTY(sdf_collision, bool);
    PROPERTY(occluder_light_mask, int64_t);
    METHOD(void, set_occluder_polygon);
    METHOD(Object, get_occluder_polygon);
    METHOD(void, set_occluder_light_mask);
    METHOD(int64_t, get_occluder_light_mask);
    METHOD(void, set_as_sdf_collision);
    METHOD(bool, is_set_as_sdf_collision);
};
struct LightmapProbe : public Node3D {
    using Node3D::Node3D;
};
struct Line2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(points, PackedArray<Vector2>);
    PROPERTY(closed, bool);
    PROPERTY(width, double);
    PROPERTY(width_curve, Object);
    PROPERTY(default_color, Color);
    PROPERTY(gradient, Object);
    PROPERTY(texture, Object);
    PROPERTY(texture_mode, int64_t);
    PROPERTY(joint_mode, int64_t);
    PROPERTY(begin_cap_mode, int64_t);
    PROPERTY(end_cap_mode, int64_t);
    PROPERTY(sharp_limit, double);
    PROPERTY(round_precision, int64_t);
    PROPERTY(antialiased, bool);
    METHOD(void, set_points);
    METHOD(PackedArray<Vector2>, get_points);
    METHOD(void, set_point_position);
    METHOD(Vector2, get_point_position);
    METHOD(int64_t, get_point_count);
    METHOD(Variant, add_point);
    METHOD(Variant, remove_point);
    METHOD(Variant, clear_points);
    METHOD(void, set_closed);
    METHOD(bool, is_closed);
    METHOD(void, set_width);
    METHOD(double, get_width);
    METHOD(void, set_curve);
    METHOD(Object, get_curve);
    METHOD(void, set_default_color);
    METHOD(Color, get_default_color);
    METHOD(void, set_gradient);
    METHOD(Object, get_gradient);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_texture_mode);
    METHOD(int64_t, get_texture_mode);
    METHOD(void, set_joint_mode);
    METHOD(int64_t, get_joint_mode);
    METHOD(void, set_begin_cap_mode);
    METHOD(int64_t, get_begin_cap_mode);
    METHOD(void, set_end_cap_mode);
    METHOD(int64_t, get_end_cap_mode);
    METHOD(void, set_sharp_limit);
    METHOD(double, get_sharp_limit);
    METHOD(void, set_round_precision);
    METHOD(int64_t, get_round_precision);
    METHOD(void, set_antialiased);
    METHOD(bool, get_antialiased);
    static constexpr int64_t LINE_JOINT_SHARP = 0;
    static constexpr int64_t LINE_JOINT_BEVEL = 1;
    static constexpr int64_t LINE_JOINT_ROUND = 2;
    static constexpr int64_t LINE_CAP_NONE = 0;
    static constexpr int64_t LINE_CAP_BOX = 1;
    static constexpr int64_t LINE_CAP_ROUND = 2;
    static constexpr int64_t LINE_TEXTURE_NONE = 0;
    static constexpr int64_t LINE_TEXTURE_TILE = 1;
    static constexpr int64_t LINE_TEXTURE_STRETCH = 2;
};
struct LineEdit : public Control {
    using Control::Control;
    PROPERTY(text, String);
    PROPERTY(placeholder_text, String);
    PROPERTY(alignment, int64_t);
    PROPERTY(max_length, int64_t);
    PROPERTY(editable, bool);
    PROPERTY(expand_to_text_length, bool);
    PROPERTY(context_menu_enabled, bool);
    PROPERTY(virtual_keyboard_enabled, bool);
    PROPERTY(virtual_keyboard_type, int64_t);
    PROPERTY(clear_button_enabled, bool);
    PROPERTY(shortcut_keys_enabled, bool);
    PROPERTY(middle_mouse_paste_enabled, bool);
    PROPERTY(selecting_enabled, bool);
    PROPERTY(deselect_on_focus_loss_enabled, bool);
    PROPERTY(drag_and_drop_selection_enabled, bool);
    PROPERTY(right_icon, Object);
    PROPERTY(flat, bool);
    PROPERTY(draw_control_chars, bool);
    PROPERTY(select_all_on_focus, bool);
    PROPERTY(caret_blink, bool);
    PROPERTY(caret_blink_interval, double);
    PROPERTY(caret_column, int64_t);
    PROPERTY(caret_force_displayed, bool);
    PROPERTY(caret_mid_grapheme, bool);
    PROPERTY(secret, bool);
    PROPERTY(secret_character, String);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    PROPERTY(structured_text_bidi_override, int64_t);
    PROPERTY(structured_text_bidi_override_options, Array);
    METHOD(void, set_horizontal_alignment);
    METHOD(int64_t, get_horizontal_alignment);
    METHOD(Variant, clear);
    METHOD(Variant, select);
    METHOD(Variant, select_all);
    METHOD(Variant, deselect);
    METHOD(bool, has_selection);
    METHOD(String, get_selected_text);
    METHOD(int64_t, get_selection_from_column);
    METHOD(int64_t, get_selection_to_column);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(bool, get_draw_control_chars);
    METHOD(void, set_draw_control_chars);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    METHOD(void, set_placeholder);
    METHOD(String, get_placeholder);
    METHOD(void, set_caret_column);
    METHOD(int64_t, get_caret_column);
    METHOD(double, get_scroll_offset);
    METHOD(void, set_expand_to_text_length_enabled);
    METHOD(bool, is_expand_to_text_length_enabled);
    METHOD(void, set_caret_blink_enabled);
    METHOD(bool, is_caret_blink_enabled);
    METHOD(void, set_caret_mid_grapheme_enabled);
    METHOD(bool, is_caret_mid_grapheme_enabled);
    METHOD(void, set_caret_force_displayed);
    METHOD(bool, is_caret_force_displayed);
    METHOD(void, set_caret_blink_interval);
    METHOD(double, get_caret_blink_interval);
    METHOD(void, set_max_length);
    METHOD(int64_t, get_max_length);
    METHOD(Variant, insert_text_at_caret);
    METHOD(Variant, delete_char_at_caret);
    METHOD(Variant, delete_text);
    METHOD(void, set_editable);
    METHOD(bool, is_editable);
    METHOD(void, set_secret);
    METHOD(bool, is_secret);
    METHOD(void, set_secret_character);
    METHOD(String, get_secret_character);
    METHOD(Variant, menu_option);
    METHOD(Object, get_menu);
    METHOD(bool, is_menu_visible);
    METHOD(void, set_context_menu_enabled);
    METHOD(bool, is_context_menu_enabled);
    METHOD(void, set_virtual_keyboard_enabled);
    METHOD(bool, is_virtual_keyboard_enabled);
    METHOD(void, set_virtual_keyboard_type);
    METHOD(int64_t, get_virtual_keyboard_type);
    METHOD(void, set_clear_button_enabled);
    METHOD(bool, is_clear_button_enabled);
    METHOD(void, set_shortcut_keys_enabled);
    METHOD(bool, is_shortcut_keys_enabled);
    METHOD(void, set_middle_mouse_paste_enabled);
    METHOD(bool, is_middle_mouse_paste_enabled);
    METHOD(void, set_selecting_enabled);
    METHOD(bool, is_selecting_enabled);
    METHOD(void, set_deselect_on_focus_loss_enabled);
    METHOD(bool, is_deselect_on_focus_loss_enabled);
    METHOD(void, set_drag_and_drop_selection_enabled);
    METHOD(bool, is_drag_and_drop_selection_enabled);
    METHOD(void, set_right_icon);
    METHOD(Object, get_right_icon);
    METHOD(void, set_flat);
    METHOD(bool, is_flat);
    METHOD(void, set_select_all_on_focus);
    METHOD(bool, is_select_all_on_focus);
    static constexpr int64_t MENU_CUT = 0;
    static constexpr int64_t MENU_COPY = 1;
    static constexpr int64_t MENU_PASTE = 2;
    static constexpr int64_t MENU_CLEAR = 3;
    static constexpr int64_t MENU_SELECT_ALL = 4;
    static constexpr int64_t MENU_UNDO = 5;
    static constexpr int64_t MENU_REDO = 6;
    static constexpr int64_t MENU_SUBMENU_TEXT_DIR = 7;
    static constexpr int64_t MENU_DIR_INHERITED = 8;
    static constexpr int64_t MENU_DIR_AUTO = 9;
    static constexpr int64_t MENU_DIR_LTR = 10;
    static constexpr int64_t MENU_DIR_RTL = 11;
    static constexpr int64_t MENU_DISPLAY_UCC = 12;
    static constexpr int64_t MENU_SUBMENU_INSERT_UCC = 13;
    static constexpr int64_t MENU_INSERT_LRM = 14;
    static constexpr int64_t MENU_INSERT_RLM = 15;
    static constexpr int64_t MENU_INSERT_LRE = 16;
    static constexpr int64_t MENU_INSERT_RLE = 17;
    static constexpr int64_t MENU_INSERT_LRO = 18;
    static constexpr int64_t MENU_INSERT_RLO = 19;
    static constexpr int64_t MENU_INSERT_PDF = 20;
    static constexpr int64_t MENU_INSERT_ALM = 21;
    static constexpr int64_t MENU_INSERT_LRI = 22;
    static constexpr int64_t MENU_INSERT_RLI = 23;
    static constexpr int64_t MENU_INSERT_FSI = 24;
    static constexpr int64_t MENU_INSERT_PDI = 25;
    static constexpr int64_t MENU_INSERT_ZWJ = 26;
    static constexpr int64_t MENU_INSERT_ZWNJ = 27;
    static constexpr int64_t MENU_INSERT_WJ = 28;
    static constexpr int64_t MENU_INSERT_SHY = 29;
    static constexpr int64_t MENU_MAX = 30;
    static constexpr int64_t KEYBOARD_TYPE_DEFAULT = 0;
    static constexpr int64_t KEYBOARD_TYPE_MULTILINE = 1;
    static constexpr int64_t KEYBOARD_TYPE_NUMBER = 2;
    static constexpr int64_t KEYBOARD_TYPE_NUMBER_DECIMAL = 3;
    static constexpr int64_t KEYBOARD_TYPE_PHONE = 4;
    static constexpr int64_t KEYBOARD_TYPE_EMAIL_ADDRESS = 5;
    static constexpr int64_t KEYBOARD_TYPE_PASSWORD = 6;
    static constexpr int64_t KEYBOARD_TYPE_URL = 7;
};
struct MainLoop : public Object {
    using Object::Object;
    METHOD(Variant, _initialize);
    METHOD(bool, _physics_process);
    METHOD(bool, _process);
    METHOD(Variant, _finalize);
    static constexpr int64_t NOTIFICATION_OS_MEMORY_WARNING = 2009;
    static constexpr int64_t NOTIFICATION_TRANSLATION_CHANGED = 2010;
    static constexpr int64_t NOTIFICATION_WM_ABOUT = 2011;
    static constexpr int64_t NOTIFICATION_CRASH = 2012;
    static constexpr int64_t NOTIFICATION_OS_IME_UPDATE = 2013;
    static constexpr int64_t NOTIFICATION_APPLICATION_RESUMED = 2014;
    static constexpr int64_t NOTIFICATION_APPLICATION_PAUSED = 2015;
    static constexpr int64_t NOTIFICATION_APPLICATION_FOCUS_IN = 2016;
    static constexpr int64_t NOTIFICATION_APPLICATION_FOCUS_OUT = 2017;
    static constexpr int64_t NOTIFICATION_TEXT_SERVER_CHANGED = 2018;
};
struct Marker2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(gizmo_extents, double);
    METHOD(void, set_gizmo_extents);
    METHOD(double, get_gizmo_extents);
};
struct Marker3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(gizmo_extents, double);
    METHOD(void, set_gizmo_extents);
    METHOD(double, get_gizmo_extents);
};
struct Marshalls : public Object {
    using Object::Object;
    METHOD(String, variant_to_base64);
    METHOD(Variant, base64_to_variant);
    METHOD(String, raw_to_base64);
    METHOD(PackedArray<uint8_t>, base64_to_raw);
    METHOD(String, utf8_to_base64);
    METHOD(String, base64_to_utf8);
    static Marshalls get_singleton() { return Marshalls(Object("Marshalls").address()); }
};
struct MenuBar : public Control {
    using Control::Control;
    PROPERTY(flat, bool);
    PROPERTY(start_index, int64_t);
    PROPERTY(switch_on_hover, bool);
    PROPERTY(prefer_global_menu, bool);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    METHOD(void, set_switch_on_hover);
    METHOD(bool, is_switch_on_hover);
    METHOD(void, set_disable_shortcuts);
    METHOD(void, set_prefer_global_menu);
    METHOD(bool, is_prefer_global_menu);
    METHOD(bool, is_native_menu);
    METHOD(int64_t, get_menu_count);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_flat);
    METHOD(bool, is_flat);
    METHOD(void, set_start_index);
    METHOD(int64_t, get_start_index);
    METHOD(void, set_menu_title);
    METHOD(String, get_menu_title);
    METHOD(void, set_menu_tooltip);
    METHOD(String, get_menu_tooltip);
    METHOD(void, set_menu_disabled);
    METHOD(bool, is_menu_disabled);
    METHOD(void, set_menu_hidden);
    METHOD(bool, is_menu_hidden);
    METHOD(Object, get_menu_popup);
};
struct MeshInstance2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(mesh, Object);
    PROPERTY(texture, Object);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
};
struct MissingNode : public Node {
    using Node::Node;
    PROPERTY(original_class, String);
    PROPERTY(original_scene, String);
    PROPERTY(recording_properties, bool);
    METHOD(void, set_original_class);
    METHOD(String, get_original_class);
    METHOD(void, set_original_scene);
    METHOD(String, get_original_scene);
    METHOD(void, set_recording_properties);
    METHOD(bool, is_recording_properties);
};
struct MovieWriter : public Object {
    using Object::Object;
    METHOD(int64_t, _get_audio_mix_rate);
    METHOD(int64_t, _get_audio_speaker_mode);
    METHOD(bool, _handles_file);
    METHOD(int64_t, _write_begin);
    METHOD(int64_t, _write_frame);
    METHOD(Variant, _write_end);
    METHOD(Variant, add_writer);
};
struct MovieWriterMJPEG : public MovieWriter {
    using MovieWriter::MovieWriter;
};
struct MovieWriterPNGWAV : public MovieWriter {
    using MovieWriter::MovieWriter;
};
struct MultiMeshInstance2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(multimesh, Object);
    PROPERTY(texture, Object);
    METHOD(void, set_multimesh);
    METHOD(Object, get_multimesh);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
};
struct NativeMenu : public Object {
    using Object::Object;
    METHOD(bool, has_feature);
    METHOD(bool, has_system_menu);
    METHOD(::RID, get_system_menu);
    METHOD(String, get_system_menu_name);
    METHOD(::RID, create_menu);
    METHOD(bool, has_menu);
    METHOD(Variant, free_menu);
    METHOD(Vector2, get_size);
    METHOD(Variant, popup);
    METHOD(void, set_interface_direction);
    METHOD(void, set_popup_open_callback);
    METHOD(Callable, get_popup_open_callback);
    METHOD(void, set_popup_close_callback);
    METHOD(Callable, get_popup_close_callback);
    METHOD(void, set_minimum_width);
    METHOD(double, get_minimum_width);
    METHOD(bool, is_opened);
    METHOD(int64_t, add_submenu_item);
    METHOD(int64_t, add_item);
    METHOD(int64_t, add_check_item);
    METHOD(int64_t, add_icon_item);
    METHOD(int64_t, add_icon_check_item);
    METHOD(int64_t, add_radio_check_item);
    METHOD(int64_t, add_icon_radio_check_item);
    METHOD(int64_t, add_multistate_item);
    METHOD(int64_t, add_separator);
    METHOD(int64_t, find_item_index_with_text);
    METHOD(int64_t, find_item_index_with_tag);
    METHOD(int64_t, find_item_index_with_submenu);
    METHOD(bool, is_item_checked);
    METHOD(bool, is_item_checkable);
    METHOD(bool, is_item_radio_checkable);
    METHOD(Callable, get_item_callback);
    METHOD(Callable, get_item_key_callback);
    METHOD(Variant, get_item_tag);
    METHOD(String, get_item_text);
    METHOD(::RID, get_item_submenu);
    METHOD(int64_t, get_item_accelerator);
    METHOD(bool, is_item_disabled);
    METHOD(bool, is_item_hidden);
    METHOD(String, get_item_tooltip);
    METHOD(int64_t, get_item_state);
    METHOD(int64_t, get_item_max_states);
    METHOD(Object, get_item_icon);
    METHOD(int64_t, get_item_indentation_level);
    METHOD(void, set_item_checked);
    METHOD(void, set_item_checkable);
    METHOD(void, set_item_radio_checkable);
    METHOD(void, set_item_callback);
    METHOD(void, set_item_hover_callbacks);
    METHOD(void, set_item_key_callback);
    METHOD(void, set_item_tag);
    METHOD(void, set_item_text);
    METHOD(void, set_item_submenu);
    METHOD(void, set_item_accelerator);
    METHOD(void, set_item_disabled);
    METHOD(void, set_item_hidden);
    METHOD(void, set_item_tooltip);
    METHOD(void, set_item_state);
    METHOD(void, set_item_max_states);
    METHOD(void, set_item_icon);
    METHOD(void, set_item_indentation_level);
    METHOD(int64_t, get_item_count);
    METHOD(bool, is_system_menu);
    METHOD(Variant, remove_item);
    METHOD(Variant, clear);
    static constexpr int64_t FEATURE_GLOBAL_MENU = 0;
    static constexpr int64_t FEATURE_POPUP_MENU = 1;
    static constexpr int64_t FEATURE_OPEN_CLOSE_CALLBACK = 2;
    static constexpr int64_t FEATURE_HOVER_CALLBACK = 3;
    static constexpr int64_t FEATURE_KEY_CALLBACK = 4;
    static constexpr int64_t INVALID_MENU_ID = 0;
    static constexpr int64_t MAIN_MENU_ID = 1;
    static constexpr int64_t APPLICATION_MENU_ID = 2;
    static constexpr int64_t WINDOW_MENU_ID = 3;
    static constexpr int64_t HELP_MENU_ID = 4;
    static constexpr int64_t DOCK_MENU_ID = 5;
    static NativeMenu get_singleton() { return NativeMenu(Object("NativeMenu").address()); }
};
struct NativeMenuWindows : public NativeMenu {
    using NativeMenu::NativeMenu;
};
struct NavigationAgent2D : public Node {
    using Node::Node;
    PROPERTY(target_position, Vector2);
    PROPERTY(path_desired_distance, double);
    PROPERTY(target_desired_distance, double);
    PROPERTY(path_max_distance, double);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(pathfinding_algorithm, int64_t);
    PROPERTY(path_postprocessing, int64_t);
    PROPERTY(path_metadata_flags, int64_t);
    PROPERTY(simplify_path, bool);
    PROPERTY(simplify_epsilon, double);
    PROPERTY(avoidance_enabled, bool);
    PROPERTY(velocity, Vector2);
    PROPERTY(radius, double);
    PROPERTY(neighbor_distance, double);
    PROPERTY(max_neighbors, int64_t);
    PROPERTY(time_horizon_agents, double);
    PROPERTY(time_horizon_obstacles, double);
    PROPERTY(max_speed, double);
    PROPERTY(avoidance_layers, int64_t);
    PROPERTY(avoidance_mask, int64_t);
    PROPERTY(avoidance_priority, double);
    PROPERTY(debug_enabled, bool);
    PROPERTY(debug_use_custom, bool);
    PROPERTY(debug_path_custom_color, Color);
    PROPERTY(debug_path_custom_point_size, double);
    PROPERTY(debug_path_custom_line_width, double);
    METHOD(::RID, get_rid);
    METHOD(void, set_avoidance_enabled);
    METHOD(bool, get_avoidance_enabled);
    METHOD(void, set_path_desired_distance);
    METHOD(double, get_path_desired_distance);
    METHOD(void, set_target_desired_distance);
    METHOD(double, get_target_desired_distance);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_neighbor_distance);
    METHOD(double, get_neighbor_distance);
    METHOD(void, set_max_neighbors);
    METHOD(int64_t, get_max_neighbors);
    METHOD(void, set_time_horizon_agents);
    METHOD(double, get_time_horizon_agents);
    METHOD(void, set_time_horizon_obstacles);
    METHOD(double, get_time_horizon_obstacles);
    METHOD(void, set_max_speed);
    METHOD(double, get_max_speed);
    METHOD(void, set_path_max_distance);
    METHOD(double, get_path_max_distance);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_navigation_layer_value);
    METHOD(bool, get_navigation_layer_value);
    METHOD(void, set_pathfinding_algorithm);
    METHOD(int64_t, get_pathfinding_algorithm);
    METHOD(void, set_path_postprocessing);
    METHOD(int64_t, get_path_postprocessing);
    METHOD(void, set_path_metadata_flags);
    METHOD(int64_t, get_path_metadata_flags);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_target_position);
    METHOD(Vector2, get_target_position);
    METHOD(void, set_simplify_path);
    METHOD(bool, get_simplify_path);
    METHOD(void, set_simplify_epsilon);
    METHOD(double, get_simplify_epsilon);
    METHOD(Vector2, get_next_path_position);
    METHOD(void, set_velocity_forced);
    METHOD(void, set_velocity);
    METHOD(Vector2, get_velocity);
    METHOD(double, distance_to_target);
    METHOD(Object, get_current_navigation_result);
    METHOD(PackedArray<Vector2>, get_current_navigation_path);
    METHOD(int64_t, get_current_navigation_path_index);
    METHOD(bool, is_target_reached);
    METHOD(bool, is_target_reachable);
    METHOD(bool, is_navigation_finished);
    METHOD(Vector2, get_final_position);
    METHOD(Variant, _avoidance_done);
    METHOD(void, set_avoidance_layers);
    METHOD(int64_t, get_avoidance_layers);
    METHOD(void, set_avoidance_mask);
    METHOD(int64_t, get_avoidance_mask);
    METHOD(void, set_avoidance_layer_value);
    METHOD(bool, get_avoidance_layer_value);
    METHOD(void, set_avoidance_mask_value);
    METHOD(bool, get_avoidance_mask_value);
    METHOD(void, set_avoidance_priority);
    METHOD(double, get_avoidance_priority);
    METHOD(void, set_debug_enabled);
    METHOD(bool, get_debug_enabled);
    METHOD(void, set_debug_use_custom);
    METHOD(bool, get_debug_use_custom);
    METHOD(void, set_debug_path_custom_color);
    METHOD(Color, get_debug_path_custom_color);
    METHOD(void, set_debug_path_custom_point_size);
    METHOD(double, get_debug_path_custom_point_size);
    METHOD(void, set_debug_path_custom_line_width);
    METHOD(double, get_debug_path_custom_line_width);
};
struct NavigationAgent3D : public Node {
    using Node::Node;
    PROPERTY(target_position, Vector3);
    PROPERTY(path_desired_distance, double);
    PROPERTY(target_desired_distance, double);
    PROPERTY(path_height_offset, double);
    PROPERTY(path_max_distance, double);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(pathfinding_algorithm, int64_t);
    PROPERTY(path_postprocessing, int64_t);
    PROPERTY(path_metadata_flags, int64_t);
    PROPERTY(simplify_path, bool);
    PROPERTY(simplify_epsilon, double);
    PROPERTY(avoidance_enabled, bool);
    PROPERTY(velocity, Vector3);
    PROPERTY(height, double);
    PROPERTY(radius, double);
    PROPERTY(neighbor_distance, double);
    PROPERTY(max_neighbors, int64_t);
    PROPERTY(time_horizon_agents, double);
    PROPERTY(time_horizon_obstacles, double);
    PROPERTY(max_speed, double);
    PROPERTY(use_3d_avoidance, bool);
    PROPERTY(keep_y_velocity, bool);
    PROPERTY(avoidance_layers, int64_t);
    PROPERTY(avoidance_mask, int64_t);
    PROPERTY(avoidance_priority, double);
    PROPERTY(debug_enabled, bool);
    PROPERTY(debug_use_custom, bool);
    PROPERTY(debug_path_custom_color, Color);
    PROPERTY(debug_path_custom_point_size, double);
    METHOD(::RID, get_rid);
    METHOD(void, set_avoidance_enabled);
    METHOD(bool, get_avoidance_enabled);
    METHOD(void, set_path_desired_distance);
    METHOD(double, get_path_desired_distance);
    METHOD(void, set_target_desired_distance);
    METHOD(double, get_target_desired_distance);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
    METHOD(void, set_path_height_offset);
    METHOD(double, get_path_height_offset);
    METHOD(void, set_use_3d_avoidance);
    METHOD(bool, get_use_3d_avoidance);
    METHOD(void, set_keep_y_velocity);
    METHOD(bool, get_keep_y_velocity);
    METHOD(void, set_neighbor_distance);
    METHOD(double, get_neighbor_distance);
    METHOD(void, set_max_neighbors);
    METHOD(int64_t, get_max_neighbors);
    METHOD(void, set_time_horizon_agents);
    METHOD(double, get_time_horizon_agents);
    METHOD(void, set_time_horizon_obstacles);
    METHOD(double, get_time_horizon_obstacles);
    METHOD(void, set_max_speed);
    METHOD(double, get_max_speed);
    METHOD(void, set_path_max_distance);
    METHOD(double, get_path_max_distance);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_navigation_layer_value);
    METHOD(bool, get_navigation_layer_value);
    METHOD(void, set_pathfinding_algorithm);
    METHOD(int64_t, get_pathfinding_algorithm);
    METHOD(void, set_path_postprocessing);
    METHOD(int64_t, get_path_postprocessing);
    METHOD(void, set_path_metadata_flags);
    METHOD(int64_t, get_path_metadata_flags);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_target_position);
    METHOD(Vector3, get_target_position);
    METHOD(void, set_simplify_path);
    METHOD(bool, get_simplify_path);
    METHOD(void, set_simplify_epsilon);
    METHOD(double, get_simplify_epsilon);
    METHOD(Vector3, get_next_path_position);
    METHOD(void, set_velocity_forced);
    METHOD(void, set_velocity);
    METHOD(Vector3, get_velocity);
    METHOD(double, distance_to_target);
    METHOD(Object, get_current_navigation_result);
    METHOD(PackedArray<Vector3>, get_current_navigation_path);
    METHOD(int64_t, get_current_navigation_path_index);
    METHOD(bool, is_target_reached);
    METHOD(bool, is_target_reachable);
    METHOD(bool, is_navigation_finished);
    METHOD(Vector3, get_final_position);
    METHOD(Variant, _avoidance_done);
    METHOD(void, set_avoidance_layers);
    METHOD(int64_t, get_avoidance_layers);
    METHOD(void, set_avoidance_mask);
    METHOD(int64_t, get_avoidance_mask);
    METHOD(void, set_avoidance_layer_value);
    METHOD(bool, get_avoidance_layer_value);
    METHOD(void, set_avoidance_mask_value);
    METHOD(bool, get_avoidance_mask_value);
    METHOD(void, set_avoidance_priority);
    METHOD(double, get_avoidance_priority);
    METHOD(void, set_debug_enabled);
    METHOD(bool, get_debug_enabled);
    METHOD(void, set_debug_use_custom);
    METHOD(bool, get_debug_use_custom);
    METHOD(void, set_debug_path_custom_color);
    METHOD(Color, get_debug_path_custom_color);
    METHOD(void, set_debug_path_custom_point_size);
    METHOD(double, get_debug_path_custom_point_size);
};
struct NavigationLink2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(enabled, bool);
    PROPERTY(bidirectional, bool);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(start_position, Vector2);
    PROPERTY(end_position, Vector2);
    PROPERTY(enter_cost, double);
    PROPERTY(travel_cost, double);
    METHOD(::RID, get_rid);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_bidirectional);
    METHOD(bool, is_bidirectional);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_navigation_layer_value);
    METHOD(bool, get_navigation_layer_value);
    METHOD(void, set_start_position);
    METHOD(Vector2, get_start_position);
    METHOD(void, set_end_position);
    METHOD(Vector2, get_end_position);
    METHOD(void, set_global_start_position);
    METHOD(Vector2, get_global_start_position);
    METHOD(void, set_global_end_position);
    METHOD(Vector2, get_global_end_position);
    METHOD(void, set_enter_cost);
    METHOD(double, get_enter_cost);
    METHOD(void, set_travel_cost);
    METHOD(double, get_travel_cost);
};
struct NavigationLink3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(enabled, bool);
    PROPERTY(bidirectional, bool);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(start_position, Vector3);
    PROPERTY(end_position, Vector3);
    PROPERTY(enter_cost, double);
    PROPERTY(travel_cost, double);
    METHOD(::RID, get_rid);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_bidirectional);
    METHOD(bool, is_bidirectional);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_navigation_layer_value);
    METHOD(bool, get_navigation_layer_value);
    METHOD(void, set_start_position);
    METHOD(Vector3, get_start_position);
    METHOD(void, set_end_position);
    METHOD(Vector3, get_end_position);
    METHOD(void, set_global_start_position);
    METHOD(Vector3, get_global_start_position);
    METHOD(void, set_global_end_position);
    METHOD(Vector3, get_global_end_position);
    METHOD(void, set_enter_cost);
    METHOD(double, get_enter_cost);
    METHOD(void, set_travel_cost);
    METHOD(double, get_travel_cost);
};
struct NavigationMeshGenerator : public Object {
    using Object::Object;
    METHOD(Variant, bake);
    METHOD(Variant, clear);
    METHOD(Variant, parse_source_geometry_data);
    METHOD(Variant, bake_from_source_geometry_data);
    static NavigationMeshGenerator get_singleton() { return NavigationMeshGenerator(Object("NavigationMeshGenerator").address()); }
};
struct NavigationObstacle2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(radius, double);
    PROPERTY(vertices, PackedArray<Vector2>);
    PROPERTY(affect_navigation_mesh, bool);
    PROPERTY(carve_navigation_mesh, bool);
    PROPERTY(avoidance_enabled, bool);
    PROPERTY(velocity, Vector2);
    PROPERTY(avoidance_layers, int64_t);
    METHOD(::RID, get_rid);
    METHOD(void, set_avoidance_enabled);
    METHOD(bool, get_avoidance_enabled);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_velocity);
    METHOD(Vector2, get_velocity);
    METHOD(void, set_vertices);
    METHOD(PackedArray<Vector2>, get_vertices);
    METHOD(void, set_avoidance_layers);
    METHOD(int64_t, get_avoidance_layers);
    METHOD(void, set_avoidance_layer_value);
    METHOD(bool, get_avoidance_layer_value);
    METHOD(void, set_affect_navigation_mesh);
    METHOD(bool, get_affect_navigation_mesh);
    METHOD(void, set_carve_navigation_mesh);
    METHOD(bool, get_carve_navigation_mesh);
};
struct NavigationObstacle3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(radius, double);
    PROPERTY(height, double);
    PROPERTY(vertices, PackedArray<Vector3>);
    PROPERTY(affect_navigation_mesh, bool);
    PROPERTY(carve_navigation_mesh, bool);
    PROPERTY(avoidance_enabled, bool);
    PROPERTY(velocity, Vector3);
    PROPERTY(avoidance_layers, int64_t);
    PROPERTY(use_3d_avoidance, bool);
    METHOD(::RID, get_rid);
    METHOD(void, set_avoidance_enabled);
    METHOD(bool, get_avoidance_enabled);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
    METHOD(void, set_velocity);
    METHOD(Vector3, get_velocity);
    METHOD(void, set_vertices);
    METHOD(PackedArray<Vector3>, get_vertices);
    METHOD(void, set_avoidance_layers);
    METHOD(int64_t, get_avoidance_layers);
    METHOD(void, set_avoidance_layer_value);
    METHOD(bool, get_avoidance_layer_value);
    METHOD(void, set_use_3d_avoidance);
    METHOD(bool, get_use_3d_avoidance);
    METHOD(void, set_affect_navigation_mesh);
    METHOD(bool, get_affect_navigation_mesh);
    METHOD(void, set_carve_navigation_mesh);
    METHOD(bool, get_carve_navigation_mesh);
};
struct NavigationRegion2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(navigation_polygon, Object);
    PROPERTY(enabled, bool);
    PROPERTY(use_edge_connections, bool);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(enter_cost, double);
    PROPERTY(travel_cost, double);
    METHOD(::RID, get_rid);
    METHOD(void, set_navigation_polygon);
    METHOD(Object, get_navigation_polygon);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_use_edge_connections);
    METHOD(bool, get_use_edge_connections);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_navigation_layer_value);
    METHOD(bool, get_navigation_layer_value);
    METHOD(::RID, get_region_rid);
    METHOD(void, set_enter_cost);
    METHOD(double, get_enter_cost);
    METHOD(void, set_travel_cost);
    METHOD(double, get_travel_cost);
    METHOD(Variant, bake_navigation_polygon);
    METHOD(bool, is_baking);
    METHOD(Variant, _navigation_polygon_changed);
};
struct NavigationRegion3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(navigation_mesh, Object);
    PROPERTY(enabled, bool);
    PROPERTY(use_edge_connections, bool);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(enter_cost, double);
    PROPERTY(travel_cost, double);
    METHOD(::RID, get_rid);
    METHOD(void, set_navigation_mesh);
    METHOD(Object, get_navigation_mesh);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_use_edge_connections);
    METHOD(bool, get_use_edge_connections);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_navigation_layer_value);
    METHOD(bool, get_navigation_layer_value);
    METHOD(::RID, get_region_rid);
    METHOD(void, set_enter_cost);
    METHOD(double, get_enter_cost);
    METHOD(void, set_travel_cost);
    METHOD(double, get_travel_cost);
    METHOD(Variant, bake_navigation_mesh);
    METHOD(bool, is_baking);
};
struct NavigationServer2D : public Object {
    using Object::Object;
    METHOD(Array, get_maps);
    METHOD(::RID, map_create);
    METHOD(Variant, map_set_active);
    METHOD(bool, map_is_active);
    METHOD(Variant, map_set_cell_size);
    METHOD(double, map_get_cell_size);
    METHOD(Variant, map_set_use_edge_connections);
    METHOD(bool, map_get_use_edge_connections);
    METHOD(Variant, map_set_edge_connection_margin);
    METHOD(double, map_get_edge_connection_margin);
    METHOD(Variant, map_set_link_connection_radius);
    METHOD(double, map_get_link_connection_radius);
    METHOD(PackedArray<Vector2>, map_get_path);
    METHOD(Vector2, map_get_closest_point);
    METHOD(::RID, map_get_closest_point_owner);
    METHOD(Array, map_get_links);
    METHOD(Array, map_get_regions);
    METHOD(Array, map_get_agents);
    METHOD(Array, map_get_obstacles);
    METHOD(Variant, map_force_update);
    METHOD(int64_t, map_get_iteration_id);
    METHOD(Vector2, map_get_random_point);
    METHOD(Variant, query_path);
    METHOD(::RID, region_create);
    METHOD(Variant, region_set_enabled);
    METHOD(bool, region_get_enabled);
    METHOD(Variant, region_set_use_edge_connections);
    METHOD(bool, region_get_use_edge_connections);
    METHOD(Variant, region_set_enter_cost);
    METHOD(double, region_get_enter_cost);
    METHOD(Variant, region_set_travel_cost);
    METHOD(double, region_get_travel_cost);
    METHOD(Variant, region_set_owner_id);
    METHOD(int64_t, region_get_owner_id);
    METHOD(bool, region_owns_point);
    METHOD(Variant, region_set_map);
    METHOD(::RID, region_get_map);
    METHOD(Variant, region_set_navigation_layers);
    METHOD(int64_t, region_get_navigation_layers);
    METHOD(Variant, region_set_transform);
    METHOD(Transform2D, region_get_transform);
    METHOD(Variant, region_set_navigation_polygon);
    METHOD(int64_t, region_get_connections_count);
    METHOD(Vector2, region_get_connection_pathway_start);
    METHOD(Vector2, region_get_connection_pathway_end);
    METHOD(Vector2, region_get_random_point);
    METHOD(::RID, link_create);
    METHOD(Variant, link_set_map);
    METHOD(::RID, link_get_map);
    METHOD(Variant, link_set_enabled);
    METHOD(bool, link_get_enabled);
    METHOD(Variant, link_set_bidirectional);
    METHOD(bool, link_is_bidirectional);
    METHOD(Variant, link_set_navigation_layers);
    METHOD(int64_t, link_get_navigation_layers);
    METHOD(Variant, link_set_start_position);
    METHOD(Vector2, link_get_start_position);
    METHOD(Variant, link_set_end_position);
    METHOD(Vector2, link_get_end_position);
    METHOD(Variant, link_set_enter_cost);
    METHOD(double, link_get_enter_cost);
    METHOD(Variant, link_set_travel_cost);
    METHOD(double, link_get_travel_cost);
    METHOD(Variant, link_set_owner_id);
    METHOD(int64_t, link_get_owner_id);
    METHOD(::RID, agent_create);
    METHOD(Variant, agent_set_avoidance_enabled);
    METHOD(bool, agent_get_avoidance_enabled);
    METHOD(Variant, agent_set_map);
    METHOD(::RID, agent_get_map);
    METHOD(Variant, agent_set_paused);
    METHOD(bool, agent_get_paused);
    METHOD(Variant, agent_set_neighbor_distance);
    METHOD(double, agent_get_neighbor_distance);
    METHOD(Variant, agent_set_max_neighbors);
    METHOD(int64_t, agent_get_max_neighbors);
    METHOD(Variant, agent_set_time_horizon_agents);
    METHOD(double, agent_get_time_horizon_agents);
    METHOD(Variant, agent_set_time_horizon_obstacles);
    METHOD(double, agent_get_time_horizon_obstacles);
    METHOD(Variant, agent_set_radius);
    METHOD(double, agent_get_radius);
    METHOD(Variant, agent_set_max_speed);
    METHOD(double, agent_get_max_speed);
    METHOD(Variant, agent_set_velocity_forced);
    METHOD(Variant, agent_set_velocity);
    METHOD(Vector2, agent_get_velocity);
    METHOD(Variant, agent_set_position);
    METHOD(Vector2, agent_get_position);
    METHOD(bool, agent_is_map_changed);
    METHOD(Variant, agent_set_avoidance_callback);
    METHOD(bool, agent_has_avoidance_callback);
    METHOD(Variant, agent_set_avoidance_layers);
    METHOD(int64_t, agent_get_avoidance_layers);
    METHOD(Variant, agent_set_avoidance_mask);
    METHOD(int64_t, agent_get_avoidance_mask);
    METHOD(Variant, agent_set_avoidance_priority);
    METHOD(double, agent_get_avoidance_priority);
    METHOD(::RID, obstacle_create);
    METHOD(Variant, obstacle_set_avoidance_enabled);
    METHOD(bool, obstacle_get_avoidance_enabled);
    METHOD(Variant, obstacle_set_map);
    METHOD(::RID, obstacle_get_map);
    METHOD(Variant, obstacle_set_paused);
    METHOD(bool, obstacle_get_paused);
    METHOD(Variant, obstacle_set_radius);
    METHOD(double, obstacle_get_radius);
    METHOD(Variant, obstacle_set_velocity);
    METHOD(Vector2, obstacle_get_velocity);
    METHOD(Variant, obstacle_set_position);
    METHOD(Vector2, obstacle_get_position);
    METHOD(Variant, obstacle_set_vertices);
    METHOD(PackedArray<Vector2>, obstacle_get_vertices);
    METHOD(Variant, obstacle_set_avoidance_layers);
    METHOD(int64_t, obstacle_get_avoidance_layers);
    METHOD(Variant, parse_source_geometry_data);
    METHOD(Variant, bake_from_source_geometry_data);
    METHOD(Variant, bake_from_source_geometry_data_async);
    METHOD(bool, is_baking_navigation_polygon);
    METHOD(::RID, source_geometry_parser_create);
    METHOD(Variant, source_geometry_parser_set_callback);
    METHOD(PackedArray<Vector2>, simplify_path);
    METHOD(Variant, free_rid);
    METHOD(void, set_debug_enabled);
    METHOD(bool, get_debug_enabled);
    static NavigationServer2D get_singleton() { return NavigationServer2D(Object("NavigationServer2D").address()); }
};
struct NavigationServer3D : public Object {
    using Object::Object;
    METHOD(Array, get_maps);
    METHOD(::RID, map_create);
    METHOD(Variant, map_set_active);
    METHOD(bool, map_is_active);
    METHOD(Variant, map_set_up);
    METHOD(Vector3, map_get_up);
    METHOD(Variant, map_set_cell_size);
    METHOD(double, map_get_cell_size);
    METHOD(Variant, map_set_cell_height);
    METHOD(double, map_get_cell_height);
    METHOD(Variant, map_set_merge_rasterizer_cell_scale);
    METHOD(double, map_get_merge_rasterizer_cell_scale);
    METHOD(Variant, map_set_use_edge_connections);
    METHOD(bool, map_get_use_edge_connections);
    METHOD(Variant, map_set_edge_connection_margin);
    METHOD(double, map_get_edge_connection_margin);
    METHOD(Variant, map_set_link_connection_radius);
    METHOD(double, map_get_link_connection_radius);
    METHOD(PackedArray<Vector3>, map_get_path);
    METHOD(Vector3, map_get_closest_point_to_segment);
    METHOD(Vector3, map_get_closest_point);
    METHOD(Vector3, map_get_closest_point_normal);
    METHOD(::RID, map_get_closest_point_owner);
    METHOD(Array, map_get_links);
    METHOD(Array, map_get_regions);
    METHOD(Array, map_get_agents);
    METHOD(Array, map_get_obstacles);
    METHOD(Variant, map_force_update);
    METHOD(int64_t, map_get_iteration_id);
    METHOD(Vector3, map_get_random_point);
    METHOD(Variant, query_path);
    METHOD(::RID, region_create);
    METHOD(Variant, region_set_enabled);
    METHOD(bool, region_get_enabled);
    METHOD(Variant, region_set_use_edge_connections);
    METHOD(bool, region_get_use_edge_connections);
    METHOD(Variant, region_set_enter_cost);
    METHOD(double, region_get_enter_cost);
    METHOD(Variant, region_set_travel_cost);
    METHOD(double, region_get_travel_cost);
    METHOD(Variant, region_set_owner_id);
    METHOD(int64_t, region_get_owner_id);
    METHOD(bool, region_owns_point);
    METHOD(Variant, region_set_map);
    METHOD(::RID, region_get_map);
    METHOD(Variant, region_set_navigation_layers);
    METHOD(int64_t, region_get_navigation_layers);
    METHOD(Variant, region_set_transform);
    METHOD(Transform3D, region_get_transform);
    METHOD(Variant, region_set_navigation_mesh);
    METHOD(Variant, region_bake_navigation_mesh);
    METHOD(int64_t, region_get_connections_count);
    METHOD(Vector3, region_get_connection_pathway_start);
    METHOD(Vector3, region_get_connection_pathway_end);
    METHOD(Vector3, region_get_random_point);
    METHOD(::RID, link_create);
    METHOD(Variant, link_set_map);
    METHOD(::RID, link_get_map);
    METHOD(Variant, link_set_enabled);
    METHOD(bool, link_get_enabled);
    METHOD(Variant, link_set_bidirectional);
    METHOD(bool, link_is_bidirectional);
    METHOD(Variant, link_set_navigation_layers);
    METHOD(int64_t, link_get_navigation_layers);
    METHOD(Variant, link_set_start_position);
    METHOD(Vector3, link_get_start_position);
    METHOD(Variant, link_set_end_position);
    METHOD(Vector3, link_get_end_position);
    METHOD(Variant, link_set_enter_cost);
    METHOD(double, link_get_enter_cost);
    METHOD(Variant, link_set_travel_cost);
    METHOD(double, link_get_travel_cost);
    METHOD(Variant, link_set_owner_id);
    METHOD(int64_t, link_get_owner_id);
    METHOD(::RID, agent_create);
    METHOD(Variant, agent_set_avoidance_enabled);
    METHOD(bool, agent_get_avoidance_enabled);
    METHOD(Variant, agent_set_use_3d_avoidance);
    METHOD(bool, agent_get_use_3d_avoidance);
    METHOD(Variant, agent_set_map);
    METHOD(::RID, agent_get_map);
    METHOD(Variant, agent_set_paused);
    METHOD(bool, agent_get_paused);
    METHOD(Variant, agent_set_neighbor_distance);
    METHOD(double, agent_get_neighbor_distance);
    METHOD(Variant, agent_set_max_neighbors);
    METHOD(int64_t, agent_get_max_neighbors);
    METHOD(Variant, agent_set_time_horizon_agents);
    METHOD(double, agent_get_time_horizon_agents);
    METHOD(Variant, agent_set_time_horizon_obstacles);
    METHOD(double, agent_get_time_horizon_obstacles);
    METHOD(Variant, agent_set_radius);
    METHOD(double, agent_get_radius);
    METHOD(Variant, agent_set_height);
    METHOD(double, agent_get_height);
    METHOD(Variant, agent_set_max_speed);
    METHOD(double, agent_get_max_speed);
    METHOD(Variant, agent_set_velocity_forced);
    METHOD(Variant, agent_set_velocity);
    METHOD(Vector3, agent_get_velocity);
    METHOD(Variant, agent_set_position);
    METHOD(Vector3, agent_get_position);
    METHOD(bool, agent_is_map_changed);
    METHOD(Variant, agent_set_avoidance_callback);
    METHOD(bool, agent_has_avoidance_callback);
    METHOD(Variant, agent_set_avoidance_layers);
    METHOD(int64_t, agent_get_avoidance_layers);
    METHOD(Variant, agent_set_avoidance_mask);
    METHOD(int64_t, agent_get_avoidance_mask);
    METHOD(Variant, agent_set_avoidance_priority);
    METHOD(double, agent_get_avoidance_priority);
    METHOD(::RID, obstacle_create);
    METHOD(Variant, obstacle_set_avoidance_enabled);
    METHOD(bool, obstacle_get_avoidance_enabled);
    METHOD(Variant, obstacle_set_use_3d_avoidance);
    METHOD(bool, obstacle_get_use_3d_avoidance);
    METHOD(Variant, obstacle_set_map);
    METHOD(::RID, obstacle_get_map);
    METHOD(Variant, obstacle_set_paused);
    METHOD(bool, obstacle_get_paused);
    METHOD(Variant, obstacle_set_radius);
    METHOD(double, obstacle_get_radius);
    METHOD(Variant, obstacle_set_height);
    METHOD(double, obstacle_get_height);
    METHOD(Variant, obstacle_set_velocity);
    METHOD(Vector3, obstacle_get_velocity);
    METHOD(Variant, obstacle_set_position);
    METHOD(Vector3, obstacle_get_position);
    METHOD(Variant, obstacle_set_vertices);
    METHOD(PackedArray<Vector3>, obstacle_get_vertices);
    METHOD(Variant, obstacle_set_avoidance_layers);
    METHOD(int64_t, obstacle_get_avoidance_layers);
    METHOD(Variant, parse_source_geometry_data);
    METHOD(Variant, bake_from_source_geometry_data);
    METHOD(Variant, bake_from_source_geometry_data_async);
    METHOD(bool, is_baking_navigation_mesh);
    METHOD(::RID, source_geometry_parser_create);
    METHOD(Variant, source_geometry_parser_set_callback);
    METHOD(PackedArray<Vector3>, simplify_path);
    METHOD(Variant, free_rid);
    METHOD(void, set_active);
    METHOD(void, set_debug_enabled);
    METHOD(bool, get_debug_enabled);
    METHOD(int64_t, get_process_info);
    static constexpr int64_t INFO_ACTIVE_MAPS = 0;
    static constexpr int64_t INFO_REGION_COUNT = 1;
    static constexpr int64_t INFO_AGENT_COUNT = 2;
    static constexpr int64_t INFO_LINK_COUNT = 3;
    static constexpr int64_t INFO_POLYGON_COUNT = 4;
    static constexpr int64_t INFO_EDGE_COUNT = 5;
    static constexpr int64_t INFO_EDGE_MERGE_COUNT = 6;
    static constexpr int64_t INFO_EDGE_CONNECTION_COUNT = 7;
    static constexpr int64_t INFO_EDGE_FREE_COUNT = 8;
    static NavigationServer3D get_singleton() { return NavigationServer3D(Object("NavigationServer3D").address()); }
};
struct NinePatchRect : public Control {
    using Control::Control;
    PROPERTY(texture, Object);
    PROPERTY(draw_center, bool);
    PROPERTY(region_rect, Rect2);
    PROPERTY(patch_margin_left, int64_t);
    PROPERTY(patch_margin_top, int64_t);
    PROPERTY(patch_margin_right, int64_t);
    PROPERTY(patch_margin_bottom, int64_t);
    PROPERTY(axis_stretch_horizontal, int64_t);
    PROPERTY(axis_stretch_vertical, int64_t);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_patch_margin);
    METHOD(int64_t, get_patch_margin);
    METHOD(void, set_region_rect);
    METHOD(Rect2, get_region_rect);
    METHOD(void, set_draw_center);
    METHOD(bool, is_draw_center_enabled);
    METHOD(void, set_h_axis_stretch_mode);
    METHOD(int64_t, get_h_axis_stretch_mode);
    METHOD(void, set_v_axis_stretch_mode);
    METHOD(int64_t, get_v_axis_stretch_mode);
    static constexpr int64_t AXIS_STRETCH_MODE_STRETCH = 0;
    static constexpr int64_t AXIS_STRETCH_MODE_TILE = 1;
    static constexpr int64_t AXIS_STRETCH_MODE_TILE_FIT = 2;
};
struct OpenXRCompositionLayer : public Node3D {
    using Node3D::Node3D;
    PROPERTY(layer_viewport, Object);
    PROPERTY(sort_order, int64_t);
    PROPERTY(alpha_blend, bool);
    PROPERTY(enable_hole_punch, bool);
    METHOD(void, set_layer_viewport);
    METHOD(Object, get_layer_viewport);
    METHOD(void, set_enable_hole_punch);
    METHOD(bool, get_enable_hole_punch);
    METHOD(void, set_sort_order);
    METHOD(int64_t, get_sort_order);
    METHOD(void, set_alpha_blend);
    METHOD(bool, get_alpha_blend);
    METHOD(bool, is_natively_supported);
    METHOD(Vector2, intersects_ray);
};
struct OpenXRCompositionLayerCylinder : public OpenXRCompositionLayer {
    using OpenXRCompositionLayer::OpenXRCompositionLayer;
    PROPERTY(radius, double);
    PROPERTY(aspect_ratio, double);
    PROPERTY(central_angle, double);
    PROPERTY(fallback_segments, int64_t);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_aspect_ratio);
    METHOD(double, get_aspect_ratio);
    METHOD(void, set_central_angle);
    METHOD(double, get_central_angle);
    METHOD(void, set_fallback_segments);
    METHOD(int64_t, get_fallback_segments);
};
struct OpenXRCompositionLayerEquirect : public OpenXRCompositionLayer {
    using OpenXRCompositionLayer::OpenXRCompositionLayer;
    PROPERTY(radius, double);
    PROPERTY(central_horizontal_angle, double);
    PROPERTY(upper_vertical_angle, double);
    PROPERTY(lower_vertical_angle, double);
    PROPERTY(fallback_segments, int64_t);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_central_horizontal_angle);
    METHOD(double, get_central_horizontal_angle);
    METHOD(void, set_upper_vertical_angle);
    METHOD(double, get_upper_vertical_angle);
    METHOD(void, set_lower_vertical_angle);
    METHOD(double, get_lower_vertical_angle);
    METHOD(void, set_fallback_segments);
    METHOD(int64_t, get_fallback_segments);
};
struct OpenXRCompositionLayerQuad : public OpenXRCompositionLayer {
    using OpenXRCompositionLayer::OpenXRCompositionLayer;
    PROPERTY(quad_size, Vector2);
    METHOD(void, set_quad_size);
    METHOD(Vector2, get_quad_size);
};
struct OpenXRExtensionWrapperExtension : public Object {
    using Object::Object;
    METHOD(Dictionary, _get_requested_extensions);
    METHOD(int64_t, _set_system_properties_and_get_next_pointer);
    METHOD(int64_t, _set_instance_create_info_and_get_next_pointer);
    METHOD(int64_t, _set_session_create_and_get_next_pointer);
    METHOD(int64_t, _set_swapchain_create_info_and_get_next_pointer);
    METHOD(int64_t, _set_hand_joint_locations_and_get_next_pointer);
    METHOD(int64_t, _get_composition_layer_count);
    METHOD(int64_t, _get_composition_layer);
    METHOD(int64_t, _get_composition_layer_order);
    METHOD(PackedArray<std::string>, _get_suggested_tracker_names);
    METHOD(Variant, _on_register_metadata);
    METHOD(Variant, _on_before_instance_created);
    METHOD(Variant, _on_instance_created);
    METHOD(Variant, _on_instance_destroyed);
    METHOD(Variant, _on_session_created);
    METHOD(Variant, _on_process);
    METHOD(Variant, _on_pre_render);
    METHOD(Variant, _on_main_swapchains_created);
    METHOD(Variant, _on_session_destroyed);
    METHOD(Variant, _on_state_idle);
    METHOD(Variant, _on_state_ready);
    METHOD(Variant, _on_state_synchronized);
    METHOD(Variant, _on_state_visible);
    METHOD(Variant, _on_state_focused);
    METHOD(Variant, _on_state_stopping);
    METHOD(Variant, _on_state_loss_pending);
    METHOD(Variant, _on_state_exiting);
    METHOD(bool, _on_event_polled);
    METHOD(int64_t, _set_viewport_composition_layer_and_get_next_pointer);
    METHOD(Array, _get_viewport_composition_layer_extension_properties);
    METHOD(Dictionary, _get_viewport_composition_layer_extension_property_defaults);
    METHOD(Variant, _on_viewport_composition_layer_destroyed);
    METHOD(Object, get_openxr_api);
    METHOD(Variant, register_extension_wrapper);
};
struct OpenXRHand : public Node3D {
    using Node3D::Node3D;
    PROPERTY(hand, int64_t);
    PROPERTY(motion_range, int64_t);
    PROPERTY(hand_skeleton, String);
    PROPERTY(skeleton_rig, int64_t);
    PROPERTY(bone_update, int64_t);
    METHOD(void, set_hand);
    METHOD(int64_t, get_hand);
    METHOD(void, set_hand_skeleton);
    METHOD(String, get_hand_skeleton);
    METHOD(void, set_motion_range);
    METHOD(int64_t, get_motion_range);
    METHOD(void, set_skeleton_rig);
    METHOD(int64_t, get_skeleton_rig);
    METHOD(void, set_bone_update);
    METHOD(int64_t, get_bone_update);
    static constexpr int64_t HAND_LEFT = 0;
    static constexpr int64_t HAND_RIGHT = 1;
    static constexpr int64_t HAND_MAX = 2;
    static constexpr int64_t MOTION_RANGE_UNOBSTRUCTED = 0;
    static constexpr int64_t MOTION_RANGE_CONFORM_TO_CONTROLLER = 1;
    static constexpr int64_t MOTION_RANGE_MAX = 2;
    static constexpr int64_t SKELETON_RIG_OPENXR = 0;
    static constexpr int64_t SKELETON_RIG_HUMANOID = 1;
    static constexpr int64_t SKELETON_RIG_MAX = 2;
    static constexpr int64_t BONE_UPDATE_FULL = 0;
    static constexpr int64_t BONE_UPDATE_ROTATION_ONLY = 1;
    static constexpr int64_t BONE_UPDATE_MAX = 2;
};
struct OpenXRInteractionProfileMetadata : public Object {
    using Object::Object;
    METHOD(Variant, register_profile_rename);
    METHOD(Variant, register_top_level_path);
    METHOD(Variant, register_interaction_profile);
    METHOD(Variant, register_io_path);
};
struct Panel : public Control {
    using Control::Control;
};
struct Parallax2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(scroll_scale, Vector2);
    PROPERTY(scroll_offset, Vector2);
    PROPERTY(repeat_size, Vector2);
    PROPERTY(autoscroll, Vector2);
    PROPERTY(repeat_times, int64_t);
    PROPERTY(limit_begin, Vector2);
    PROPERTY(limit_end, Vector2);
    PROPERTY(follow_viewport, bool);
    PROPERTY(ignore_camera_scroll, bool);
    PROPERTY(screen_offset, Vector2);
    METHOD(Variant, _camera_moved);
    METHOD(void, set_scroll_scale);
    METHOD(Vector2, get_scroll_scale);
    METHOD(void, set_repeat_size);
    METHOD(Vector2, get_repeat_size);
    METHOD(void, set_repeat_times);
    METHOD(int64_t, get_repeat_times);
    METHOD(void, set_autoscroll);
    METHOD(Vector2, get_autoscroll);
    METHOD(void, set_scroll_offset);
    METHOD(Vector2, get_scroll_offset);
    METHOD(void, set_screen_offset);
    METHOD(Vector2, get_screen_offset);
    METHOD(void, set_limit_begin);
    METHOD(Vector2, get_limit_begin);
    METHOD(void, set_limit_end);
    METHOD(Vector2, get_limit_end);
    METHOD(void, set_follow_viewport);
    METHOD(bool, get_follow_viewport);
    METHOD(void, set_ignore_camera_scroll);
    METHOD(bool, is_ignore_camera_scroll);
};
struct ParallaxBackground : public CanvasLayer {
    using CanvasLayer::CanvasLayer;
    PROPERTY(scroll_offset, Vector2);
    PROPERTY(scroll_base_offset, Vector2);
    PROPERTY(scroll_base_scale, Vector2);
    PROPERTY(scroll_limit_begin, Vector2);
    PROPERTY(scroll_limit_end, Vector2);
    PROPERTY(scroll_ignore_camera_zoom, bool);
    METHOD(Variant, _camera_moved);
    METHOD(void, set_scroll_offset);
    METHOD(Vector2, get_scroll_offset);
    METHOD(void, set_scroll_base_offset);
    METHOD(Vector2, get_scroll_base_offset);
    METHOD(void, set_scroll_base_scale);
    METHOD(Vector2, get_scroll_base_scale);
    METHOD(void, set_limit_begin);
    METHOD(Vector2, get_limit_begin);
    METHOD(void, set_limit_end);
    METHOD(Vector2, get_limit_end);
    METHOD(void, set_ignore_camera_zoom);
    METHOD(bool, is_ignore_camera_zoom);
};
struct ParallaxLayer : public Node2D {
    using Node2D::Node2D;
    PROPERTY(motion_scale, Vector2);
    PROPERTY(motion_offset, Vector2);
    PROPERTY(motion_mirroring, Vector2);
    METHOD(void, set_motion_scale);
    METHOD(Vector2, get_motion_scale);
    METHOD(void, set_motion_offset);
    METHOD(Vector2, get_motion_offset);
    METHOD(void, set_mirroring);
    METHOD(Vector2, get_mirroring);
};
struct Path2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(curve, Object);
    METHOD(void, set_curve);
    METHOD(Object, get_curve);
};
struct Path3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(curve, Object);
    METHOD(void, set_curve);
    METHOD(Object, get_curve);
};
struct PathFollow2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(progress, double);
    PROPERTY(progress_ratio, double);
    PROPERTY(h_offset, double);
    PROPERTY(v_offset, double);
    PROPERTY(rotates, bool);
    PROPERTY(cubic_interp, bool);
    PROPERTY(loop, bool);
    METHOD(void, set_progress);
    METHOD(double, get_progress);
    METHOD(void, set_h_offset);
    METHOD(double, get_h_offset);
    METHOD(void, set_v_offset);
    METHOD(double, get_v_offset);
    METHOD(void, set_progress_ratio);
    METHOD(double, get_progress_ratio);
    METHOD(void, set_rotates);
    METHOD(bool, is_rotating);
    METHOD(void, set_cubic_interpolation);
    METHOD(bool, get_cubic_interpolation);
    METHOD(void, set_loop);
    METHOD(bool, has_loop);
};
struct PathFollow3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(progress, double);
    PROPERTY(progress_ratio, double);
    PROPERTY(h_offset, double);
    PROPERTY(v_offset, double);
    PROPERTY(rotation_mode, int64_t);
    PROPERTY(use_model_front, bool);
    PROPERTY(cubic_interp, bool);
    PROPERTY(loop, bool);
    PROPERTY(tilt_enabled, bool);
    METHOD(void, set_progress);
    METHOD(double, get_progress);
    METHOD(void, set_h_offset);
    METHOD(double, get_h_offset);
    METHOD(void, set_v_offset);
    METHOD(double, get_v_offset);
    METHOD(void, set_progress_ratio);
    METHOD(double, get_progress_ratio);
    METHOD(void, set_rotation_mode);
    METHOD(int64_t, get_rotation_mode);
    METHOD(void, set_cubic_interpolation);
    METHOD(bool, get_cubic_interpolation);
    METHOD(void, set_use_model_front);
    METHOD(bool, is_using_model_front);
    METHOD(void, set_loop);
    METHOD(bool, has_loop);
    METHOD(void, set_tilt_enabled);
    METHOD(bool, is_tilt_enabled);
    METHOD(Transform3D, correct_posture);
    static constexpr int64_t ROTATION_NONE = 0;
    static constexpr int64_t ROTATION_Y = 1;
    static constexpr int64_t ROTATION_XY = 2;
    static constexpr int64_t ROTATION_XYZ = 3;
    static constexpr int64_t ROTATION_ORIENTED = 4;
};
struct Performance : public Object {
    using Object::Object;
    METHOD(double, get_monitor);
    METHOD(Variant, add_custom_monitor);
    METHOD(Variant, remove_custom_monitor);
    METHOD(bool, has_custom_monitor);
    METHOD(Variant, get_custom_monitor);
    METHOD(int64_t, get_monitor_modification_time);
    METHOD(Array, get_custom_monitor_names);
    static constexpr int64_t TIME_FPS = 0;
    static constexpr int64_t TIME_PROCESS = 1;
    static constexpr int64_t TIME_PHYSICS_PROCESS = 2;
    static constexpr int64_t TIME_NAVIGATION_PROCESS = 3;
    static constexpr int64_t MEMORY_STATIC = 4;
    static constexpr int64_t MEMORY_STATIC_MAX = 5;
    static constexpr int64_t MEMORY_MESSAGE_BUFFER_MAX = 6;
    static constexpr int64_t OBJECT_COUNT = 7;
    static constexpr int64_t OBJECT_RESOURCE_COUNT = 8;
    static constexpr int64_t OBJECT_NODE_COUNT = 9;
    static constexpr int64_t OBJECT_ORPHAN_NODE_COUNT = 10;
    static constexpr int64_t RENDER_TOTAL_OBJECTS_IN_FRAME = 11;
    static constexpr int64_t RENDER_TOTAL_PRIMITIVES_IN_FRAME = 12;
    static constexpr int64_t RENDER_TOTAL_DRAW_CALLS_IN_FRAME = 13;
    static constexpr int64_t RENDER_VIDEO_MEM_USED = 14;
    static constexpr int64_t RENDER_TEXTURE_MEM_USED = 15;
    static constexpr int64_t RENDER_BUFFER_MEM_USED = 16;
    static constexpr int64_t PHYSICS_2D_ACTIVE_OBJECTS = 17;
    static constexpr int64_t PHYSICS_2D_COLLISION_PAIRS = 18;
    static constexpr int64_t PHYSICS_2D_ISLAND_COUNT = 19;
    static constexpr int64_t PHYSICS_3D_ACTIVE_OBJECTS = 20;
    static constexpr int64_t PHYSICS_3D_COLLISION_PAIRS = 21;
    static constexpr int64_t PHYSICS_3D_ISLAND_COUNT = 22;
    static constexpr int64_t AUDIO_OUTPUT_LATENCY = 23;
    static constexpr int64_t NAVIGATION_ACTIVE_MAPS = 24;
    static constexpr int64_t NAVIGATION_REGION_COUNT = 25;
    static constexpr int64_t NAVIGATION_AGENT_COUNT = 26;
    static constexpr int64_t NAVIGATION_LINK_COUNT = 27;
    static constexpr int64_t NAVIGATION_POLYGON_COUNT = 28;
    static constexpr int64_t NAVIGATION_EDGE_COUNT = 29;
    static constexpr int64_t NAVIGATION_EDGE_MERGE_COUNT = 30;
    static constexpr int64_t NAVIGATION_EDGE_CONNECTION_COUNT = 31;
    static constexpr int64_t NAVIGATION_EDGE_FREE_COUNT = 32;
    static constexpr int64_t MONITOR_MAX = 33;
    static Performance get_singleton() { return Performance(Object("Performance").address()); }
};
struct PhysicsBody2D : public CollisionObject2D {
    using CollisionObject2D::CollisionObject2D;
    METHOD(Object, move_and_collide);
    METHOD(bool, test_move);
    METHOD(Vector2, get_gravity);
    METHOD(Array, get_collision_exceptions);
    METHOD(Variant, add_collision_exception_with);
    METHOD(Variant, remove_collision_exception_with);
};
struct PhysicsBody3D : public CollisionObject3D {
    using CollisionObject3D::CollisionObject3D;
    PROPERTY(axis_lock_linear_x, bool);
    PROPERTY(axis_lock_linear_y, bool);
    PROPERTY(axis_lock_linear_z, bool);
    PROPERTY(axis_lock_angular_x, bool);
    PROPERTY(axis_lock_angular_y, bool);
    PROPERTY(axis_lock_angular_z, bool);
    METHOD(Object, move_and_collide);
    METHOD(bool, test_move);
    METHOD(Vector3, get_gravity);
    METHOD(void, set_axis_lock);
    METHOD(bool, get_axis_lock);
    METHOD(Array, get_collision_exceptions);
    METHOD(Variant, add_collision_exception_with);
    METHOD(Variant, remove_collision_exception_with);
};
struct PhysicsDirectBodyState2D : public Object {
    using Object::Object;
    PROPERTY(step, double);
    PROPERTY(inverse_mass, double);
    PROPERTY(inverse_inertia, double);
    PROPERTY(total_angular_damp, double);
    PROPERTY(total_linear_damp, double);
    PROPERTY(total_gravity, Vector2);
    PROPERTY(center_of_mass, Vector2);
    PROPERTY(center_of_mass_local, Vector2);
    PROPERTY(angular_velocity, double);
    PROPERTY(linear_velocity, Vector2);
    PROPERTY(sleeping, bool);
    PROPERTY(transform, Transform2D);
    METHOD(Vector2, get_total_gravity);
    METHOD(double, get_total_linear_damp);
    METHOD(double, get_total_angular_damp);
    METHOD(Vector2, get_center_of_mass);
    METHOD(Vector2, get_center_of_mass_local);
    METHOD(double, get_inverse_mass);
    METHOD(double, get_inverse_inertia);
    METHOD(void, set_linear_velocity);
    METHOD(Vector2, get_linear_velocity);
    METHOD(void, set_angular_velocity);
    METHOD(double, get_angular_velocity);
    METHOD(void, set_transform);
    METHOD(Transform2D, get_transform);
    METHOD(Vector2, get_velocity_at_local_position);
    METHOD(Variant, apply_central_impulse);
    METHOD(Variant, apply_torque_impulse);
    METHOD(Variant, apply_impulse);
    METHOD(Variant, apply_central_force);
    METHOD(Variant, apply_force);
    METHOD(Variant, apply_torque);
    METHOD(Variant, add_constant_central_force);
    METHOD(Variant, add_constant_force);
    METHOD(Variant, add_constant_torque);
    METHOD(void, set_constant_force);
    METHOD(Vector2, get_constant_force);
    METHOD(void, set_constant_torque);
    METHOD(double, get_constant_torque);
    METHOD(void, set_sleep_state);
    METHOD(bool, is_sleeping);
    METHOD(int64_t, get_contact_count);
    METHOD(Vector2, get_contact_local_position);
    METHOD(Vector2, get_contact_local_normal);
    METHOD(int64_t, get_contact_local_shape);
    METHOD(Vector2, get_contact_local_velocity_at_position);
    METHOD(::RID, get_contact_collider);
    METHOD(Vector2, get_contact_collider_position);
    METHOD(int64_t, get_contact_collider_id);
    METHOD(Object, get_contact_collider_object);
    METHOD(int64_t, get_contact_collider_shape);
    METHOD(Vector2, get_contact_collider_velocity_at_position);
    METHOD(Vector2, get_contact_impulse);
    METHOD(double, get_step);
    METHOD(Variant, integrate_forces);
    METHOD(Object, get_space_state);
};
struct PhysicsDirectBodyState2DExtension : public PhysicsDirectBodyState2D {
    using PhysicsDirectBodyState2D::PhysicsDirectBodyState2D;
    METHOD(Vector2, _get_total_gravity);
    METHOD(double, _get_total_linear_damp);
    METHOD(double, _get_total_angular_damp);
    METHOD(Vector2, _get_center_of_mass);
    METHOD(Vector2, _get_center_of_mass_local);
    METHOD(double, _get_inverse_mass);
    METHOD(double, _get_inverse_inertia);
    METHOD(Variant, _set_linear_velocity);
    METHOD(Vector2, _get_linear_velocity);
    METHOD(Variant, _set_angular_velocity);
    METHOD(double, _get_angular_velocity);
    METHOD(Variant, _set_transform);
    METHOD(Transform2D, _get_transform);
    METHOD(Vector2, _get_velocity_at_local_position);
    METHOD(Variant, _apply_central_impulse);
    METHOD(Variant, _apply_impulse);
    METHOD(Variant, _apply_torque_impulse);
    METHOD(Variant, _apply_central_force);
    METHOD(Variant, _apply_force);
    METHOD(Variant, _apply_torque);
    METHOD(Variant, _add_constant_central_force);
    METHOD(Variant, _add_constant_force);
    METHOD(Variant, _add_constant_torque);
    METHOD(Variant, _set_constant_force);
    METHOD(Vector2, _get_constant_force);
    METHOD(Variant, _set_constant_torque);
    METHOD(double, _get_constant_torque);
    METHOD(Variant, _set_sleep_state);
    METHOD(bool, _is_sleeping);
    METHOD(int64_t, _get_contact_count);
    METHOD(Vector2, _get_contact_local_position);
    METHOD(Vector2, _get_contact_local_normal);
    METHOD(int64_t, _get_contact_local_shape);
    METHOD(Vector2, _get_contact_local_velocity_at_position);
    METHOD(::RID, _get_contact_collider);
    METHOD(Vector2, _get_contact_collider_position);
    METHOD(int64_t, _get_contact_collider_id);
    METHOD(Object, _get_contact_collider_object);
    METHOD(int64_t, _get_contact_collider_shape);
    METHOD(Vector2, _get_contact_collider_velocity_at_position);
    METHOD(Vector2, _get_contact_impulse);
    METHOD(double, _get_step);
    METHOD(Variant, _integrate_forces);
    METHOD(Object, _get_space_state);
};
struct PhysicsDirectBodyState3D : public Object {
    using Object::Object;
    PROPERTY(step, double);
    PROPERTY(inverse_mass, double);
    PROPERTY(total_angular_damp, double);
    PROPERTY(total_linear_damp, double);
    PROPERTY(inverse_inertia, Vector3);
    PROPERTY(inverse_inertia_tensor, Basis);
    PROPERTY(total_gravity, Vector3);
    PROPERTY(center_of_mass, Vector3);
    PROPERTY(center_of_mass_local, Vector3);
    PROPERTY(principal_inertia_axes, Basis);
    PROPERTY(angular_velocity, Vector3);
    PROPERTY(linear_velocity, Vector3);
    PROPERTY(sleeping, bool);
    PROPERTY(transform, Transform3D);
    METHOD(Vector3, get_total_gravity);
    METHOD(double, get_total_linear_damp);
    METHOD(double, get_total_angular_damp);
    METHOD(Vector3, get_center_of_mass);
    METHOD(Vector3, get_center_of_mass_local);
    METHOD(Basis, get_principal_inertia_axes);
    METHOD(double, get_inverse_mass);
    METHOD(Vector3, get_inverse_inertia);
    METHOD(Basis, get_inverse_inertia_tensor);
    METHOD(void, set_linear_velocity);
    METHOD(Vector3, get_linear_velocity);
    METHOD(void, set_angular_velocity);
    METHOD(Vector3, get_angular_velocity);
    METHOD(void, set_transform);
    METHOD(Transform3D, get_transform);
    METHOD(Vector3, get_velocity_at_local_position);
    METHOD(Variant, apply_central_impulse);
    METHOD(Variant, apply_impulse);
    METHOD(Variant, apply_torque_impulse);
    METHOD(Variant, apply_central_force);
    METHOD(Variant, apply_force);
    METHOD(Variant, apply_torque);
    METHOD(Variant, add_constant_central_force);
    METHOD(Variant, add_constant_force);
    METHOD(Variant, add_constant_torque);
    METHOD(void, set_constant_force);
    METHOD(Vector3, get_constant_force);
    METHOD(void, set_constant_torque);
    METHOD(Vector3, get_constant_torque);
    METHOD(void, set_sleep_state);
    METHOD(bool, is_sleeping);
    METHOD(int64_t, get_contact_count);
    METHOD(Vector3, get_contact_local_position);
    METHOD(Vector3, get_contact_local_normal);
    METHOD(Vector3, get_contact_impulse);
    METHOD(int64_t, get_contact_local_shape);
    METHOD(Vector3, get_contact_local_velocity_at_position);
    METHOD(::RID, get_contact_collider);
    METHOD(Vector3, get_contact_collider_position);
    METHOD(int64_t, get_contact_collider_id);
    METHOD(Object, get_contact_collider_object);
    METHOD(int64_t, get_contact_collider_shape);
    METHOD(Vector3, get_contact_collider_velocity_at_position);
    METHOD(double, get_step);
    METHOD(Variant, integrate_forces);
    METHOD(Object, get_space_state);
};
struct PhysicsDirectBodyState3DExtension : public PhysicsDirectBodyState3D {
    using PhysicsDirectBodyState3D::PhysicsDirectBodyState3D;
    METHOD(Vector3, _get_total_gravity);
    METHOD(double, _get_total_linear_damp);
    METHOD(double, _get_total_angular_damp);
    METHOD(Vector3, _get_center_of_mass);
    METHOD(Vector3, _get_center_of_mass_local);
    METHOD(Basis, _get_principal_inertia_axes);
    METHOD(double, _get_inverse_mass);
    METHOD(Vector3, _get_inverse_inertia);
    METHOD(Basis, _get_inverse_inertia_tensor);
    METHOD(Variant, _set_linear_velocity);
    METHOD(Vector3, _get_linear_velocity);
    METHOD(Variant, _set_angular_velocity);
    METHOD(Vector3, _get_angular_velocity);
    METHOD(Variant, _set_transform);
    METHOD(Transform3D, _get_transform);
    METHOD(Vector3, _get_velocity_at_local_position);
    METHOD(Variant, _apply_central_impulse);
    METHOD(Variant, _apply_impulse);
    METHOD(Variant, _apply_torque_impulse);
    METHOD(Variant, _apply_central_force);
    METHOD(Variant, _apply_force);
    METHOD(Variant, _apply_torque);
    METHOD(Variant, _add_constant_central_force);
    METHOD(Variant, _add_constant_force);
    METHOD(Variant, _add_constant_torque);
    METHOD(Variant, _set_constant_force);
    METHOD(Vector3, _get_constant_force);
    METHOD(Variant, _set_constant_torque);
    METHOD(Vector3, _get_constant_torque);
    METHOD(Variant, _set_sleep_state);
    METHOD(bool, _is_sleeping);
    METHOD(int64_t, _get_contact_count);
    METHOD(Vector3, _get_contact_local_position);
    METHOD(Vector3, _get_contact_local_normal);
    METHOD(Vector3, _get_contact_impulse);
    METHOD(int64_t, _get_contact_local_shape);
    METHOD(Vector3, _get_contact_local_velocity_at_position);
    METHOD(::RID, _get_contact_collider);
    METHOD(Vector3, _get_contact_collider_position);
    METHOD(int64_t, _get_contact_collider_id);
    METHOD(Object, _get_contact_collider_object);
    METHOD(int64_t, _get_contact_collider_shape);
    METHOD(Vector3, _get_contact_collider_velocity_at_position);
    METHOD(double, _get_step);
    METHOD(Variant, _integrate_forces);
    METHOD(Object, _get_space_state);
};
struct PhysicsDirectSpaceState2D : public Object {
    using Object::Object;
    METHOD(Array, intersect_point);
    METHOD(Dictionary, intersect_ray);
    METHOD(Array, intersect_shape);
    METHOD(PackedArray<float>, cast_motion);
    METHOD(Array, collide_shape);
    METHOD(Dictionary, get_rest_info);
};
struct PhysicsDirectSpaceState2DExtension : public PhysicsDirectSpaceState2D {
    using PhysicsDirectSpaceState2D::PhysicsDirectSpaceState2D;
    METHOD(bool, _intersect_ray);
    METHOD(int64_t, _intersect_point);
    METHOD(int64_t, _intersect_shape);
    METHOD(bool, _cast_motion);
    METHOD(bool, _collide_shape);
    METHOD(bool, _rest_info);
    METHOD(bool, is_body_excluded_from_query);
};
struct PhysicsDirectSpaceState3D : public Object {
    using Object::Object;
    METHOD(Array, intersect_point);
    METHOD(Dictionary, intersect_ray);
    METHOD(Array, intersect_shape);
    METHOD(PackedArray<float>, cast_motion);
    METHOD(Array, collide_shape);
    METHOD(Dictionary, get_rest_info);
};
struct PhysicsDirectSpaceState3DExtension : public PhysicsDirectSpaceState3D {
    using PhysicsDirectSpaceState3D::PhysicsDirectSpaceState3D;
    METHOD(bool, _intersect_ray);
    METHOD(int64_t, _intersect_point);
    METHOD(int64_t, _intersect_shape);
    METHOD(bool, _cast_motion);
    METHOD(bool, _collide_shape);
    METHOD(bool, _rest_info);
    METHOD(Vector3, _get_closest_point_to_object_volume);
    METHOD(bool, is_body_excluded_from_query);
};
struct PhysicsServer2D : public Object {
    using Object::Object;
    METHOD(::RID, world_boundary_shape_create);
    METHOD(::RID, separation_ray_shape_create);
    METHOD(::RID, segment_shape_create);
    METHOD(::RID, circle_shape_create);
    METHOD(::RID, rectangle_shape_create);
    METHOD(::RID, capsule_shape_create);
    METHOD(::RID, convex_polygon_shape_create);
    METHOD(::RID, concave_polygon_shape_create);
    METHOD(Variant, shape_set_data);
    METHOD(int64_t, shape_get_type);
    METHOD(Variant, shape_get_data);
    METHOD(::RID, space_create);
    METHOD(Variant, space_set_active);
    METHOD(bool, space_is_active);
    METHOD(Variant, space_set_param);
    METHOD(double, space_get_param);
    METHOD(Object, space_get_direct_state);
    METHOD(::RID, area_create);
    METHOD(Variant, area_set_space);
    METHOD(::RID, area_get_space);
    METHOD(Variant, area_add_shape);
    METHOD(Variant, area_set_shape);
    METHOD(Variant, area_set_shape_transform);
    METHOD(Variant, area_set_shape_disabled);
    METHOD(int64_t, area_get_shape_count);
    METHOD(::RID, area_get_shape);
    METHOD(Transform2D, area_get_shape_transform);
    METHOD(Variant, area_remove_shape);
    METHOD(Variant, area_clear_shapes);
    METHOD(Variant, area_set_collision_layer);
    METHOD(int64_t, area_get_collision_layer);
    METHOD(Variant, area_set_collision_mask);
    METHOD(int64_t, area_get_collision_mask);
    METHOD(Variant, area_set_param);
    METHOD(Variant, area_set_transform);
    METHOD(Variant, area_get_param);
    METHOD(Transform2D, area_get_transform);
    METHOD(Variant, area_attach_object_instance_id);
    METHOD(int64_t, area_get_object_instance_id);
    METHOD(Variant, area_attach_canvas_instance_id);
    METHOD(int64_t, area_get_canvas_instance_id);
    METHOD(Variant, area_set_monitor_callback);
    METHOD(Variant, area_set_area_monitor_callback);
    METHOD(Variant, area_set_monitorable);
    METHOD(::RID, body_create);
    METHOD(Variant, body_set_space);
    METHOD(::RID, body_get_space);
    METHOD(Variant, body_set_mode);
    METHOD(int64_t, body_get_mode);
    METHOD(Variant, body_add_shape);
    METHOD(Variant, body_set_shape);
    METHOD(Variant, body_set_shape_transform);
    METHOD(int64_t, body_get_shape_count);
    METHOD(::RID, body_get_shape);
    METHOD(Transform2D, body_get_shape_transform);
    METHOD(Variant, body_remove_shape);
    METHOD(Variant, body_clear_shapes);
    METHOD(Variant, body_set_shape_disabled);
    METHOD(Variant, body_set_shape_as_one_way_collision);
    METHOD(Variant, body_attach_object_instance_id);
    METHOD(int64_t, body_get_object_instance_id);
    METHOD(Variant, body_attach_canvas_instance_id);
    METHOD(int64_t, body_get_canvas_instance_id);
    METHOD(Variant, body_set_continuous_collision_detection_mode);
    METHOD(int64_t, body_get_continuous_collision_detection_mode);
    METHOD(Variant, body_set_collision_layer);
    METHOD(int64_t, body_get_collision_layer);
    METHOD(Variant, body_set_collision_mask);
    METHOD(int64_t, body_get_collision_mask);
    METHOD(Variant, body_set_collision_priority);
    METHOD(double, body_get_collision_priority);
    METHOD(Variant, body_set_param);
    METHOD(Variant, body_get_param);
    METHOD(Variant, body_reset_mass_properties);
    METHOD(Variant, body_set_state);
    METHOD(Variant, body_get_state);
    METHOD(Variant, body_apply_central_impulse);
    METHOD(Variant, body_apply_torque_impulse);
    METHOD(Variant, body_apply_impulse);
    METHOD(Variant, body_apply_central_force);
    METHOD(Variant, body_apply_force);
    METHOD(Variant, body_apply_torque);
    METHOD(Variant, body_add_constant_central_force);
    METHOD(Variant, body_add_constant_force);
    METHOD(Variant, body_add_constant_torque);
    METHOD(Variant, body_set_constant_force);
    METHOD(Vector2, body_get_constant_force);
    METHOD(Variant, body_set_constant_torque);
    METHOD(double, body_get_constant_torque);
    METHOD(Variant, body_set_axis_velocity);
    METHOD(Variant, body_add_collision_exception);
    METHOD(Variant, body_remove_collision_exception);
    METHOD(Variant, body_set_max_contacts_reported);
    METHOD(int64_t, body_get_max_contacts_reported);
    METHOD(Variant, body_set_omit_force_integration);
    METHOD(bool, body_is_omitting_force_integration);
    METHOD(Variant, body_set_state_sync_callback);
    METHOD(Variant, body_set_force_integration_callback);
    METHOD(bool, body_test_motion);
    METHOD(Object, body_get_direct_state);
    METHOD(::RID, joint_create);
    METHOD(Variant, joint_clear);
    METHOD(Variant, joint_set_param);
    METHOD(double, joint_get_param);
    METHOD(Variant, joint_disable_collisions_between_bodies);
    METHOD(bool, joint_is_disabled_collisions_between_bodies);
    METHOD(Variant, joint_make_pin);
    METHOD(Variant, joint_make_groove);
    METHOD(Variant, joint_make_damped_spring);
    METHOD(Variant, pin_joint_set_flag);
    METHOD(bool, pin_joint_get_flag);
    METHOD(Variant, pin_joint_set_param);
    METHOD(double, pin_joint_get_param);
    METHOD(Variant, damped_spring_joint_set_param);
    METHOD(double, damped_spring_joint_get_param);
    METHOD(int64_t, joint_get_type);
    METHOD(Variant, free_rid);
    METHOD(void, set_active);
    METHOD(int64_t, get_process_info);
    static constexpr int64_t SPACE_PARAM_CONTACT_RECYCLE_RADIUS = 0;
    static constexpr int64_t SPACE_PARAM_CONTACT_MAX_SEPARATION = 1;
    static constexpr int64_t SPACE_PARAM_CONTACT_MAX_ALLOWED_PENETRATION = 2;
    static constexpr int64_t SPACE_PARAM_CONTACT_DEFAULT_BIAS = 3;
    static constexpr int64_t SPACE_PARAM_BODY_LINEAR_VELOCITY_SLEEP_THRESHOLD = 4;
    static constexpr int64_t SPACE_PARAM_BODY_ANGULAR_VELOCITY_SLEEP_THRESHOLD = 5;
    static constexpr int64_t SPACE_PARAM_BODY_TIME_TO_SLEEP = 6;
    static constexpr int64_t SPACE_PARAM_CONSTRAINT_DEFAULT_BIAS = 7;
    static constexpr int64_t SPACE_PARAM_SOLVER_ITERATIONS = 8;
    static constexpr int64_t SHAPE_WORLD_BOUNDARY = 0;
    static constexpr int64_t SHAPE_SEPARATION_RAY = 1;
    static constexpr int64_t SHAPE_SEGMENT = 2;
    static constexpr int64_t SHAPE_CIRCLE = 3;
    static constexpr int64_t SHAPE_RECTANGLE = 4;
    static constexpr int64_t SHAPE_CAPSULE = 5;
    static constexpr int64_t SHAPE_CONVEX_POLYGON = 6;
    static constexpr int64_t SHAPE_CONCAVE_POLYGON = 7;
    static constexpr int64_t SHAPE_CUSTOM = 8;
    static constexpr int64_t AREA_PARAM_GRAVITY_OVERRIDE_MODE = 0;
    static constexpr int64_t AREA_PARAM_GRAVITY = 1;
    static constexpr int64_t AREA_PARAM_GRAVITY_VECTOR = 2;
    static constexpr int64_t AREA_PARAM_GRAVITY_IS_POINT = 3;
    static constexpr int64_t AREA_PARAM_GRAVITY_POINT_UNIT_DISTANCE = 4;
    static constexpr int64_t AREA_PARAM_LINEAR_DAMP_OVERRIDE_MODE = 5;
    static constexpr int64_t AREA_PARAM_LINEAR_DAMP = 6;
    static constexpr int64_t AREA_PARAM_ANGULAR_DAMP_OVERRIDE_MODE = 7;
    static constexpr int64_t AREA_PARAM_ANGULAR_DAMP = 8;
    static constexpr int64_t AREA_PARAM_PRIORITY = 9;
    static constexpr int64_t AREA_SPACE_OVERRIDE_DISABLED = 0;
    static constexpr int64_t AREA_SPACE_OVERRIDE_COMBINE = 1;
    static constexpr int64_t AREA_SPACE_OVERRIDE_COMBINE_REPLACE = 2;
    static constexpr int64_t AREA_SPACE_OVERRIDE_REPLACE = 3;
    static constexpr int64_t AREA_SPACE_OVERRIDE_REPLACE_COMBINE = 4;
    static constexpr int64_t BODY_MODE_STATIC = 0;
    static constexpr int64_t BODY_MODE_KINEMATIC = 1;
    static constexpr int64_t BODY_MODE_RIGID = 2;
    static constexpr int64_t BODY_MODE_RIGID_LINEAR = 3;
    static constexpr int64_t BODY_PARAM_BOUNCE = 0;
    static constexpr int64_t BODY_PARAM_FRICTION = 1;
    static constexpr int64_t BODY_PARAM_MASS = 2;
    static constexpr int64_t BODY_PARAM_INERTIA = 3;
    static constexpr int64_t BODY_PARAM_CENTER_OF_MASS = 4;
    static constexpr int64_t BODY_PARAM_GRAVITY_SCALE = 5;
    static constexpr int64_t BODY_PARAM_LINEAR_DAMP_MODE = 6;
    static constexpr int64_t BODY_PARAM_ANGULAR_DAMP_MODE = 7;
    static constexpr int64_t BODY_PARAM_LINEAR_DAMP = 8;
    static constexpr int64_t BODY_PARAM_ANGULAR_DAMP = 9;
    static constexpr int64_t BODY_PARAM_MAX = 10;
    static constexpr int64_t BODY_DAMP_MODE_COMBINE = 0;
    static constexpr int64_t BODY_DAMP_MODE_REPLACE = 1;
    static constexpr int64_t BODY_STATE_TRANSFORM = 0;
    static constexpr int64_t BODY_STATE_LINEAR_VELOCITY = 1;
    static constexpr int64_t BODY_STATE_ANGULAR_VELOCITY = 2;
    static constexpr int64_t BODY_STATE_SLEEPING = 3;
    static constexpr int64_t BODY_STATE_CAN_SLEEP = 4;
    static constexpr int64_t JOINT_TYPE_PIN = 0;
    static constexpr int64_t JOINT_TYPE_GROOVE = 1;
    static constexpr int64_t JOINT_TYPE_DAMPED_SPRING = 2;
    static constexpr int64_t JOINT_TYPE_MAX = 3;
    static constexpr int64_t JOINT_PARAM_BIAS = 0;
    static constexpr int64_t JOINT_PARAM_MAX_BIAS = 1;
    static constexpr int64_t JOINT_PARAM_MAX_FORCE = 2;
    static constexpr int64_t PIN_JOINT_SOFTNESS = 0;
    static constexpr int64_t PIN_JOINT_LIMIT_UPPER = 1;
    static constexpr int64_t PIN_JOINT_LIMIT_LOWER = 2;
    static constexpr int64_t PIN_JOINT_MOTOR_TARGET_VELOCITY = 3;
    static constexpr int64_t PIN_JOINT_FLAG_ANGULAR_LIMIT_ENABLED = 0;
    static constexpr int64_t PIN_JOINT_FLAG_MOTOR_ENABLED = 1;
    static constexpr int64_t DAMPED_SPRING_REST_LENGTH = 0;
    static constexpr int64_t DAMPED_SPRING_STIFFNESS = 1;
    static constexpr int64_t DAMPED_SPRING_DAMPING = 2;
    static constexpr int64_t CCD_MODE_DISABLED = 0;
    static constexpr int64_t CCD_MODE_CAST_RAY = 1;
    static constexpr int64_t CCD_MODE_CAST_SHAPE = 2;
    static constexpr int64_t AREA_BODY_ADDED = 0;
    static constexpr int64_t AREA_BODY_REMOVED = 1;
    static constexpr int64_t INFO_ACTIVE_OBJECTS = 0;
    static constexpr int64_t INFO_COLLISION_PAIRS = 1;
    static constexpr int64_t INFO_ISLAND_COUNT = 2;
    static PhysicsServer2D get_singleton() { return PhysicsServer2D(Object("PhysicsServer2D").address()); }
};
struct PhysicsServer2DExtension : public PhysicsServer2D {
    using PhysicsServer2D::PhysicsServer2D;
    METHOD(::RID, _world_boundary_shape_create);
    METHOD(::RID, _separation_ray_shape_create);
    METHOD(::RID, _segment_shape_create);
    METHOD(::RID, _circle_shape_create);
    METHOD(::RID, _rectangle_shape_create);
    METHOD(::RID, _capsule_shape_create);
    METHOD(::RID, _convex_polygon_shape_create);
    METHOD(::RID, _concave_polygon_shape_create);
    METHOD(Variant, _shape_set_data);
    METHOD(Variant, _shape_set_custom_solver_bias);
    METHOD(int64_t, _shape_get_type);
    METHOD(Variant, _shape_get_data);
    METHOD(double, _shape_get_custom_solver_bias);
    METHOD(bool, _shape_collide);
    METHOD(::RID, _space_create);
    METHOD(Variant, _space_set_active);
    METHOD(bool, _space_is_active);
    METHOD(Variant, _space_set_param);
    METHOD(double, _space_get_param);
    METHOD(Object, _space_get_direct_state);
    METHOD(Variant, _space_set_debug_contacts);
    METHOD(PackedArray<Vector2>, _space_get_contacts);
    METHOD(int64_t, _space_get_contact_count);
    METHOD(::RID, _area_create);
    METHOD(Variant, _area_set_space);
    METHOD(::RID, _area_get_space);
    METHOD(Variant, _area_add_shape);
    METHOD(Variant, _area_set_shape);
    METHOD(Variant, _area_set_shape_transform);
    METHOD(Variant, _area_set_shape_disabled);
    METHOD(int64_t, _area_get_shape_count);
    METHOD(::RID, _area_get_shape);
    METHOD(Transform2D, _area_get_shape_transform);
    METHOD(Variant, _area_remove_shape);
    METHOD(Variant, _area_clear_shapes);
    METHOD(Variant, _area_attach_object_instance_id);
    METHOD(int64_t, _area_get_object_instance_id);
    METHOD(Variant, _area_attach_canvas_instance_id);
    METHOD(int64_t, _area_get_canvas_instance_id);
    METHOD(Variant, _area_set_param);
    METHOD(Variant, _area_set_transform);
    METHOD(Variant, _area_get_param);
    METHOD(Transform2D, _area_get_transform);
    METHOD(Variant, _area_set_collision_layer);
    METHOD(int64_t, _area_get_collision_layer);
    METHOD(Variant, _area_set_collision_mask);
    METHOD(int64_t, _area_get_collision_mask);
    METHOD(Variant, _area_set_monitorable);
    METHOD(Variant, _area_set_pickable);
    METHOD(Variant, _area_set_monitor_callback);
    METHOD(Variant, _area_set_area_monitor_callback);
    METHOD(::RID, _body_create);
    METHOD(Variant, _body_set_space);
    METHOD(::RID, _body_get_space);
    METHOD(Variant, _body_set_mode);
    METHOD(int64_t, _body_get_mode);
    METHOD(Variant, _body_add_shape);
    METHOD(Variant, _body_set_shape);
    METHOD(Variant, _body_set_shape_transform);
    METHOD(int64_t, _body_get_shape_count);
    METHOD(::RID, _body_get_shape);
    METHOD(Transform2D, _body_get_shape_transform);
    METHOD(Variant, _body_set_shape_disabled);
    METHOD(Variant, _body_set_shape_as_one_way_collision);
    METHOD(Variant, _body_remove_shape);
    METHOD(Variant, _body_clear_shapes);
    METHOD(Variant, _body_attach_object_instance_id);
    METHOD(int64_t, _body_get_object_instance_id);
    METHOD(Variant, _body_attach_canvas_instance_id);
    METHOD(int64_t, _body_get_canvas_instance_id);
    METHOD(Variant, _body_set_continuous_collision_detection_mode);
    METHOD(int64_t, _body_get_continuous_collision_detection_mode);
    METHOD(Variant, _body_set_collision_layer);
    METHOD(int64_t, _body_get_collision_layer);
    METHOD(Variant, _body_set_collision_mask);
    METHOD(int64_t, _body_get_collision_mask);
    METHOD(Variant, _body_set_collision_priority);
    METHOD(double, _body_get_collision_priority);
    METHOD(Variant, _body_set_param);
    METHOD(Variant, _body_get_param);
    METHOD(Variant, _body_reset_mass_properties);
    METHOD(Variant, _body_set_state);
    METHOD(Variant, _body_get_state);
    METHOD(Variant, _body_apply_central_impulse);
    METHOD(Variant, _body_apply_torque_impulse);
    METHOD(Variant, _body_apply_impulse);
    METHOD(Variant, _body_apply_central_force);
    METHOD(Variant, _body_apply_force);
    METHOD(Variant, _body_apply_torque);
    METHOD(Variant, _body_add_constant_central_force);
    METHOD(Variant, _body_add_constant_force);
    METHOD(Variant, _body_add_constant_torque);
    METHOD(Variant, _body_set_constant_force);
    METHOD(Vector2, _body_get_constant_force);
    METHOD(Variant, _body_set_constant_torque);
    METHOD(double, _body_get_constant_torque);
    METHOD(Variant, _body_set_axis_velocity);
    METHOD(Variant, _body_add_collision_exception);
    METHOD(Variant, _body_remove_collision_exception);
    METHOD(Array, _body_get_collision_exceptions);
    METHOD(Variant, _body_set_max_contacts_reported);
    METHOD(int64_t, _body_get_max_contacts_reported);
    METHOD(Variant, _body_set_contacts_reported_depth_threshold);
    METHOD(double, _body_get_contacts_reported_depth_threshold);
    METHOD(Variant, _body_set_omit_force_integration);
    METHOD(bool, _body_is_omitting_force_integration);
    METHOD(Variant, _body_set_state_sync_callback);
    METHOD(Variant, _body_set_force_integration_callback);
    METHOD(bool, _body_collide_shape);
    METHOD(Variant, _body_set_pickable);
    METHOD(Object, _body_get_direct_state);
    METHOD(bool, _body_test_motion);
    METHOD(::RID, _joint_create);
    METHOD(Variant, _joint_clear);
    METHOD(Variant, _joint_set_param);
    METHOD(double, _joint_get_param);
    METHOD(Variant, _joint_disable_collisions_between_bodies);
    METHOD(bool, _joint_is_disabled_collisions_between_bodies);
    METHOD(Variant, _joint_make_pin);
    METHOD(Variant, _joint_make_groove);
    METHOD(Variant, _joint_make_damped_spring);
    METHOD(Variant, _pin_joint_set_flag);
    METHOD(bool, _pin_joint_get_flag);
    METHOD(Variant, _pin_joint_set_param);
    METHOD(double, _pin_joint_get_param);
    METHOD(Variant, _damped_spring_joint_set_param);
    METHOD(double, _damped_spring_joint_get_param);
    METHOD(int64_t, _joint_get_type);
    METHOD(Variant, _free_rid);
    METHOD(Variant, _set_active);
    METHOD(Variant, _init);
    METHOD(Variant, _step);
    METHOD(Variant, _sync);
    METHOD(Variant, _flush_queries);
    METHOD(Variant, _end_sync);
    METHOD(Variant, _finish);
    METHOD(bool, _is_flushing_queries);
    METHOD(int64_t, _get_process_info);
    METHOD(bool, body_test_motion_is_excluding_body);
    METHOD(bool, body_test_motion_is_excluding_object);
};
struct PhysicsServer2DManager : public Object {
    using Object::Object;
    METHOD(Variant, register_server);
    METHOD(void, set_default_server);
    static PhysicsServer2DManager get_singleton() { return PhysicsServer2DManager(Object("PhysicsServer2DManager").address()); }
};
struct PhysicsServer3D : public Object {
    using Object::Object;
    METHOD(::RID, world_boundary_shape_create);
    METHOD(::RID, separation_ray_shape_create);
    METHOD(::RID, sphere_shape_create);
    METHOD(::RID, box_shape_create);
    METHOD(::RID, capsule_shape_create);
    METHOD(::RID, cylinder_shape_create);
    METHOD(::RID, convex_polygon_shape_create);
    METHOD(::RID, concave_polygon_shape_create);
    METHOD(::RID, heightmap_shape_create);
    METHOD(::RID, custom_shape_create);
    METHOD(Variant, shape_set_data);
    METHOD(Variant, shape_set_margin);
    METHOD(int64_t, shape_get_type);
    METHOD(Variant, shape_get_data);
    METHOD(double, shape_get_margin);
    METHOD(::RID, space_create);
    METHOD(Variant, space_set_active);
    METHOD(bool, space_is_active);
    METHOD(Variant, space_set_param);
    METHOD(double, space_get_param);
    METHOD(Object, space_get_direct_state);
    METHOD(::RID, area_create);
    METHOD(Variant, area_set_space);
    METHOD(::RID, area_get_space);
    METHOD(Variant, area_add_shape);
    METHOD(Variant, area_set_shape);
    METHOD(Variant, area_set_shape_transform);
    METHOD(Variant, area_set_shape_disabled);
    METHOD(int64_t, area_get_shape_count);
    METHOD(::RID, area_get_shape);
    METHOD(Transform3D, area_get_shape_transform);
    METHOD(Variant, area_remove_shape);
    METHOD(Variant, area_clear_shapes);
    METHOD(Variant, area_set_collision_layer);
    METHOD(int64_t, area_get_collision_layer);
    METHOD(Variant, area_set_collision_mask);
    METHOD(int64_t, area_get_collision_mask);
    METHOD(Variant, area_set_param);
    METHOD(Variant, area_set_transform);
    METHOD(Variant, area_get_param);
    METHOD(Transform3D, area_get_transform);
    METHOD(Variant, area_attach_object_instance_id);
    METHOD(int64_t, area_get_object_instance_id);
    METHOD(Variant, area_set_monitor_callback);
    METHOD(Variant, area_set_area_monitor_callback);
    METHOD(Variant, area_set_monitorable);
    METHOD(Variant, area_set_ray_pickable);
    METHOD(::RID, body_create);
    METHOD(Variant, body_set_space);
    METHOD(::RID, body_get_space);
    METHOD(Variant, body_set_mode);
    METHOD(int64_t, body_get_mode);
    METHOD(Variant, body_set_collision_layer);
    METHOD(int64_t, body_get_collision_layer);
    METHOD(Variant, body_set_collision_mask);
    METHOD(int64_t, body_get_collision_mask);
    METHOD(Variant, body_set_collision_priority);
    METHOD(double, body_get_collision_priority);
    METHOD(Variant, body_add_shape);
    METHOD(Variant, body_set_shape);
    METHOD(Variant, body_set_shape_transform);
    METHOD(Variant, body_set_shape_disabled);
    METHOD(int64_t, body_get_shape_count);
    METHOD(::RID, body_get_shape);
    METHOD(Transform3D, body_get_shape_transform);
    METHOD(Variant, body_remove_shape);
    METHOD(Variant, body_clear_shapes);
    METHOD(Variant, body_attach_object_instance_id);
    METHOD(int64_t, body_get_object_instance_id);
    METHOD(Variant, body_set_enable_continuous_collision_detection);
    METHOD(bool, body_is_continuous_collision_detection_enabled);
    METHOD(Variant, body_set_param);
    METHOD(Variant, body_get_param);
    METHOD(Variant, body_reset_mass_properties);
    METHOD(Variant, body_set_state);
    METHOD(Variant, body_get_state);
    METHOD(Variant, body_apply_central_impulse);
    METHOD(Variant, body_apply_impulse);
    METHOD(Variant, body_apply_torque_impulse);
    METHOD(Variant, body_apply_central_force);
    METHOD(Variant, body_apply_force);
    METHOD(Variant, body_apply_torque);
    METHOD(Variant, body_add_constant_central_force);
    METHOD(Variant, body_add_constant_force);
    METHOD(Variant, body_add_constant_torque);
    METHOD(Variant, body_set_constant_force);
    METHOD(Vector3, body_get_constant_force);
    METHOD(Variant, body_set_constant_torque);
    METHOD(Vector3, body_get_constant_torque);
    METHOD(Variant, body_set_axis_velocity);
    METHOD(Variant, body_set_axis_lock);
    METHOD(bool, body_is_axis_locked);
    METHOD(Variant, body_add_collision_exception);
    METHOD(Variant, body_remove_collision_exception);
    METHOD(Variant, body_set_max_contacts_reported);
    METHOD(int64_t, body_get_max_contacts_reported);
    METHOD(Variant, body_set_omit_force_integration);
    METHOD(bool, body_is_omitting_force_integration);
    METHOD(Variant, body_set_state_sync_callback);
    METHOD(Variant, body_set_force_integration_callback);
    METHOD(Variant, body_set_ray_pickable);
    METHOD(bool, body_test_motion);
    METHOD(Object, body_get_direct_state);
    METHOD(::RID, soft_body_create);
    METHOD(Variant, soft_body_update_rendering_server);
    METHOD(Variant, soft_body_set_space);
    METHOD(::RID, soft_body_get_space);
    METHOD(Variant, soft_body_set_mesh);
    METHOD(Variant, soft_body_get_bounds);
    METHOD(Variant, soft_body_set_collision_layer);
    METHOD(int64_t, soft_body_get_collision_layer);
    METHOD(Variant, soft_body_set_collision_mask);
    METHOD(int64_t, soft_body_get_collision_mask);
    METHOD(Variant, soft_body_add_collision_exception);
    METHOD(Variant, soft_body_remove_collision_exception);
    METHOD(Variant, soft_body_set_state);
    METHOD(Variant, soft_body_get_state);
    METHOD(Variant, soft_body_set_transform);
    METHOD(Variant, soft_body_set_ray_pickable);
    METHOD(Variant, soft_body_set_simulation_precision);
    METHOD(int64_t, soft_body_get_simulation_precision);
    METHOD(Variant, soft_body_set_total_mass);
    METHOD(double, soft_body_get_total_mass);
    METHOD(Variant, soft_body_set_linear_stiffness);
    METHOD(double, soft_body_get_linear_stiffness);
    METHOD(Variant, soft_body_set_pressure_coefficient);
    METHOD(double, soft_body_get_pressure_coefficient);
    METHOD(Variant, soft_body_set_damping_coefficient);
    METHOD(double, soft_body_get_damping_coefficient);
    METHOD(Variant, soft_body_set_drag_coefficient);
    METHOD(double, soft_body_get_drag_coefficient);
    METHOD(Variant, soft_body_move_point);
    METHOD(Vector3, soft_body_get_point_global_position);
    METHOD(Variant, soft_body_remove_all_pinned_points);
    METHOD(Variant, soft_body_pin_point);
    METHOD(bool, soft_body_is_point_pinned);
    METHOD(::RID, joint_create);
    METHOD(Variant, joint_clear);
    METHOD(Variant, joint_make_pin);
    METHOD(Variant, pin_joint_set_param);
    METHOD(double, pin_joint_get_param);
    METHOD(Variant, pin_joint_set_local_a);
    METHOD(Vector3, pin_joint_get_local_a);
    METHOD(Variant, pin_joint_set_local_b);
    METHOD(Vector3, pin_joint_get_local_b);
    METHOD(Variant, joint_make_hinge);
    METHOD(Variant, hinge_joint_set_param);
    METHOD(double, hinge_joint_get_param);
    METHOD(Variant, hinge_joint_set_flag);
    METHOD(bool, hinge_joint_get_flag);
    METHOD(Variant, joint_make_slider);
    METHOD(Variant, slider_joint_set_param);
    METHOD(double, slider_joint_get_param);
    METHOD(Variant, joint_make_cone_twist);
    METHOD(Variant, cone_twist_joint_set_param);
    METHOD(double, cone_twist_joint_get_param);
    METHOD(int64_t, joint_get_type);
    METHOD(Variant, joint_set_solver_priority);
    METHOD(int64_t, joint_get_solver_priority);
    METHOD(Variant, joint_disable_collisions_between_bodies);
    METHOD(bool, joint_is_disabled_collisions_between_bodies);
    METHOD(Variant, joint_make_generic_6dof);
    METHOD(Variant, generic_6dof_joint_set_param);
    METHOD(double, generic_6dof_joint_get_param);
    METHOD(Variant, generic_6dof_joint_set_flag);
    METHOD(bool, generic_6dof_joint_get_flag);
    METHOD(Variant, free_rid);
    METHOD(void, set_active);
    METHOD(int64_t, get_process_info);
    static constexpr int64_t JOINT_TYPE_PIN = 0;
    static constexpr int64_t JOINT_TYPE_HINGE = 1;
    static constexpr int64_t JOINT_TYPE_SLIDER = 2;
    static constexpr int64_t JOINT_TYPE_CONE_TWIST = 3;
    static constexpr int64_t JOINT_TYPE_6DOF = 4;
    static constexpr int64_t JOINT_TYPE_MAX = 5;
    static constexpr int64_t PIN_JOINT_BIAS = 0;
    static constexpr int64_t PIN_JOINT_DAMPING = 1;
    static constexpr int64_t PIN_JOINT_IMPULSE_CLAMP = 2;
    static constexpr int64_t HINGE_JOINT_BIAS = 0;
    static constexpr int64_t HINGE_JOINT_LIMIT_UPPER = 1;
    static constexpr int64_t HINGE_JOINT_LIMIT_LOWER = 2;
    static constexpr int64_t HINGE_JOINT_LIMIT_BIAS = 3;
    static constexpr int64_t HINGE_JOINT_LIMIT_SOFTNESS = 4;
    static constexpr int64_t HINGE_JOINT_LIMIT_RELAXATION = 5;
    static constexpr int64_t HINGE_JOINT_MOTOR_TARGET_VELOCITY = 6;
    static constexpr int64_t HINGE_JOINT_MOTOR_MAX_IMPULSE = 7;
    static constexpr int64_t HINGE_JOINT_FLAG_USE_LIMIT = 0;
    static constexpr int64_t HINGE_JOINT_FLAG_ENABLE_MOTOR = 1;
    static constexpr int64_t SLIDER_JOINT_LINEAR_LIMIT_UPPER = 0;
    static constexpr int64_t SLIDER_JOINT_LINEAR_LIMIT_LOWER = 1;
    static constexpr int64_t SLIDER_JOINT_LINEAR_LIMIT_SOFTNESS = 2;
    static constexpr int64_t SLIDER_JOINT_LINEAR_LIMIT_RESTITUTION = 3;
    static constexpr int64_t SLIDER_JOINT_LINEAR_LIMIT_DAMPING = 4;
    static constexpr int64_t SLIDER_JOINT_LINEAR_MOTION_SOFTNESS = 5;
    static constexpr int64_t SLIDER_JOINT_LINEAR_MOTION_RESTITUTION = 6;
    static constexpr int64_t SLIDER_JOINT_LINEAR_MOTION_DAMPING = 7;
    static constexpr int64_t SLIDER_JOINT_LINEAR_ORTHOGONAL_SOFTNESS = 8;
    static constexpr int64_t SLIDER_JOINT_LINEAR_ORTHOGONAL_RESTITUTION = 9;
    static constexpr int64_t SLIDER_JOINT_LINEAR_ORTHOGONAL_DAMPING = 10;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_LIMIT_UPPER = 11;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_LIMIT_LOWER = 12;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_LIMIT_SOFTNESS = 13;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_LIMIT_RESTITUTION = 14;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_LIMIT_DAMPING = 15;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_MOTION_SOFTNESS = 16;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_MOTION_RESTITUTION = 17;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_MOTION_DAMPING = 18;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_ORTHOGONAL_SOFTNESS = 19;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_ORTHOGONAL_RESTITUTION = 20;
    static constexpr int64_t SLIDER_JOINT_ANGULAR_ORTHOGONAL_DAMPING = 21;
    static constexpr int64_t SLIDER_JOINT_MAX = 22;
    static constexpr int64_t CONE_TWIST_JOINT_SWING_SPAN = 0;
    static constexpr int64_t CONE_TWIST_JOINT_TWIST_SPAN = 1;
    static constexpr int64_t CONE_TWIST_JOINT_BIAS = 2;
    static constexpr int64_t CONE_TWIST_JOINT_SOFTNESS = 3;
    static constexpr int64_t CONE_TWIST_JOINT_RELAXATION = 4;
    static constexpr int64_t G6DOF_JOINT_LINEAR_LOWER_LIMIT = 0;
    static constexpr int64_t G6DOF_JOINT_LINEAR_UPPER_LIMIT = 1;
    static constexpr int64_t G6DOF_JOINT_LINEAR_LIMIT_SOFTNESS = 2;
    static constexpr int64_t G6DOF_JOINT_LINEAR_RESTITUTION = 3;
    static constexpr int64_t G6DOF_JOINT_LINEAR_DAMPING = 4;
    static constexpr int64_t G6DOF_JOINT_LINEAR_MOTOR_TARGET_VELOCITY = 5;
    static constexpr int64_t G6DOF_JOINT_LINEAR_MOTOR_FORCE_LIMIT = 6;
    static constexpr int64_t G6DOF_JOINT_LINEAR_SPRING_STIFFNESS = 7;
    static constexpr int64_t G6DOF_JOINT_LINEAR_SPRING_DAMPING = 8;
    static constexpr int64_t G6DOF_JOINT_LINEAR_SPRING_EQUILIBRIUM_POINT = 9;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_LOWER_LIMIT = 10;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_UPPER_LIMIT = 11;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_LIMIT_SOFTNESS = 12;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_DAMPING = 13;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_RESTITUTION = 14;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_FORCE_LIMIT = 15;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_ERP = 16;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_MOTOR_TARGET_VELOCITY = 17;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_MOTOR_FORCE_LIMIT = 18;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_SPRING_STIFFNESS = 19;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_SPRING_DAMPING = 20;
    static constexpr int64_t G6DOF_JOINT_ANGULAR_SPRING_EQUILIBRIUM_POINT = 21;
    static constexpr int64_t G6DOF_JOINT_MAX = 22;
    static constexpr int64_t G6DOF_JOINT_FLAG_ENABLE_LINEAR_LIMIT = 0;
    static constexpr int64_t G6DOF_JOINT_FLAG_ENABLE_ANGULAR_LIMIT = 1;
    static constexpr int64_t G6DOF_JOINT_FLAG_ENABLE_ANGULAR_SPRING = 2;
    static constexpr int64_t G6DOF_JOINT_FLAG_ENABLE_LINEAR_SPRING = 3;
    static constexpr int64_t G6DOF_JOINT_FLAG_ENABLE_MOTOR = 4;
    static constexpr int64_t G6DOF_JOINT_FLAG_ENABLE_LINEAR_MOTOR = 5;
    static constexpr int64_t G6DOF_JOINT_FLAG_MAX = 6;
    static constexpr int64_t SHAPE_WORLD_BOUNDARY = 0;
    static constexpr int64_t SHAPE_SEPARATION_RAY = 1;
    static constexpr int64_t SHAPE_SPHERE = 2;
    static constexpr int64_t SHAPE_BOX = 3;
    static constexpr int64_t SHAPE_CAPSULE = 4;
    static constexpr int64_t SHAPE_CYLINDER = 5;
    static constexpr int64_t SHAPE_CONVEX_POLYGON = 6;
    static constexpr int64_t SHAPE_CONCAVE_POLYGON = 7;
    static constexpr int64_t SHAPE_HEIGHTMAP = 8;
    static constexpr int64_t SHAPE_SOFT_BODY = 9;
    static constexpr int64_t SHAPE_CUSTOM = 10;
    static constexpr int64_t AREA_PARAM_GRAVITY_OVERRIDE_MODE = 0;
    static constexpr int64_t AREA_PARAM_GRAVITY = 1;
    static constexpr int64_t AREA_PARAM_GRAVITY_VECTOR = 2;
    static constexpr int64_t AREA_PARAM_GRAVITY_IS_POINT = 3;
    static constexpr int64_t AREA_PARAM_GRAVITY_POINT_UNIT_DISTANCE = 4;
    static constexpr int64_t AREA_PARAM_LINEAR_DAMP_OVERRIDE_MODE = 5;
    static constexpr int64_t AREA_PARAM_LINEAR_DAMP = 6;
    static constexpr int64_t AREA_PARAM_ANGULAR_DAMP_OVERRIDE_MODE = 7;
    static constexpr int64_t AREA_PARAM_ANGULAR_DAMP = 8;
    static constexpr int64_t AREA_PARAM_PRIORITY = 9;
    static constexpr int64_t AREA_PARAM_WIND_FORCE_MAGNITUDE = 10;
    static constexpr int64_t AREA_PARAM_WIND_SOURCE = 11;
    static constexpr int64_t AREA_PARAM_WIND_DIRECTION = 12;
    static constexpr int64_t AREA_PARAM_WIND_ATTENUATION_FACTOR = 13;
    static constexpr int64_t AREA_SPACE_OVERRIDE_DISABLED = 0;
    static constexpr int64_t AREA_SPACE_OVERRIDE_COMBINE = 1;
    static constexpr int64_t AREA_SPACE_OVERRIDE_COMBINE_REPLACE = 2;
    static constexpr int64_t AREA_SPACE_OVERRIDE_REPLACE = 3;
    static constexpr int64_t AREA_SPACE_OVERRIDE_REPLACE_COMBINE = 4;
    static constexpr int64_t BODY_MODE_STATIC = 0;
    static constexpr int64_t BODY_MODE_KINEMATIC = 1;
    static constexpr int64_t BODY_MODE_RIGID = 2;
    static constexpr int64_t BODY_MODE_RIGID_LINEAR = 3;
    static constexpr int64_t BODY_PARAM_BOUNCE = 0;
    static constexpr int64_t BODY_PARAM_FRICTION = 1;
    static constexpr int64_t BODY_PARAM_MASS = 2;
    static constexpr int64_t BODY_PARAM_INERTIA = 3;
    static constexpr int64_t BODY_PARAM_CENTER_OF_MASS = 4;
    static constexpr int64_t BODY_PARAM_GRAVITY_SCALE = 5;
    static constexpr int64_t BODY_PARAM_LINEAR_DAMP_MODE = 6;
    static constexpr int64_t BODY_PARAM_ANGULAR_DAMP_MODE = 7;
    static constexpr int64_t BODY_PARAM_LINEAR_DAMP = 8;
    static constexpr int64_t BODY_PARAM_ANGULAR_DAMP = 9;
    static constexpr int64_t BODY_PARAM_MAX = 10;
    static constexpr int64_t BODY_DAMP_MODE_COMBINE = 0;
    static constexpr int64_t BODY_DAMP_MODE_REPLACE = 1;
    static constexpr int64_t BODY_STATE_TRANSFORM = 0;
    static constexpr int64_t BODY_STATE_LINEAR_VELOCITY = 1;
    static constexpr int64_t BODY_STATE_ANGULAR_VELOCITY = 2;
    static constexpr int64_t BODY_STATE_SLEEPING = 3;
    static constexpr int64_t BODY_STATE_CAN_SLEEP = 4;
    static constexpr int64_t AREA_BODY_ADDED = 0;
    static constexpr int64_t AREA_BODY_REMOVED = 1;
    static constexpr int64_t INFO_ACTIVE_OBJECTS = 0;
    static constexpr int64_t INFO_COLLISION_PAIRS = 1;
    static constexpr int64_t INFO_ISLAND_COUNT = 2;
    static constexpr int64_t SPACE_PARAM_CONTACT_RECYCLE_RADIUS = 0;
    static constexpr int64_t SPACE_PARAM_CONTACT_MAX_SEPARATION = 1;
    static constexpr int64_t SPACE_PARAM_CONTACT_MAX_ALLOWED_PENETRATION = 2;
    static constexpr int64_t SPACE_PARAM_CONTACT_DEFAULT_BIAS = 3;
    static constexpr int64_t SPACE_PARAM_BODY_LINEAR_VELOCITY_SLEEP_THRESHOLD = 4;
    static constexpr int64_t SPACE_PARAM_BODY_ANGULAR_VELOCITY_SLEEP_THRESHOLD = 5;
    static constexpr int64_t SPACE_PARAM_BODY_TIME_TO_SLEEP = 6;
    static constexpr int64_t SPACE_PARAM_SOLVER_ITERATIONS = 7;
    static constexpr int64_t BODY_AXIS_LINEAR_X = 1;
    static constexpr int64_t BODY_AXIS_LINEAR_Y = 2;
    static constexpr int64_t BODY_AXIS_LINEAR_Z = 4;
    static constexpr int64_t BODY_AXIS_ANGULAR_X = 8;
    static constexpr int64_t BODY_AXIS_ANGULAR_Y = 16;
    static constexpr int64_t BODY_AXIS_ANGULAR_Z = 32;
    static PhysicsServer3D get_singleton() { return PhysicsServer3D(Object("PhysicsServer3D").address()); }
};
struct PhysicsServer3DExtension : public PhysicsServer3D {
    using PhysicsServer3D::PhysicsServer3D;
    METHOD(::RID, _world_boundary_shape_create);
    METHOD(::RID, _separation_ray_shape_create);
    METHOD(::RID, _sphere_shape_create);
    METHOD(::RID, _box_shape_create);
    METHOD(::RID, _capsule_shape_create);
    METHOD(::RID, _cylinder_shape_create);
    METHOD(::RID, _convex_polygon_shape_create);
    METHOD(::RID, _concave_polygon_shape_create);
    METHOD(::RID, _heightmap_shape_create);
    METHOD(::RID, _custom_shape_create);
    METHOD(Variant, _shape_set_data);
    METHOD(Variant, _shape_set_custom_solver_bias);
    METHOD(Variant, _shape_set_margin);
    METHOD(double, _shape_get_margin);
    METHOD(int64_t, _shape_get_type);
    METHOD(Variant, _shape_get_data);
    METHOD(double, _shape_get_custom_solver_bias);
    METHOD(::RID, _space_create);
    METHOD(Variant, _space_set_active);
    METHOD(bool, _space_is_active);
    METHOD(Variant, _space_set_param);
    METHOD(double, _space_get_param);
    METHOD(Object, _space_get_direct_state);
    METHOD(Variant, _space_set_debug_contacts);
    METHOD(PackedArray<Vector3>, _space_get_contacts);
    METHOD(int64_t, _space_get_contact_count);
    METHOD(::RID, _area_create);
    METHOD(Variant, _area_set_space);
    METHOD(::RID, _area_get_space);
    METHOD(Variant, _area_add_shape);
    METHOD(Variant, _area_set_shape);
    METHOD(Variant, _area_set_shape_transform);
    METHOD(Variant, _area_set_shape_disabled);
    METHOD(int64_t, _area_get_shape_count);
    METHOD(::RID, _area_get_shape);
    METHOD(Transform3D, _area_get_shape_transform);
    METHOD(Variant, _area_remove_shape);
    METHOD(Variant, _area_clear_shapes);
    METHOD(Variant, _area_attach_object_instance_id);
    METHOD(int64_t, _area_get_object_instance_id);
    METHOD(Variant, _area_set_param);
    METHOD(Variant, _area_set_transform);
    METHOD(Variant, _area_get_param);
    METHOD(Transform3D, _area_get_transform);
    METHOD(Variant, _area_set_collision_layer);
    METHOD(int64_t, _area_get_collision_layer);
    METHOD(Variant, _area_set_collision_mask);
    METHOD(int64_t, _area_get_collision_mask);
    METHOD(Variant, _area_set_monitorable);
    METHOD(Variant, _area_set_ray_pickable);
    METHOD(Variant, _area_set_monitor_callback);
    METHOD(Variant, _area_set_area_monitor_callback);
    METHOD(::RID, _body_create);
    METHOD(Variant, _body_set_space);
    METHOD(::RID, _body_get_space);
    METHOD(Variant, _body_set_mode);
    METHOD(int64_t, _body_get_mode);
    METHOD(Variant, _body_add_shape);
    METHOD(Variant, _body_set_shape);
    METHOD(Variant, _body_set_shape_transform);
    METHOD(Variant, _body_set_shape_disabled);
    METHOD(int64_t, _body_get_shape_count);
    METHOD(::RID, _body_get_shape);
    METHOD(Transform3D, _body_get_shape_transform);
    METHOD(Variant, _body_remove_shape);
    METHOD(Variant, _body_clear_shapes);
    METHOD(Variant, _body_attach_object_instance_id);
    METHOD(int64_t, _body_get_object_instance_id);
    METHOD(Variant, _body_set_enable_continuous_collision_detection);
    METHOD(bool, _body_is_continuous_collision_detection_enabled);
    METHOD(Variant, _body_set_collision_layer);
    METHOD(int64_t, _body_get_collision_layer);
    METHOD(Variant, _body_set_collision_mask);
    METHOD(int64_t, _body_get_collision_mask);
    METHOD(Variant, _body_set_collision_priority);
    METHOD(double, _body_get_collision_priority);
    METHOD(Variant, _body_set_user_flags);
    METHOD(int64_t, _body_get_user_flags);
    METHOD(Variant, _body_set_param);
    METHOD(Variant, _body_get_param);
    METHOD(Variant, _body_reset_mass_properties);
    METHOD(Variant, _body_set_state);
    METHOD(Variant, _body_get_state);
    METHOD(Variant, _body_apply_central_impulse);
    METHOD(Variant, _body_apply_impulse);
    METHOD(Variant, _body_apply_torque_impulse);
    METHOD(Variant, _body_apply_central_force);
    METHOD(Variant, _body_apply_force);
    METHOD(Variant, _body_apply_torque);
    METHOD(Variant, _body_add_constant_central_force);
    METHOD(Variant, _body_add_constant_force);
    METHOD(Variant, _body_add_constant_torque);
    METHOD(Variant, _body_set_constant_force);
    METHOD(Vector3, _body_get_constant_force);
    METHOD(Variant, _body_set_constant_torque);
    METHOD(Vector3, _body_get_constant_torque);
    METHOD(Variant, _body_set_axis_velocity);
    METHOD(Variant, _body_set_axis_lock);
    METHOD(bool, _body_is_axis_locked);
    METHOD(Variant, _body_add_collision_exception);
    METHOD(Variant, _body_remove_collision_exception);
    METHOD(Array, _body_get_collision_exceptions);
    METHOD(Variant, _body_set_max_contacts_reported);
    METHOD(int64_t, _body_get_max_contacts_reported);
    METHOD(Variant, _body_set_contacts_reported_depth_threshold);
    METHOD(double, _body_get_contacts_reported_depth_threshold);
    METHOD(Variant, _body_set_omit_force_integration);
    METHOD(bool, _body_is_omitting_force_integration);
    METHOD(Variant, _body_set_state_sync_callback);
    METHOD(Variant, _body_set_force_integration_callback);
    METHOD(Variant, _body_set_ray_pickable);
    METHOD(bool, _body_test_motion);
    METHOD(Object, _body_get_direct_state);
    METHOD(::RID, _soft_body_create);
    METHOD(Variant, _soft_body_update_rendering_server);
    METHOD(Variant, _soft_body_set_space);
    METHOD(::RID, _soft_body_get_space);
    METHOD(Variant, _soft_body_set_ray_pickable);
    METHOD(Variant, _soft_body_set_collision_layer);
    METHOD(int64_t, _soft_body_get_collision_layer);
    METHOD(Variant, _soft_body_set_collision_mask);
    METHOD(int64_t, _soft_body_get_collision_mask);
    METHOD(Variant, _soft_body_add_collision_exception);
    METHOD(Variant, _soft_body_remove_collision_exception);
    METHOD(Array, _soft_body_get_collision_exceptions);
    METHOD(Variant, _soft_body_set_state);
    METHOD(Variant, _soft_body_get_state);
    METHOD(Variant, _soft_body_set_transform);
    METHOD(Variant, _soft_body_set_simulation_precision);
    METHOD(int64_t, _soft_body_get_simulation_precision);
    METHOD(Variant, _soft_body_set_total_mass);
    METHOD(double, _soft_body_get_total_mass);
    METHOD(Variant, _soft_body_set_linear_stiffness);
    METHOD(double, _soft_body_get_linear_stiffness);
    METHOD(Variant, _soft_body_set_pressure_coefficient);
    METHOD(double, _soft_body_get_pressure_coefficient);
    METHOD(Variant, _soft_body_set_damping_coefficient);
    METHOD(double, _soft_body_get_damping_coefficient);
    METHOD(Variant, _soft_body_set_drag_coefficient);
    METHOD(double, _soft_body_get_drag_coefficient);
    METHOD(Variant, _soft_body_set_mesh);
    METHOD(Variant, _soft_body_get_bounds);
    METHOD(Variant, _soft_body_move_point);
    METHOD(Vector3, _soft_body_get_point_global_position);
    METHOD(Variant, _soft_body_remove_all_pinned_points);
    METHOD(Variant, _soft_body_pin_point);
    METHOD(bool, _soft_body_is_point_pinned);
    METHOD(::RID, _joint_create);
    METHOD(Variant, _joint_clear);
    METHOD(Variant, _joint_make_pin);
    METHOD(Variant, _pin_joint_set_param);
    METHOD(double, _pin_joint_get_param);
    METHOD(Variant, _pin_joint_set_local_a);
    METHOD(Vector3, _pin_joint_get_local_a);
    METHOD(Variant, _pin_joint_set_local_b);
    METHOD(Vector3, _pin_joint_get_local_b);
    METHOD(Variant, _joint_make_hinge);
    METHOD(Variant, _joint_make_hinge_simple);
    METHOD(Variant, _hinge_joint_set_param);
    METHOD(double, _hinge_joint_get_param);
    METHOD(Variant, _hinge_joint_set_flag);
    METHOD(bool, _hinge_joint_get_flag);
    METHOD(Variant, _joint_make_slider);
    METHOD(Variant, _slider_joint_set_param);
    METHOD(double, _slider_joint_get_param);
    METHOD(Variant, _joint_make_cone_twist);
    METHOD(Variant, _cone_twist_joint_set_param);
    METHOD(double, _cone_twist_joint_get_param);
    METHOD(Variant, _joint_make_generic_6dof);
    METHOD(Variant, _generic_6dof_joint_set_param);
    METHOD(double, _generic_6dof_joint_get_param);
    METHOD(Variant, _generic_6dof_joint_set_flag);
    METHOD(bool, _generic_6dof_joint_get_flag);
    METHOD(int64_t, _joint_get_type);
    METHOD(Variant, _joint_set_solver_priority);
    METHOD(int64_t, _joint_get_solver_priority);
    METHOD(Variant, _joint_disable_collisions_between_bodies);
    METHOD(bool, _joint_is_disabled_collisions_between_bodies);
    METHOD(Variant, _free_rid);
    METHOD(Variant, _set_active);
    METHOD(Variant, _init);
    METHOD(Variant, _step);
    METHOD(Variant, _sync);
    METHOD(Variant, _flush_queries);
    METHOD(Variant, _end_sync);
    METHOD(Variant, _finish);
    METHOD(bool, _is_flushing_queries);
    METHOD(int64_t, _get_process_info);
    METHOD(bool, body_test_motion_is_excluding_body);
    METHOD(bool, body_test_motion_is_excluding_object);
};
struct PhysicsServer3DManager : public Object {
    using Object::Object;
    METHOD(Variant, register_server);
    METHOD(void, set_default_server);
    static PhysicsServer3DManager get_singleton() { return PhysicsServer3DManager(Object("PhysicsServer3DManager").address()); }
};
struct PhysicsServer3DRenderingServerHandler : public Object {
    using Object::Object;
    METHOD(Variant, _set_vertex);
    METHOD(Variant, _set_normal);
    METHOD(Variant, _set_aabb);
    METHOD(void, set_vertex);
    METHOD(void, set_normal);
    METHOD(void, set_aabb);
};
struct PinJoint2D : public Joint2D {
    using Joint2D::Joint2D;
    PROPERTY(softness, double);
    PROPERTY(angular_limit_enabled, bool);
    PROPERTY(angular_limit_lower, double);
    PROPERTY(angular_limit_upper, double);
    PROPERTY(motor_enabled, bool);
    PROPERTY(motor_target_velocity, double);
    METHOD(void, set_softness);
    METHOD(double, get_softness);
    METHOD(void, set_angular_limit_lower);
    METHOD(double, get_angular_limit_lower);
    METHOD(void, set_angular_limit_upper);
    METHOD(double, get_angular_limit_upper);
    METHOD(void, set_motor_target_velocity);
    METHOD(double, get_motor_target_velocity);
    METHOD(void, set_motor_enabled);
    METHOD(bool, is_motor_enabled);
    METHOD(void, set_angular_limit_enabled);
    METHOD(bool, is_angular_limit_enabled);
};
struct PinJoint3D : public Joint3D {
    using Joint3D::Joint3D;
    METHOD(void, set_param);
    METHOD(double, get_param);
    static constexpr int64_t PARAM_BIAS = 0;
    static constexpr int64_t PARAM_DAMPING = 1;
    static constexpr int64_t PARAM_IMPULSE_CLAMP = 2;
};
struct PointLight2D : public Light2D {
    using Light2D::Light2D;
    PROPERTY(texture, Object);
    PROPERTY(offset, Vector2);
    PROPERTY(texture_scale, double);
    PROPERTY(height, double);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_texture_offset);
    METHOD(Vector2, get_texture_offset);
    METHOD(void, set_texture_scale);
    METHOD(double, get_texture_scale);
};
struct Polygon2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(color, Color);
    PROPERTY(offset, Vector2);
    PROPERTY(antialiased, bool);
    PROPERTY(texture, Object);
    PROPERTY(texture_offset, Vector2);
    PROPERTY(texture_scale, Vector2);
    PROPERTY(texture_rotation, double);
    PROPERTY(skeleton, String);
    PROPERTY(invert_enabled, bool);
    PROPERTY(invert_border, double);
    PROPERTY(polygon, PackedArray<Vector2>);
    PROPERTY(uv, PackedArray<Vector2>);
    PROPERTY(vertex_colors, PackedArray<Color>);
    PROPERTY(polygons, Array);
    PROPERTY(bones, Array);
    PROPERTY(internal_vertex_count, int64_t);
    METHOD(void, set_polygon);
    METHOD(PackedArray<Vector2>, get_polygon);
    METHOD(void, set_uv);
    METHOD(PackedArray<Vector2>, get_uv);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_polygons);
    METHOD(Array, get_polygons);
    METHOD(void, set_vertex_colors);
    METHOD(PackedArray<Color>, get_vertex_colors);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_texture_offset);
    METHOD(Vector2, get_texture_offset);
    METHOD(void, set_texture_rotation);
    METHOD(double, get_texture_rotation);
    METHOD(void, set_texture_scale);
    METHOD(Vector2, get_texture_scale);
    METHOD(void, set_invert_enabled);
    METHOD(bool, get_invert_enabled);
    METHOD(void, set_antialiased);
    METHOD(bool, get_antialiased);
    METHOD(void, set_invert_border);
    METHOD(double, get_invert_border);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(Variant, add_bone);
    METHOD(int64_t, get_bone_count);
    METHOD(String, get_bone_path);
    METHOD(PackedArray<float>, get_bone_weights);
    METHOD(Variant, erase_bone);
    METHOD(Variant, clear_bones);
    METHOD(void, set_bone_path);
    METHOD(void, set_bone_weights);
    METHOD(void, set_skeleton);
    METHOD(String, get_skeleton);
    METHOD(void, set_internal_vertex_count);
    METHOD(int64_t, get_internal_vertex_count);
    METHOD(Variant, _set_bones);
    METHOD(Array, _get_bones);
};
struct ProjectSettings : public Object {
    using Object::Object;
    METHOD(bool, has_setting);
    METHOD(void, set_setting);
    METHOD(Variant, get_setting);
    METHOD(Variant, get_setting_with_override);
    METHOD(Array, get_global_class_list);
    METHOD(void, set_order);
    METHOD(int64_t, get_order);
    METHOD(void, set_initial_value);
    METHOD(void, set_as_basic);
    METHOD(void, set_as_internal);
    METHOD(Variant, add_property_info);
    METHOD(void, set_restart_if_changed);
    METHOD(Variant, clear);
    METHOD(String, localize_path);
    METHOD(String, globalize_path);
    METHOD(int64_t, save);
    METHOD(bool, load_resource_pack);
    METHOD(int64_t, save_custom);
    static ProjectSettings get_singleton() { return ProjectSettings(Object("ProjectSettings").address()); }
};
struct Range : public Control {
    using Control::Control;
    PROPERTY(min_value, double);
    PROPERTY(max_value, double);
    PROPERTY(step, double);
    PROPERTY(page, double);
    PROPERTY(value, double);
    PROPERTY(ratio, double);
    PROPERTY(exp_edit, bool);
    PROPERTY(rounded, bool);
    PROPERTY(allow_greater, bool);
    PROPERTY(allow_lesser, bool);
    METHOD(Variant, _value_changed);
    METHOD(double, get_value);
    METHOD(double, get_min);
    METHOD(double, get_max);
    METHOD(double, get_step);
    METHOD(double, get_page);
    METHOD(double, get_as_ratio);
    METHOD(void, set_value);
    METHOD(void, set_value_no_signal);
    METHOD(void, set_min);
    METHOD(void, set_max);
    METHOD(void, set_step);
    METHOD(void, set_page);
    METHOD(void, set_as_ratio);
    METHOD(void, set_use_rounded_values);
    METHOD(bool, is_using_rounded_values);
    METHOD(void, set_exp_ratio);
    METHOD(bool, is_ratio_exp);
    METHOD(void, set_allow_greater);
    METHOD(bool, is_greater_allowed);
    METHOD(void, set_allow_lesser);
    METHOD(bool, is_lesser_allowed);
    METHOD(Variant, share);
    METHOD(Variant, unshare);
};
struct RayCast2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(enabled, bool);
    PROPERTY(exclude_parent, bool);
    PROPERTY(target_position, Vector2);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(hit_from_inside, bool);
    PROPERTY(collide_with_areas, bool);
    PROPERTY(collide_with_bodies, bool);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_target_position);
    METHOD(Vector2, get_target_position);
    METHOD(bool, is_colliding);
    METHOD(Variant, force_raycast_update);
    METHOD(Object, get_collider);
    METHOD(::RID, get_collider_rid);
    METHOD(int64_t, get_collider_shape);
    METHOD(Vector2, get_collision_point);
    METHOD(Vector2, get_collision_normal);
    METHOD(Variant, add_exception_rid);
    METHOD(Variant, add_exception);
    METHOD(Variant, remove_exception_rid);
    METHOD(Variant, remove_exception);
    METHOD(Variant, clear_exceptions);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_exclude_parent_body);
    METHOD(bool, get_exclude_parent_body);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_hit_from_inside);
    METHOD(bool, is_hit_from_inside_enabled);
};
struct RayCast3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(enabled, bool);
    PROPERTY(exclude_parent, bool);
    PROPERTY(target_position, Vector3);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(hit_from_inside, bool);
    PROPERTY(hit_back_faces, bool);
    PROPERTY(collide_with_areas, bool);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(debug_shape_custom_color, Color);
    PROPERTY(debug_shape_thickness, int64_t);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_target_position);
    METHOD(Vector3, get_target_position);
    METHOD(bool, is_colliding);
    METHOD(Variant, force_raycast_update);
    METHOD(Object, get_collider);
    METHOD(::RID, get_collider_rid);
    METHOD(int64_t, get_collider_shape);
    METHOD(Vector3, get_collision_point);
    METHOD(Vector3, get_collision_normal);
    METHOD(int64_t, get_collision_face_index);
    METHOD(Variant, add_exception_rid);
    METHOD(Variant, add_exception);
    METHOD(Variant, remove_exception_rid);
    METHOD(Variant, remove_exception);
    METHOD(Variant, clear_exceptions);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_exclude_parent_body);
    METHOD(bool, get_exclude_parent_body);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_hit_from_inside);
    METHOD(bool, is_hit_from_inside_enabled);
    METHOD(void, set_hit_back_faces);
    METHOD(bool, is_hit_back_faces_enabled);
    METHOD(void, set_debug_shape_custom_color);
    METHOD(Color, get_debug_shape_custom_color);
    METHOD(void, set_debug_shape_thickness);
    METHOD(int64_t, get_debug_shape_thickness);
};
struct RefCounted : public Object {
    using Object::Object;
    METHOD(bool, init_ref);
    METHOD(bool, reference);
    METHOD(bool, unreference);
    METHOD(int64_t, get_reference_count);
};
struct ReferenceRect : public Control {
    using Control::Control;
    PROPERTY(border_color, Color);
    PROPERTY(border_width, double);
    PROPERTY(editor_only, bool);
    METHOD(Color, get_border_color);
    METHOD(void, set_border_color);
    METHOD(double, get_border_width);
    METHOD(void, set_border_width);
    METHOD(bool, get_editor_only);
    METHOD(void, set_editor_only);
};
struct RegEx : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Object, create_from_string);
    METHOD(Variant, clear);
    METHOD(int64_t, compile);
    METHOD(Object, search);
    METHOD(Array, search_all);
    METHOD(String, sub);
    METHOD(bool, is_valid);
    METHOD(String, get_pattern);
    METHOD(int64_t, get_group_count);
    METHOD(PackedArray<std::string>, get_names);
};
struct RegExMatch : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(subject, String);
    PROPERTY(names, Dictionary);
    PROPERTY(strings, Array);
    METHOD(String, get_subject);
    METHOD(int64_t, get_group_count);
    METHOD(Dictionary, get_names);
    METHOD(PackedArray<std::string>, get_strings);
    METHOD(String, get_string);
    METHOD(int64_t, get_start);
    METHOD(int64_t, get_end);
};
struct RemoteTransform2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(remote_path, String);
    PROPERTY(use_global_coordinates, bool);
    PROPERTY(update_position, bool);
    PROPERTY(update_rotation, bool);
    PROPERTY(update_scale, bool);
    METHOD(void, set_remote_node);
    METHOD(String, get_remote_node);
    METHOD(Variant, force_update_cache);
    METHOD(void, set_use_global_coordinates);
    METHOD(bool, get_use_global_coordinates);
    METHOD(void, set_update_position);
    METHOD(bool, get_update_position);
    METHOD(void, set_update_rotation);
    METHOD(bool, get_update_rotation);
    METHOD(void, set_update_scale);
    METHOD(bool, get_update_scale);
};
struct RemoteTransform3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(remote_path, String);
    PROPERTY(use_global_coordinates, bool);
    PROPERTY(update_position, bool);
    PROPERTY(update_rotation, bool);
    PROPERTY(update_scale, bool);
    METHOD(void, set_remote_node);
    METHOD(String, get_remote_node);
    METHOD(Variant, force_update_cache);
    METHOD(void, set_use_global_coordinates);
    METHOD(bool, get_use_global_coordinates);
    METHOD(void, set_update_position);
    METHOD(bool, get_update_position);
    METHOD(void, set_update_rotation);
    METHOD(bool, get_update_rotation);
    METHOD(void, set_update_scale);
    METHOD(bool, get_update_scale);
};
struct RenderBufferCustomDataRD : public RefCounted {
    using RefCounted::RefCounted;
};
struct RenderBufferDataForwardClustered : public RenderBufferCustomDataRD {
    using RenderBufferCustomDataRD::RenderBufferCustomDataRD;
};
struct RenderBuffersGI : public RenderBufferCustomDataRD {
    using RenderBufferCustomDataRD::RenderBufferCustomDataRD;
};
struct RenderData : public Object {
    using Object::Object;
    METHOD(Object, get_render_scene_buffers);
    METHOD(Object, get_render_scene_data);
    METHOD(::RID, get_environment);
    METHOD(::RID, get_camera_attributes);
};
struct RenderDataExtension : public RenderData {
    using RenderData::RenderData;
    METHOD(Object, _get_render_scene_buffers);
    METHOD(Object, _get_render_scene_data);
    METHOD(::RID, _get_environment);
    METHOD(::RID, _get_camera_attributes);
};
struct RenderDataRD : public RenderData {
    using RenderData::RenderData;
};
struct RenderSceneBuffers : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, configure);
};
struct RenderSceneBuffersConfiguration : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(render_target, ::RID);
    PROPERTY(internal_size, Vector2i);
    PROPERTY(target_size, Vector2i);
    PROPERTY(view_count, int64_t);
    PROPERTY(scaling_3d_mode, int64_t);
    PROPERTY(msaa_3d, int64_t);
    PROPERTY(screen_space_aa, int64_t);
    PROPERTY(fsr_sharpness, bool);
    PROPERTY(texture_mipmap_bias, bool);
    METHOD(::RID, get_render_target);
    METHOD(void, set_render_target);
    METHOD(Vector2i, get_internal_size);
    METHOD(void, set_internal_size);
    METHOD(Vector2i, get_target_size);
    METHOD(void, set_target_size);
    METHOD(int64_t, get_view_count);
    METHOD(void, set_view_count);
    METHOD(int64_t, get_scaling_3d_mode);
    METHOD(void, set_scaling_3d_mode);
    METHOD(int64_t, get_msaa_3d);
    METHOD(void, set_msaa_3d);
    METHOD(int64_t, get_screen_space_aa);
    METHOD(void, set_screen_space_aa);
    METHOD(double, get_fsr_sharpness);
    METHOD(void, set_fsr_sharpness);
    METHOD(double, get_texture_mipmap_bias);
    METHOD(void, set_texture_mipmap_bias);
};
struct RenderSceneBuffersExtension : public RenderSceneBuffers {
    using RenderSceneBuffers::RenderSceneBuffers;
    METHOD(Variant, _configure);
    METHOD(Variant, _set_fsr_sharpness);
    METHOD(Variant, _set_texture_mipmap_bias);
    METHOD(Variant, _set_use_debanding);
};
struct RenderSceneBuffersRD : public RenderSceneBuffers {
    using RenderSceneBuffers::RenderSceneBuffers;
    METHOD(bool, has_texture);
    METHOD(::RID, create_texture);
    METHOD(::RID, create_texture_from_format);
    METHOD(::RID, create_texture_view);
    METHOD(::RID, get_texture);
    METHOD(Object, get_texture_format);
    METHOD(::RID, get_texture_slice);
    METHOD(::RID, get_texture_slice_view);
    METHOD(Vector2i, get_texture_slice_size);
    METHOD(Variant, clear_context);
    METHOD(::RID, get_color_texture);
    METHOD(::RID, get_color_layer);
    METHOD(::RID, get_depth_texture);
    METHOD(::RID, get_depth_layer);
    METHOD(::RID, get_velocity_texture);
    METHOD(::RID, get_velocity_layer);
    METHOD(::RID, get_render_target);
    METHOD(int64_t, get_view_count);
    METHOD(Vector2i, get_internal_size);
    METHOD(Vector2i, get_target_size);
    METHOD(int64_t, get_scaling_3d_mode);
    METHOD(double, get_fsr_sharpness);
    METHOD(int64_t, get_msaa_3d);
    METHOD(int64_t, get_texture_samples);
    METHOD(int64_t, get_screen_space_aa);
    METHOD(bool, get_use_taa);
    METHOD(bool, get_use_debanding);
};
struct RenderSceneData : public Object {
    using Object::Object;
    METHOD(Transform3D, get_cam_transform);
    METHOD(Variant, get_cam_projection);
    METHOD(int64_t, get_view_count);
    METHOD(Vector3, get_view_eye_offset);
    METHOD(Variant, get_view_projection);
    METHOD(::RID, get_uniform_buffer);
};
struct RenderSceneDataExtension : public RenderSceneData {
    using RenderSceneData::RenderSceneData;
    METHOD(Transform3D, _get_cam_transform);
    METHOD(Variant, _get_cam_projection);
    METHOD(int64_t, _get_view_count);
    METHOD(Vector3, _get_view_eye_offset);
    METHOD(Variant, _get_view_projection);
    METHOD(::RID, _get_uniform_buffer);
};
struct RenderSceneDataRD : public RenderSceneData {
    using RenderSceneData::RenderSceneData;
};
struct RenderingDevice : public Object {
    using Object::Object;
    METHOD(::RID, texture_create);
    METHOD(::RID, texture_create_shared);
    METHOD(::RID, texture_create_shared_from_slice);
    METHOD(::RID, texture_create_from_extension);
    METHOD(int64_t, texture_update);
    METHOD(PackedArray<uint8_t>, texture_get_data);
    METHOD(bool, texture_is_format_supported_for_usage);
    METHOD(bool, texture_is_shared);
    METHOD(bool, texture_is_valid);
    METHOD(int64_t, texture_copy);
    METHOD(int64_t, texture_clear);
    METHOD(int64_t, texture_resolve_multisample);
    METHOD(Object, texture_get_format);
    METHOD(int64_t, texture_get_native_handle);
    METHOD(int64_t, framebuffer_format_create);
    METHOD(int64_t, framebuffer_format_create_multipass);
    METHOD(int64_t, framebuffer_format_create_empty);
    METHOD(int64_t, framebuffer_format_get_texture_samples);
    METHOD(::RID, framebuffer_create);
    METHOD(::RID, framebuffer_create_multipass);
    METHOD(::RID, framebuffer_create_empty);
    METHOD(int64_t, framebuffer_get_format);
    METHOD(bool, framebuffer_is_valid);
    METHOD(::RID, sampler_create);
    METHOD(bool, sampler_is_format_supported_for_filter);
    METHOD(::RID, vertex_buffer_create);
    METHOD(int64_t, vertex_format_create);
    METHOD(::RID, vertex_array_create);
    METHOD(::RID, index_buffer_create);
    METHOD(::RID, index_array_create);
    METHOD(Object, shader_compile_spirv_from_source);
    METHOD(PackedArray<uint8_t>, shader_compile_binary_from_spirv);
    METHOD(::RID, shader_create_from_spirv);
    METHOD(::RID, shader_create_from_bytecode);
    METHOD(::RID, shader_create_placeholder);
    METHOD(int64_t, shader_get_vertex_input_attribute_mask);
    METHOD(::RID, uniform_buffer_create);
    METHOD(::RID, storage_buffer_create);
    METHOD(::RID, texture_buffer_create);
    METHOD(::RID, uniform_set_create);
    METHOD(bool, uniform_set_is_valid);
    METHOD(int64_t, buffer_copy);
    METHOD(int64_t, buffer_update);
    METHOD(int64_t, buffer_clear);
    METHOD(PackedArray<uint8_t>, buffer_get_data);
    METHOD(::RID, render_pipeline_create);
    METHOD(bool, render_pipeline_is_valid);
    METHOD(::RID, compute_pipeline_create);
    METHOD(bool, compute_pipeline_is_valid);
    METHOD(int64_t, screen_get_width);
    METHOD(int64_t, screen_get_height);
    METHOD(int64_t, screen_get_framebuffer_format);
    METHOD(int64_t, draw_list_begin_for_screen);
    METHOD(int64_t, draw_list_begin);
    METHOD(PackedArray<int64_t>, draw_list_begin_split);
    METHOD(Variant, draw_list_set_blend_constants);
    METHOD(Variant, draw_list_bind_render_pipeline);
    METHOD(Variant, draw_list_bind_uniform_set);
    METHOD(Variant, draw_list_bind_vertex_array);
    METHOD(Variant, draw_list_bind_index_array);
    METHOD(Variant, draw_list_set_push_constant);
    METHOD(Variant, draw_list_draw);
    METHOD(Variant, draw_list_enable_scissor);
    METHOD(Variant, draw_list_disable_scissor);
    METHOD(int64_t, draw_list_switch_to_next_pass);
    METHOD(PackedArray<int64_t>, draw_list_switch_to_next_pass_split);
    METHOD(Variant, draw_list_end);
    METHOD(int64_t, compute_list_begin);
    METHOD(Variant, compute_list_bind_compute_pipeline);
    METHOD(Variant, compute_list_set_push_constant);
    METHOD(Variant, compute_list_bind_uniform_set);
    METHOD(Variant, compute_list_dispatch);
    METHOD(Variant, compute_list_dispatch_indirect);
    METHOD(Variant, compute_list_add_barrier);
    METHOD(Variant, compute_list_end);
    METHOD(Variant, free_rid);
    METHOD(Variant, capture_timestamp);
    METHOD(int64_t, get_captured_timestamps_count);
    METHOD(int64_t, get_captured_timestamps_frame);
    METHOD(int64_t, get_captured_timestamp_gpu_time);
    METHOD(int64_t, get_captured_timestamp_cpu_time);
    METHOD(String, get_captured_timestamp_name);
    METHOD(int64_t, limit_get);
    METHOD(int64_t, get_frame_delay);
    METHOD(Variant, submit);
    METHOD(Variant, sync);
    METHOD(Variant, barrier);
    METHOD(Variant, full_barrier);
    METHOD(Object, create_local_device);
    METHOD(void, set_resource_name);
    METHOD(Variant, draw_command_begin_label);
    METHOD(Variant, draw_command_insert_label);
    METHOD(Variant, draw_command_end_label);
    METHOD(String, get_device_vendor_name);
    METHOD(String, get_device_name);
    METHOD(String, get_device_pipeline_cache_uuid);
    METHOD(int64_t, get_memory_usage);
    METHOD(int64_t, get_driver_resource);
    static constexpr int64_t DEVICE_TYPE_OTHER = 0;
    static constexpr int64_t DEVICE_TYPE_INTEGRATED_GPU = 1;
    static constexpr int64_t DEVICE_TYPE_DISCRETE_GPU = 2;
    static constexpr int64_t DEVICE_TYPE_VIRTUAL_GPU = 3;
    static constexpr int64_t DEVICE_TYPE_CPU = 4;
    static constexpr int64_t DEVICE_TYPE_MAX = 5;
    static constexpr int64_t DRIVER_RESOURCE_LOGICAL_DEVICE = 0;
    static constexpr int64_t DRIVER_RESOURCE_PHYSICAL_DEVICE = 1;
    static constexpr int64_t DRIVER_RESOURCE_TOPMOST_OBJECT = 2;
    static constexpr int64_t DRIVER_RESOURCE_COMMAND_QUEUE = 3;
    static constexpr int64_t DRIVER_RESOURCE_QUEUE_FAMILY = 4;
    static constexpr int64_t DRIVER_RESOURCE_TEXTURE = 5;
    static constexpr int64_t DRIVER_RESOURCE_TEXTURE_VIEW = 6;
    static constexpr int64_t DRIVER_RESOURCE_TEXTURE_DATA_FORMAT = 7;
    static constexpr int64_t DRIVER_RESOURCE_SAMPLER = 8;
    static constexpr int64_t DRIVER_RESOURCE_UNIFORM_SET = 9;
    static constexpr int64_t DRIVER_RESOURCE_BUFFER = 10;
    static constexpr int64_t DRIVER_RESOURCE_COMPUTE_PIPELINE = 11;
    static constexpr int64_t DRIVER_RESOURCE_RENDER_PIPELINE = 12;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_DEVICE = 0;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_PHYSICAL_DEVICE = 1;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_INSTANCE = 2;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_QUEUE = 3;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_QUEUE_FAMILY_INDEX = 4;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_IMAGE = 5;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_IMAGE_VIEW = 6;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_IMAGE_NATIVE_TEXTURE_FORMAT = 7;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_SAMPLER = 8;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_DESCRIPTOR_SET = 9;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_BUFFER = 10;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_COMPUTE_PIPELINE = 11;
    static constexpr int64_t DRIVER_RESOURCE_VULKAN_RENDER_PIPELINE = 12;
    static constexpr int64_t DATA_FORMAT_R4G4_UNORM_PACK8 = 0;
    static constexpr int64_t DATA_FORMAT_R4G4B4A4_UNORM_PACK16 = 1;
    static constexpr int64_t DATA_FORMAT_B4G4R4A4_UNORM_PACK16 = 2;
    static constexpr int64_t DATA_FORMAT_R5G6B5_UNORM_PACK16 = 3;
    static constexpr int64_t DATA_FORMAT_B5G6R5_UNORM_PACK16 = 4;
    static constexpr int64_t DATA_FORMAT_R5G5B5A1_UNORM_PACK16 = 5;
    static constexpr int64_t DATA_FORMAT_B5G5R5A1_UNORM_PACK16 = 6;
    static constexpr int64_t DATA_FORMAT_A1R5G5B5_UNORM_PACK16 = 7;
    static constexpr int64_t DATA_FORMAT_R8_UNORM = 8;
    static constexpr int64_t DATA_FORMAT_R8_SNORM = 9;
    static constexpr int64_t DATA_FORMAT_R8_USCALED = 10;
    static constexpr int64_t DATA_FORMAT_R8_SSCALED = 11;
    static constexpr int64_t DATA_FORMAT_R8_UINT = 12;
    static constexpr int64_t DATA_FORMAT_R8_SINT = 13;
    static constexpr int64_t DATA_FORMAT_R8_SRGB = 14;
    static constexpr int64_t DATA_FORMAT_R8G8_UNORM = 15;
    static constexpr int64_t DATA_FORMAT_R8G8_SNORM = 16;
    static constexpr int64_t DATA_FORMAT_R8G8_USCALED = 17;
    static constexpr int64_t DATA_FORMAT_R8G8_SSCALED = 18;
    static constexpr int64_t DATA_FORMAT_R8G8_UINT = 19;
    static constexpr int64_t DATA_FORMAT_R8G8_SINT = 20;
    static constexpr int64_t DATA_FORMAT_R8G8_SRGB = 21;
    static constexpr int64_t DATA_FORMAT_R8G8B8_UNORM = 22;
    static constexpr int64_t DATA_FORMAT_R8G8B8_SNORM = 23;
    static constexpr int64_t DATA_FORMAT_R8G8B8_USCALED = 24;
    static constexpr int64_t DATA_FORMAT_R8G8B8_SSCALED = 25;
    static constexpr int64_t DATA_FORMAT_R8G8B8_UINT = 26;
    static constexpr int64_t DATA_FORMAT_R8G8B8_SINT = 27;
    static constexpr int64_t DATA_FORMAT_R8G8B8_SRGB = 28;
    static constexpr int64_t DATA_FORMAT_B8G8R8_UNORM = 29;
    static constexpr int64_t DATA_FORMAT_B8G8R8_SNORM = 30;
    static constexpr int64_t DATA_FORMAT_B8G8R8_USCALED = 31;
    static constexpr int64_t DATA_FORMAT_B8G8R8_SSCALED = 32;
    static constexpr int64_t DATA_FORMAT_B8G8R8_UINT = 33;
    static constexpr int64_t DATA_FORMAT_B8G8R8_SINT = 34;
    static constexpr int64_t DATA_FORMAT_B8G8R8_SRGB = 35;
    static constexpr int64_t DATA_FORMAT_R8G8B8A8_UNORM = 36;
    static constexpr int64_t DATA_FORMAT_R8G8B8A8_SNORM = 37;
    static constexpr int64_t DATA_FORMAT_R8G8B8A8_USCALED = 38;
    static constexpr int64_t DATA_FORMAT_R8G8B8A8_SSCALED = 39;
    static constexpr int64_t DATA_FORMAT_R8G8B8A8_UINT = 40;
    static constexpr int64_t DATA_FORMAT_R8G8B8A8_SINT = 41;
    static constexpr int64_t DATA_FORMAT_R8G8B8A8_SRGB = 42;
    static constexpr int64_t DATA_FORMAT_B8G8R8A8_UNORM = 43;
    static constexpr int64_t DATA_FORMAT_B8G8R8A8_SNORM = 44;
    static constexpr int64_t DATA_FORMAT_B8G8R8A8_USCALED = 45;
    static constexpr int64_t DATA_FORMAT_B8G8R8A8_SSCALED = 46;
    static constexpr int64_t DATA_FORMAT_B8G8R8A8_UINT = 47;
    static constexpr int64_t DATA_FORMAT_B8G8R8A8_SINT = 48;
    static constexpr int64_t DATA_FORMAT_B8G8R8A8_SRGB = 49;
    static constexpr int64_t DATA_FORMAT_A8B8G8R8_UNORM_PACK32 = 50;
    static constexpr int64_t DATA_FORMAT_A8B8G8R8_SNORM_PACK32 = 51;
    static constexpr int64_t DATA_FORMAT_A8B8G8R8_USCALED_PACK32 = 52;
    static constexpr int64_t DATA_FORMAT_A8B8G8R8_SSCALED_PACK32 = 53;
    static constexpr int64_t DATA_FORMAT_A8B8G8R8_UINT_PACK32 = 54;
    static constexpr int64_t DATA_FORMAT_A8B8G8R8_SINT_PACK32 = 55;
    static constexpr int64_t DATA_FORMAT_A8B8G8R8_SRGB_PACK32 = 56;
    static constexpr int64_t DATA_FORMAT_A2R10G10B10_UNORM_PACK32 = 57;
    static constexpr int64_t DATA_FORMAT_A2R10G10B10_SNORM_PACK32 = 58;
    static constexpr int64_t DATA_FORMAT_A2R10G10B10_USCALED_PACK32 = 59;
    static constexpr int64_t DATA_FORMAT_A2R10G10B10_SSCALED_PACK32 = 60;
    static constexpr int64_t DATA_FORMAT_A2R10G10B10_UINT_PACK32 = 61;
    static constexpr int64_t DATA_FORMAT_A2R10G10B10_SINT_PACK32 = 62;
    static constexpr int64_t DATA_FORMAT_A2B10G10R10_UNORM_PACK32 = 63;
    static constexpr int64_t DATA_FORMAT_A2B10G10R10_SNORM_PACK32 = 64;
    static constexpr int64_t DATA_FORMAT_A2B10G10R10_USCALED_PACK32 = 65;
    static constexpr int64_t DATA_FORMAT_A2B10G10R10_SSCALED_PACK32 = 66;
    static constexpr int64_t DATA_FORMAT_A2B10G10R10_UINT_PACK32 = 67;
    static constexpr int64_t DATA_FORMAT_A2B10G10R10_SINT_PACK32 = 68;
    static constexpr int64_t DATA_FORMAT_R16_UNORM = 69;
    static constexpr int64_t DATA_FORMAT_R16_SNORM = 70;
    static constexpr int64_t DATA_FORMAT_R16_USCALED = 71;
    static constexpr int64_t DATA_FORMAT_R16_SSCALED = 72;
    static constexpr int64_t DATA_FORMAT_R16_UINT = 73;
    static constexpr int64_t DATA_FORMAT_R16_SINT = 74;
    static constexpr int64_t DATA_FORMAT_R16_SFLOAT = 75;
    static constexpr int64_t DATA_FORMAT_R16G16_UNORM = 76;
    static constexpr int64_t DATA_FORMAT_R16G16_SNORM = 77;
    static constexpr int64_t DATA_FORMAT_R16G16_USCALED = 78;
    static constexpr int64_t DATA_FORMAT_R16G16_SSCALED = 79;
    static constexpr int64_t DATA_FORMAT_R16G16_UINT = 80;
    static constexpr int64_t DATA_FORMAT_R16G16_SINT = 81;
    static constexpr int64_t DATA_FORMAT_R16G16_SFLOAT = 82;
    static constexpr int64_t DATA_FORMAT_R16G16B16_UNORM = 83;
    static constexpr int64_t DATA_FORMAT_R16G16B16_SNORM = 84;
    static constexpr int64_t DATA_FORMAT_R16G16B16_USCALED = 85;
    static constexpr int64_t DATA_FORMAT_R16G16B16_SSCALED = 86;
    static constexpr int64_t DATA_FORMAT_R16G16B16_UINT = 87;
    static constexpr int64_t DATA_FORMAT_R16G16B16_SINT = 88;
    static constexpr int64_t DATA_FORMAT_R16G16B16_SFLOAT = 89;
    static constexpr int64_t DATA_FORMAT_R16G16B16A16_UNORM = 90;
    static constexpr int64_t DATA_FORMAT_R16G16B16A16_SNORM = 91;
    static constexpr int64_t DATA_FORMAT_R16G16B16A16_USCALED = 92;
    static constexpr int64_t DATA_FORMAT_R16G16B16A16_SSCALED = 93;
    static constexpr int64_t DATA_FORMAT_R16G16B16A16_UINT = 94;
    static constexpr int64_t DATA_FORMAT_R16G16B16A16_SINT = 95;
    static constexpr int64_t DATA_FORMAT_R16G16B16A16_SFLOAT = 96;
    static constexpr int64_t DATA_FORMAT_R32_UINT = 97;
    static constexpr int64_t DATA_FORMAT_R32_SINT = 98;
    static constexpr int64_t DATA_FORMAT_R32_SFLOAT = 99;
    static constexpr int64_t DATA_FORMAT_R32G32_UINT = 100;
    static constexpr int64_t DATA_FORMAT_R32G32_SINT = 101;
    static constexpr int64_t DATA_FORMAT_R32G32_SFLOAT = 102;
    static constexpr int64_t DATA_FORMAT_R32G32B32_UINT = 103;
    static constexpr int64_t DATA_FORMAT_R32G32B32_SINT = 104;
    static constexpr int64_t DATA_FORMAT_R32G32B32_SFLOAT = 105;
    static constexpr int64_t DATA_FORMAT_R32G32B32A32_UINT = 106;
    static constexpr int64_t DATA_FORMAT_R32G32B32A32_SINT = 107;
    static constexpr int64_t DATA_FORMAT_R32G32B32A32_SFLOAT = 108;
    static constexpr int64_t DATA_FORMAT_R64_UINT = 109;
    static constexpr int64_t DATA_FORMAT_R64_SINT = 110;
    static constexpr int64_t DATA_FORMAT_R64_SFLOAT = 111;
    static constexpr int64_t DATA_FORMAT_R64G64_UINT = 112;
    static constexpr int64_t DATA_FORMAT_R64G64_SINT = 113;
    static constexpr int64_t DATA_FORMAT_R64G64_SFLOAT = 114;
    static constexpr int64_t DATA_FORMAT_R64G64B64_UINT = 115;
    static constexpr int64_t DATA_FORMAT_R64G64B64_SINT = 116;
    static constexpr int64_t DATA_FORMAT_R64G64B64_SFLOAT = 117;
    static constexpr int64_t DATA_FORMAT_R64G64B64A64_UINT = 118;
    static constexpr int64_t DATA_FORMAT_R64G64B64A64_SINT = 119;
    static constexpr int64_t DATA_FORMAT_R64G64B64A64_SFLOAT = 120;
    static constexpr int64_t DATA_FORMAT_B10G11R11_UFLOAT_PACK32 = 121;
    static constexpr int64_t DATA_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 122;
    static constexpr int64_t DATA_FORMAT_D16_UNORM = 123;
    static constexpr int64_t DATA_FORMAT_X8_D24_UNORM_PACK32 = 124;
    static constexpr int64_t DATA_FORMAT_D32_SFLOAT = 125;
    static constexpr int64_t DATA_FORMAT_S8_UINT = 126;
    static constexpr int64_t DATA_FORMAT_D16_UNORM_S8_UINT = 127;
    static constexpr int64_t DATA_FORMAT_D24_UNORM_S8_UINT = 128;
    static constexpr int64_t DATA_FORMAT_D32_SFLOAT_S8_UINT = 129;
    static constexpr int64_t DATA_FORMAT_BC1_RGB_UNORM_BLOCK = 130;
    static constexpr int64_t DATA_FORMAT_BC1_RGB_SRGB_BLOCK = 131;
    static constexpr int64_t DATA_FORMAT_BC1_RGBA_UNORM_BLOCK = 132;
    static constexpr int64_t DATA_FORMAT_BC1_RGBA_SRGB_BLOCK = 133;
    static constexpr int64_t DATA_FORMAT_BC2_UNORM_BLOCK = 134;
    static constexpr int64_t DATA_FORMAT_BC2_SRGB_BLOCK = 135;
    static constexpr int64_t DATA_FORMAT_BC3_UNORM_BLOCK = 136;
    static constexpr int64_t DATA_FORMAT_BC3_SRGB_BLOCK = 137;
    static constexpr int64_t DATA_FORMAT_BC4_UNORM_BLOCK = 138;
    static constexpr int64_t DATA_FORMAT_BC4_SNORM_BLOCK = 139;
    static constexpr int64_t DATA_FORMAT_BC5_UNORM_BLOCK = 140;
    static constexpr int64_t DATA_FORMAT_BC5_SNORM_BLOCK = 141;
    static constexpr int64_t DATA_FORMAT_BC6H_UFLOAT_BLOCK = 142;
    static constexpr int64_t DATA_FORMAT_BC6H_SFLOAT_BLOCK = 143;
    static constexpr int64_t DATA_FORMAT_BC7_UNORM_BLOCK = 144;
    static constexpr int64_t DATA_FORMAT_BC7_SRGB_BLOCK = 145;
    static constexpr int64_t DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 146;
    static constexpr int64_t DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 147;
    static constexpr int64_t DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 148;
    static constexpr int64_t DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 149;
    static constexpr int64_t DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 150;
    static constexpr int64_t DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 151;
    static constexpr int64_t DATA_FORMAT_EAC_R11_UNORM_BLOCK = 152;
    static constexpr int64_t DATA_FORMAT_EAC_R11_SNORM_BLOCK = 153;
    static constexpr int64_t DATA_FORMAT_EAC_R11G11_UNORM_BLOCK = 154;
    static constexpr int64_t DATA_FORMAT_EAC_R11G11_SNORM_BLOCK = 155;
    static constexpr int64_t DATA_FORMAT_ASTC_4x4_UNORM_BLOCK = 156;
    static constexpr int64_t DATA_FORMAT_ASTC_4x4_SRGB_BLOCK = 157;
    static constexpr int64_t DATA_FORMAT_ASTC_5x4_UNORM_BLOCK = 158;
    static constexpr int64_t DATA_FORMAT_ASTC_5x4_SRGB_BLOCK = 159;
    static constexpr int64_t DATA_FORMAT_ASTC_5x5_UNORM_BLOCK = 160;
    static constexpr int64_t DATA_FORMAT_ASTC_5x5_SRGB_BLOCK = 161;
    static constexpr int64_t DATA_FORMAT_ASTC_6x5_UNORM_BLOCK = 162;
    static constexpr int64_t DATA_FORMAT_ASTC_6x5_SRGB_BLOCK = 163;
    static constexpr int64_t DATA_FORMAT_ASTC_6x6_UNORM_BLOCK = 164;
    static constexpr int64_t DATA_FORMAT_ASTC_6x6_SRGB_BLOCK = 165;
    static constexpr int64_t DATA_FORMAT_ASTC_8x5_UNORM_BLOCK = 166;
    static constexpr int64_t DATA_FORMAT_ASTC_8x5_SRGB_BLOCK = 167;
    static constexpr int64_t DATA_FORMAT_ASTC_8x6_UNORM_BLOCK = 168;
    static constexpr int64_t DATA_FORMAT_ASTC_8x6_SRGB_BLOCK = 169;
    static constexpr int64_t DATA_FORMAT_ASTC_8x8_UNORM_BLOCK = 170;
    static constexpr int64_t DATA_FORMAT_ASTC_8x8_SRGB_BLOCK = 171;
    static constexpr int64_t DATA_FORMAT_ASTC_10x5_UNORM_BLOCK = 172;
    static constexpr int64_t DATA_FORMAT_ASTC_10x5_SRGB_BLOCK = 173;
    static constexpr int64_t DATA_FORMAT_ASTC_10x6_UNORM_BLOCK = 174;
    static constexpr int64_t DATA_FORMAT_ASTC_10x6_SRGB_BLOCK = 175;
    static constexpr int64_t DATA_FORMAT_ASTC_10x8_UNORM_BLOCK = 176;
    static constexpr int64_t DATA_FORMAT_ASTC_10x8_SRGB_BLOCK = 177;
    static constexpr int64_t DATA_FORMAT_ASTC_10x10_UNORM_BLOCK = 178;
    static constexpr int64_t DATA_FORMAT_ASTC_10x10_SRGB_BLOCK = 179;
    static constexpr int64_t DATA_FORMAT_ASTC_12x10_UNORM_BLOCK = 180;
    static constexpr int64_t DATA_FORMAT_ASTC_12x10_SRGB_BLOCK = 181;
    static constexpr int64_t DATA_FORMAT_ASTC_12x12_UNORM_BLOCK = 182;
    static constexpr int64_t DATA_FORMAT_ASTC_12x12_SRGB_BLOCK = 183;
    static constexpr int64_t DATA_FORMAT_G8B8G8R8_422_UNORM = 184;
    static constexpr int64_t DATA_FORMAT_B8G8R8G8_422_UNORM = 185;
    static constexpr int64_t DATA_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 186;
    static constexpr int64_t DATA_FORMAT_G8_B8R8_2PLANE_420_UNORM = 187;
    static constexpr int64_t DATA_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 188;
    static constexpr int64_t DATA_FORMAT_G8_B8R8_2PLANE_422_UNORM = 189;
    static constexpr int64_t DATA_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 190;
    static constexpr int64_t DATA_FORMAT_R10X6_UNORM_PACK16 = 191;
    static constexpr int64_t DATA_FORMAT_R10X6G10X6_UNORM_2PACK16 = 192;
    static constexpr int64_t DATA_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 193;
    static constexpr int64_t DATA_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 194;
    static constexpr int64_t DATA_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 195;
    static constexpr int64_t DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 196;
    static constexpr int64_t DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 197;
    static constexpr int64_t DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 198;
    static constexpr int64_t DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 199;
    static constexpr int64_t DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 200;
    static constexpr int64_t DATA_FORMAT_R12X4_UNORM_PACK16 = 201;
    static constexpr int64_t DATA_FORMAT_R12X4G12X4_UNORM_2PACK16 = 202;
    static constexpr int64_t DATA_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 203;
    static constexpr int64_t DATA_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 204;
    static constexpr int64_t DATA_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 205;
    static constexpr int64_t DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 206;
    static constexpr int64_t DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 207;
    static constexpr int64_t DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 208;
    static constexpr int64_t DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 209;
    static constexpr int64_t DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 210;
    static constexpr int64_t DATA_FORMAT_G16B16G16R16_422_UNORM = 211;
    static constexpr int64_t DATA_FORMAT_B16G16R16G16_422_UNORM = 212;
    static constexpr int64_t DATA_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 213;
    static constexpr int64_t DATA_FORMAT_G16_B16R16_2PLANE_420_UNORM = 214;
    static constexpr int64_t DATA_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 215;
    static constexpr int64_t DATA_FORMAT_G16_B16R16_2PLANE_422_UNORM = 216;
    static constexpr int64_t DATA_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 217;
    static constexpr int64_t DATA_FORMAT_MAX = 218;
    static constexpr int64_t BARRIER_MASK_VERTEX = 1;
    static constexpr int64_t BARRIER_MASK_FRAGMENT = 8;
    static constexpr int64_t BARRIER_MASK_COMPUTE = 2;
    static constexpr int64_t BARRIER_MASK_TRANSFER = 4;
    static constexpr int64_t BARRIER_MASK_RASTER = 9;
    static constexpr int64_t BARRIER_MASK_ALL_BARRIERS = 32767;
    static constexpr int64_t BARRIER_MASK_NO_BARRIER = 32768;
    static constexpr int64_t TEXTURE_TYPE_1D = 0;
    static constexpr int64_t TEXTURE_TYPE_2D = 1;
    static constexpr int64_t TEXTURE_TYPE_3D = 2;
    static constexpr int64_t TEXTURE_TYPE_CUBE = 3;
    static constexpr int64_t TEXTURE_TYPE_1D_ARRAY = 4;
    static constexpr int64_t TEXTURE_TYPE_2D_ARRAY = 5;
    static constexpr int64_t TEXTURE_TYPE_CUBE_ARRAY = 6;
    static constexpr int64_t TEXTURE_TYPE_MAX = 7;
    static constexpr int64_t TEXTURE_SAMPLES_1 = 0;
    static constexpr int64_t TEXTURE_SAMPLES_2 = 1;
    static constexpr int64_t TEXTURE_SAMPLES_4 = 2;
    static constexpr int64_t TEXTURE_SAMPLES_8 = 3;
    static constexpr int64_t TEXTURE_SAMPLES_16 = 4;
    static constexpr int64_t TEXTURE_SAMPLES_32 = 5;
    static constexpr int64_t TEXTURE_SAMPLES_64 = 6;
    static constexpr int64_t TEXTURE_SAMPLES_MAX = 7;
    static constexpr int64_t TEXTURE_USAGE_SAMPLING_BIT = 1;
    static constexpr int64_t TEXTURE_USAGE_COLOR_ATTACHMENT_BIT = 2;
    static constexpr int64_t TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 4;
    static constexpr int64_t TEXTURE_USAGE_STORAGE_BIT = 8;
    static constexpr int64_t TEXTURE_USAGE_STORAGE_ATOMIC_BIT = 16;
    static constexpr int64_t TEXTURE_USAGE_CPU_READ_BIT = 32;
    static constexpr int64_t TEXTURE_USAGE_CAN_UPDATE_BIT = 64;
    static constexpr int64_t TEXTURE_USAGE_CAN_COPY_FROM_BIT = 128;
    static constexpr int64_t TEXTURE_USAGE_CAN_COPY_TO_BIT = 256;
    static constexpr int64_t TEXTURE_USAGE_INPUT_ATTACHMENT_BIT = 512;
    static constexpr int64_t TEXTURE_SWIZZLE_IDENTITY = 0;
    static constexpr int64_t TEXTURE_SWIZZLE_ZERO = 1;
    static constexpr int64_t TEXTURE_SWIZZLE_ONE = 2;
    static constexpr int64_t TEXTURE_SWIZZLE_R = 3;
    static constexpr int64_t TEXTURE_SWIZZLE_G = 4;
    static constexpr int64_t TEXTURE_SWIZZLE_B = 5;
    static constexpr int64_t TEXTURE_SWIZZLE_A = 6;
    static constexpr int64_t TEXTURE_SWIZZLE_MAX = 7;
    static constexpr int64_t TEXTURE_SLICE_2D = 0;
    static constexpr int64_t TEXTURE_SLICE_CUBEMAP = 1;
    static constexpr int64_t TEXTURE_SLICE_3D = 2;
    static constexpr int64_t SAMPLER_FILTER_NEAREST = 0;
    static constexpr int64_t SAMPLER_FILTER_LINEAR = 1;
    static constexpr int64_t SAMPLER_REPEAT_MODE_REPEAT = 0;
    static constexpr int64_t SAMPLER_REPEAT_MODE_MIRRORED_REPEAT = 1;
    static constexpr int64_t SAMPLER_REPEAT_MODE_CLAMP_TO_EDGE = 2;
    static constexpr int64_t SAMPLER_REPEAT_MODE_CLAMP_TO_BORDER = 3;
    static constexpr int64_t SAMPLER_REPEAT_MODE_MIRROR_CLAMP_TO_EDGE = 4;
    static constexpr int64_t SAMPLER_REPEAT_MODE_MAX = 5;
    static constexpr int64_t SAMPLER_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0;
    static constexpr int64_t SAMPLER_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1;
    static constexpr int64_t SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2;
    static constexpr int64_t SAMPLER_BORDER_COLOR_INT_OPAQUE_BLACK = 3;
    static constexpr int64_t SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4;
    static constexpr int64_t SAMPLER_BORDER_COLOR_INT_OPAQUE_WHITE = 5;
    static constexpr int64_t SAMPLER_BORDER_COLOR_MAX = 6;
    static constexpr int64_t VERTEX_FREQUENCY_VERTEX = 0;
    static constexpr int64_t VERTEX_FREQUENCY_INSTANCE = 1;
    static constexpr int64_t INDEX_BUFFER_FORMAT_UINT16 = 0;
    static constexpr int64_t INDEX_BUFFER_FORMAT_UINT32 = 1;
    static constexpr int64_t STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT = 1;
    static constexpr int64_t UNIFORM_TYPE_SAMPLER = 0;
    static constexpr int64_t UNIFORM_TYPE_SAMPLER_WITH_TEXTURE = 1;
    static constexpr int64_t UNIFORM_TYPE_TEXTURE = 2;
    static constexpr int64_t UNIFORM_TYPE_IMAGE = 3;
    static constexpr int64_t UNIFORM_TYPE_TEXTURE_BUFFER = 4;
    static constexpr int64_t UNIFORM_TYPE_SAMPLER_WITH_TEXTURE_BUFFER = 5;
    static constexpr int64_t UNIFORM_TYPE_IMAGE_BUFFER = 6;
    static constexpr int64_t UNIFORM_TYPE_UNIFORM_BUFFER = 7;
    static constexpr int64_t UNIFORM_TYPE_STORAGE_BUFFER = 8;
    static constexpr int64_t UNIFORM_TYPE_INPUT_ATTACHMENT = 9;
    static constexpr int64_t UNIFORM_TYPE_MAX = 10;
    static constexpr int64_t RENDER_PRIMITIVE_POINTS = 0;
    static constexpr int64_t RENDER_PRIMITIVE_LINES = 1;
    static constexpr int64_t RENDER_PRIMITIVE_LINES_WITH_ADJACENCY = 2;
    static constexpr int64_t RENDER_PRIMITIVE_LINESTRIPS = 3;
    static constexpr int64_t RENDER_PRIMITIVE_LINESTRIPS_WITH_ADJACENCY = 4;
    static constexpr int64_t RENDER_PRIMITIVE_TRIANGLES = 5;
    static constexpr int64_t RENDER_PRIMITIVE_TRIANGLES_WITH_ADJACENCY = 6;
    static constexpr int64_t RENDER_PRIMITIVE_TRIANGLE_STRIPS = 7;
    static constexpr int64_t RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_AJACENCY = 8;
    static constexpr int64_t RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_RESTART_INDEX = 9;
    static constexpr int64_t RENDER_PRIMITIVE_TESSELATION_PATCH = 10;
    static constexpr int64_t RENDER_PRIMITIVE_MAX = 11;
    static constexpr int64_t POLYGON_CULL_DISABLED = 0;
    static constexpr int64_t POLYGON_CULL_FRONT = 1;
    static constexpr int64_t POLYGON_CULL_BACK = 2;
    static constexpr int64_t POLYGON_FRONT_FACE_CLOCKWISE = 0;
    static constexpr int64_t POLYGON_FRONT_FACE_COUNTER_CLOCKWISE = 1;
    static constexpr int64_t STENCIL_OP_KEEP = 0;
    static constexpr int64_t STENCIL_OP_ZERO = 1;
    static constexpr int64_t STENCIL_OP_REPLACE = 2;
    static constexpr int64_t STENCIL_OP_INCREMENT_AND_CLAMP = 3;
    static constexpr int64_t STENCIL_OP_DECREMENT_AND_CLAMP = 4;
    static constexpr int64_t STENCIL_OP_INVERT = 5;
    static constexpr int64_t STENCIL_OP_INCREMENT_AND_WRAP = 6;
    static constexpr int64_t STENCIL_OP_DECREMENT_AND_WRAP = 7;
    static constexpr int64_t STENCIL_OP_MAX = 8;
    static constexpr int64_t COMPARE_OP_NEVER = 0;
    static constexpr int64_t COMPARE_OP_LESS = 1;
    static constexpr int64_t COMPARE_OP_EQUAL = 2;
    static constexpr int64_t COMPARE_OP_LESS_OR_EQUAL = 3;
    static constexpr int64_t COMPARE_OP_GREATER = 4;
    static constexpr int64_t COMPARE_OP_NOT_EQUAL = 5;
    static constexpr int64_t COMPARE_OP_GREATER_OR_EQUAL = 6;
    static constexpr int64_t COMPARE_OP_ALWAYS = 7;
    static constexpr int64_t COMPARE_OP_MAX = 8;
    static constexpr int64_t LOGIC_OP_CLEAR = 0;
    static constexpr int64_t LOGIC_OP_AND = 1;
    static constexpr int64_t LOGIC_OP_AND_REVERSE = 2;
    static constexpr int64_t LOGIC_OP_COPY = 3;
    static constexpr int64_t LOGIC_OP_AND_INVERTED = 4;
    static constexpr int64_t LOGIC_OP_NO_OP = 5;
    static constexpr int64_t LOGIC_OP_XOR = 6;
    static constexpr int64_t LOGIC_OP_OR = 7;
    static constexpr int64_t LOGIC_OP_NOR = 8;
    static constexpr int64_t LOGIC_OP_EQUIVALENT = 9;
    static constexpr int64_t LOGIC_OP_INVERT = 10;
    static constexpr int64_t LOGIC_OP_OR_REVERSE = 11;
    static constexpr int64_t LOGIC_OP_COPY_INVERTED = 12;
    static constexpr int64_t LOGIC_OP_OR_INVERTED = 13;
    static constexpr int64_t LOGIC_OP_NAND = 14;
    static constexpr int64_t LOGIC_OP_SET = 15;
    static constexpr int64_t LOGIC_OP_MAX = 16;
    static constexpr int64_t BLEND_FACTOR_ZERO = 0;
    static constexpr int64_t BLEND_FACTOR_ONE = 1;
    static constexpr int64_t BLEND_FACTOR_SRC_COLOR = 2;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3;
    static constexpr int64_t BLEND_FACTOR_DST_COLOR = 4;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5;
    static constexpr int64_t BLEND_FACTOR_SRC_ALPHA = 6;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7;
    static constexpr int64_t BLEND_FACTOR_DST_ALPHA = 8;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9;
    static constexpr int64_t BLEND_FACTOR_CONSTANT_COLOR = 10;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11;
    static constexpr int64_t BLEND_FACTOR_CONSTANT_ALPHA = 12;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13;
    static constexpr int64_t BLEND_FACTOR_SRC_ALPHA_SATURATE = 14;
    static constexpr int64_t BLEND_FACTOR_SRC1_COLOR = 15;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16;
    static constexpr int64_t BLEND_FACTOR_SRC1_ALPHA = 17;
    static constexpr int64_t BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18;
    static constexpr int64_t BLEND_FACTOR_MAX = 19;
    static constexpr int64_t BLEND_OP_ADD = 0;
    static constexpr int64_t BLEND_OP_SUBTRACT = 1;
    static constexpr int64_t BLEND_OP_REVERSE_SUBTRACT = 2;
    static constexpr int64_t BLEND_OP_MINIMUM = 3;
    static constexpr int64_t BLEND_OP_MAXIMUM = 4;
    static constexpr int64_t BLEND_OP_MAX = 5;
    static constexpr int64_t DYNAMIC_STATE_LINE_WIDTH = 1;
    static constexpr int64_t DYNAMIC_STATE_DEPTH_BIAS = 2;
    static constexpr int64_t DYNAMIC_STATE_BLEND_CONSTANTS = 4;
    static constexpr int64_t DYNAMIC_STATE_DEPTH_BOUNDS = 8;
    static constexpr int64_t DYNAMIC_STATE_STENCIL_COMPARE_MASK = 16;
    static constexpr int64_t DYNAMIC_STATE_STENCIL_WRITE_MASK = 32;
    static constexpr int64_t DYNAMIC_STATE_STENCIL_REFERENCE = 64;
    static constexpr int64_t INITIAL_ACTION_LOAD = 0;
    static constexpr int64_t INITIAL_ACTION_CLEAR = 1;
    static constexpr int64_t INITIAL_ACTION_DISCARD = 2;
    static constexpr int64_t INITIAL_ACTION_MAX = 3;
    static constexpr int64_t INITIAL_ACTION_CLEAR_REGION = 1;
    static constexpr int64_t INITIAL_ACTION_CLEAR_REGION_CONTINUE = 1;
    static constexpr int64_t INITIAL_ACTION_KEEP = 0;
    static constexpr int64_t INITIAL_ACTION_DROP = 2;
    static constexpr int64_t INITIAL_ACTION_CONTINUE = 0;
    static constexpr int64_t FINAL_ACTION_STORE = 0;
    static constexpr int64_t FINAL_ACTION_DISCARD = 1;
    static constexpr int64_t FINAL_ACTION_MAX = 2;
    static constexpr int64_t FINAL_ACTION_READ = 0;
    static constexpr int64_t FINAL_ACTION_CONTINUE = 0;
    static constexpr int64_t SHADER_STAGE_VERTEX = 0;
    static constexpr int64_t SHADER_STAGE_FRAGMENT = 1;
    static constexpr int64_t SHADER_STAGE_TESSELATION_CONTROL = 2;
    static constexpr int64_t SHADER_STAGE_TESSELATION_EVALUATION = 3;
    static constexpr int64_t SHADER_STAGE_COMPUTE = 4;
    static constexpr int64_t SHADER_STAGE_MAX = 5;
    static constexpr int64_t SHADER_STAGE_VERTEX_BIT = 1;
    static constexpr int64_t SHADER_STAGE_FRAGMENT_BIT = 2;
    static constexpr int64_t SHADER_STAGE_TESSELATION_CONTROL_BIT = 4;
    static constexpr int64_t SHADER_STAGE_TESSELATION_EVALUATION_BIT = 8;
    static constexpr int64_t SHADER_STAGE_COMPUTE_BIT = 16;
    static constexpr int64_t SHADER_LANGUAGE_GLSL = 0;
    static constexpr int64_t SHADER_LANGUAGE_HLSL = 1;
    static constexpr int64_t PIPELINE_SPECIALIZATION_CONSTANT_TYPE_BOOL = 0;
    static constexpr int64_t PIPELINE_SPECIALIZATION_CONSTANT_TYPE_INT = 1;
    static constexpr int64_t PIPELINE_SPECIALIZATION_CONSTANT_TYPE_FLOAT = 2;
    static constexpr int64_t LIMIT_MAX_BOUND_UNIFORM_SETS = 0;
    static constexpr int64_t LIMIT_MAX_FRAMEBUFFER_COLOR_ATTACHMENTS = 1;
    static constexpr int64_t LIMIT_MAX_TEXTURES_PER_UNIFORM_SET = 2;
    static constexpr int64_t LIMIT_MAX_SAMPLERS_PER_UNIFORM_SET = 3;
    static constexpr int64_t LIMIT_MAX_STORAGE_BUFFERS_PER_UNIFORM_SET = 4;
    static constexpr int64_t LIMIT_MAX_STORAGE_IMAGES_PER_UNIFORM_SET = 5;
    static constexpr int64_t LIMIT_MAX_UNIFORM_BUFFERS_PER_UNIFORM_SET = 6;
    static constexpr int64_t LIMIT_MAX_DRAW_INDEXED_INDEX = 7;
    static constexpr int64_t LIMIT_MAX_FRAMEBUFFER_HEIGHT = 8;
    static constexpr int64_t LIMIT_MAX_FRAMEBUFFER_WIDTH = 9;
    static constexpr int64_t LIMIT_MAX_TEXTURE_ARRAY_LAYERS = 10;
    static constexpr int64_t LIMIT_MAX_TEXTURE_SIZE_1D = 11;
    static constexpr int64_t LIMIT_MAX_TEXTURE_SIZE_2D = 12;
    static constexpr int64_t LIMIT_MAX_TEXTURE_SIZE_3D = 13;
    static constexpr int64_t LIMIT_MAX_TEXTURE_SIZE_CUBE = 14;
    static constexpr int64_t LIMIT_MAX_TEXTURES_PER_SHADER_STAGE = 15;
    static constexpr int64_t LIMIT_MAX_SAMPLERS_PER_SHADER_STAGE = 16;
    static constexpr int64_t LIMIT_MAX_STORAGE_BUFFERS_PER_SHADER_STAGE = 17;
    static constexpr int64_t LIMIT_MAX_STORAGE_IMAGES_PER_SHADER_STAGE = 18;
    static constexpr int64_t LIMIT_MAX_UNIFORM_BUFFERS_PER_SHADER_STAGE = 19;
    static constexpr int64_t LIMIT_MAX_PUSH_CONSTANT_SIZE = 20;
    static constexpr int64_t LIMIT_MAX_UNIFORM_BUFFER_SIZE = 21;
    static constexpr int64_t LIMIT_MAX_VERTEX_INPUT_ATTRIBUTE_OFFSET = 22;
    static constexpr int64_t LIMIT_MAX_VERTEX_INPUT_ATTRIBUTES = 23;
    static constexpr int64_t LIMIT_MAX_VERTEX_INPUT_BINDINGS = 24;
    static constexpr int64_t LIMIT_MAX_VERTEX_INPUT_BINDING_STRIDE = 25;
    static constexpr int64_t LIMIT_MIN_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 26;
    static constexpr int64_t LIMIT_MAX_COMPUTE_SHARED_MEMORY_SIZE = 27;
    static constexpr int64_t LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_X = 28;
    static constexpr int64_t LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Y = 29;
    static constexpr int64_t LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Z = 30;
    static constexpr int64_t LIMIT_MAX_COMPUTE_WORKGROUP_INVOCATIONS = 31;
    static constexpr int64_t LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_X = 32;
    static constexpr int64_t LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Y = 33;
    static constexpr int64_t LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Z = 34;
    static constexpr int64_t LIMIT_MAX_VIEWPORT_DIMENSIONS_X = 35;
    static constexpr int64_t LIMIT_MAX_VIEWPORT_DIMENSIONS_Y = 36;
    static constexpr int64_t MEMORY_TEXTURES = 0;
    static constexpr int64_t MEMORY_BUFFERS = 1;
    static constexpr int64_t MEMORY_TOTAL = 2;
    static constexpr int64_t INVALID_ID = -1;
    static constexpr int64_t INVALID_FORMAT_ID = -1;
};
struct RenderingServer : public Object {
    using Object::Object;
    PROPERTY(render_loop_enabled, bool);
    METHOD(::RID, texture_2d_create);
    METHOD(::RID, texture_2d_layered_create);
    METHOD(::RID, texture_3d_create);
    METHOD(::RID, texture_proxy_create);
    METHOD(Variant, texture_2d_update);
    METHOD(Variant, texture_3d_update);
    METHOD(Variant, texture_proxy_update);
    METHOD(::RID, texture_2d_placeholder_create);
    METHOD(::RID, texture_2d_layered_placeholder_create);
    METHOD(::RID, texture_3d_placeholder_create);
    METHOD(Object, texture_2d_get);
    METHOD(Object, texture_2d_layer_get);
    METHOD(Array, texture_3d_get);
    METHOD(Variant, texture_replace);
    METHOD(Variant, texture_set_size_override);
    METHOD(Variant, texture_set_path);
    METHOD(String, texture_get_path);
    METHOD(int64_t, texture_get_format);
    METHOD(Variant, texture_set_force_redraw_if_visible);
    METHOD(::RID, texture_rd_create);
    METHOD(::RID, texture_get_rd_texture);
    METHOD(int64_t, texture_get_native_handle);
    METHOD(::RID, shader_create);
    METHOD(Variant, shader_set_code);
    METHOD(Variant, shader_set_path_hint);
    METHOD(String, shader_get_code);
    METHOD(Array, get_shader_parameter_list);
    METHOD(Variant, shader_get_parameter_default);
    METHOD(Variant, shader_set_default_texture_parameter);
    METHOD(::RID, shader_get_default_texture_parameter);
    METHOD(::RID, material_create);
    METHOD(Variant, material_set_shader);
    METHOD(Variant, material_set_param);
    METHOD(Variant, material_get_param);
    METHOD(Variant, material_set_render_priority);
    METHOD(Variant, material_set_next_pass);
    METHOD(::RID, mesh_create_from_surfaces);
    METHOD(::RID, mesh_create);
    METHOD(int64_t, mesh_surface_get_format_offset);
    METHOD(int64_t, mesh_surface_get_format_vertex_stride);
    METHOD(int64_t, mesh_surface_get_format_normal_tangent_stride);
    METHOD(int64_t, mesh_surface_get_format_attribute_stride);
    METHOD(int64_t, mesh_surface_get_format_skin_stride);
    METHOD(Variant, mesh_add_surface);
    METHOD(Variant, mesh_add_surface_from_arrays);
    METHOD(int64_t, mesh_get_blend_shape_count);
    METHOD(Variant, mesh_set_blend_shape_mode);
    METHOD(int64_t, mesh_get_blend_shape_mode);
    METHOD(Variant, mesh_surface_set_material);
    METHOD(::RID, mesh_surface_get_material);
    METHOD(Dictionary, mesh_get_surface);
    METHOD(Array, mesh_surface_get_arrays);
    METHOD(Array, mesh_surface_get_blend_shape_arrays);
    METHOD(int64_t, mesh_get_surface_count);
    METHOD(Variant, mesh_set_custom_aabb);
    METHOD(Variant, mesh_get_custom_aabb);
    METHOD(Variant, mesh_clear);
    METHOD(Variant, mesh_surface_update_vertex_region);
    METHOD(Variant, mesh_surface_update_attribute_region);
    METHOD(Variant, mesh_surface_update_skin_region);
    METHOD(Variant, mesh_set_shadow_mesh);
    METHOD(::RID, multimesh_create);
    METHOD(Variant, multimesh_allocate_data);
    METHOD(int64_t, multimesh_get_instance_count);
    METHOD(Variant, multimesh_set_mesh);
    METHOD(Variant, multimesh_instance_set_transform);
    METHOD(Variant, multimesh_instance_set_transform_2d);
    METHOD(Variant, multimesh_instance_set_color);
    METHOD(Variant, multimesh_instance_set_custom_data);
    METHOD(::RID, multimesh_get_mesh);
    METHOD(Variant, multimesh_get_aabb);
    METHOD(Variant, multimesh_set_custom_aabb);
    METHOD(Variant, multimesh_get_custom_aabb);
    METHOD(Transform3D, multimesh_instance_get_transform);
    METHOD(Transform2D, multimesh_instance_get_transform_2d);
    METHOD(Color, multimesh_instance_get_color);
    METHOD(Color, multimesh_instance_get_custom_data);
    METHOD(Variant, multimesh_set_visible_instances);
    METHOD(int64_t, multimesh_get_visible_instances);
    METHOD(Variant, multimesh_set_buffer);
    METHOD(PackedArray<float>, multimesh_get_buffer);
    METHOD(::RID, skeleton_create);
    METHOD(Variant, skeleton_allocate_data);
    METHOD(int64_t, skeleton_get_bone_count);
    METHOD(Variant, skeleton_bone_set_transform);
    METHOD(Transform3D, skeleton_bone_get_transform);
    METHOD(Variant, skeleton_bone_set_transform_2d);
    METHOD(Transform2D, skeleton_bone_get_transform_2d);
    METHOD(Variant, skeleton_set_base_transform_2d);
    METHOD(::RID, directional_light_create);
    METHOD(::RID, omni_light_create);
    METHOD(::RID, spot_light_create);
    METHOD(Variant, light_set_color);
    METHOD(Variant, light_set_param);
    METHOD(Variant, light_set_shadow);
    METHOD(Variant, light_set_projector);
    METHOD(Variant, light_set_negative);
    METHOD(Variant, light_set_cull_mask);
    METHOD(Variant, light_set_distance_fade);
    METHOD(Variant, light_set_reverse_cull_face_mode);
    METHOD(Variant, light_set_bake_mode);
    METHOD(Variant, light_set_max_sdfgi_cascade);
    METHOD(Variant, light_omni_set_shadow_mode);
    METHOD(Variant, light_directional_set_shadow_mode);
    METHOD(Variant, light_directional_set_blend_splits);
    METHOD(Variant, light_directional_set_sky_mode);
    METHOD(Variant, light_projectors_set_filter);
    METHOD(Variant, positional_soft_shadow_filter_set_quality);
    METHOD(Variant, directional_soft_shadow_filter_set_quality);
    METHOD(Variant, directional_shadow_atlas_set_size);
    METHOD(::RID, reflection_probe_create);
    METHOD(Variant, reflection_probe_set_update_mode);
    METHOD(Variant, reflection_probe_set_intensity);
    METHOD(Variant, reflection_probe_set_ambient_mode);
    METHOD(Variant, reflection_probe_set_ambient_color);
    METHOD(Variant, reflection_probe_set_ambient_energy);
    METHOD(Variant, reflection_probe_set_max_distance);
    METHOD(Variant, reflection_probe_set_size);
    METHOD(Variant, reflection_probe_set_origin_offset);
    METHOD(Variant, reflection_probe_set_as_interior);
    METHOD(Variant, reflection_probe_set_enable_box_projection);
    METHOD(Variant, reflection_probe_set_enable_shadows);
    METHOD(Variant, reflection_probe_set_cull_mask);
    METHOD(Variant, reflection_probe_set_reflection_mask);
    METHOD(Variant, reflection_probe_set_resolution);
    METHOD(Variant, reflection_probe_set_mesh_lod_threshold);
    METHOD(::RID, decal_create);
    METHOD(Variant, decal_set_size);
    METHOD(Variant, decal_set_texture);
    METHOD(Variant, decal_set_emission_energy);
    METHOD(Variant, decal_set_albedo_mix);
    METHOD(Variant, decal_set_modulate);
    METHOD(Variant, decal_set_cull_mask);
    METHOD(Variant, decal_set_distance_fade);
    METHOD(Variant, decal_set_fade);
    METHOD(Variant, decal_set_normal_fade);
    METHOD(Variant, decals_set_filter);
    METHOD(Variant, gi_set_use_half_resolution);
    METHOD(::RID, voxel_gi_create);
    METHOD(Variant, voxel_gi_allocate_data);
    METHOD(Vector3i, voxel_gi_get_octree_size);
    METHOD(PackedArray<uint8_t>, voxel_gi_get_octree_cells);
    METHOD(PackedArray<uint8_t>, voxel_gi_get_data_cells);
    METHOD(PackedArray<uint8_t>, voxel_gi_get_distance_field);
    METHOD(PackedArray<int32_t>, voxel_gi_get_level_counts);
    METHOD(Transform3D, voxel_gi_get_to_cell_xform);
    METHOD(Variant, voxel_gi_set_dynamic_range);
    METHOD(Variant, voxel_gi_set_propagation);
    METHOD(Variant, voxel_gi_set_energy);
    METHOD(Variant, voxel_gi_set_baked_exposure_normalization);
    METHOD(Variant, voxel_gi_set_bias);
    METHOD(Variant, voxel_gi_set_normal_bias);
    METHOD(Variant, voxel_gi_set_interior);
    METHOD(Variant, voxel_gi_set_use_two_bounces);
    METHOD(Variant, voxel_gi_set_quality);
    METHOD(::RID, lightmap_create);
    METHOD(Variant, lightmap_set_textures);
    METHOD(Variant, lightmap_set_probe_bounds);
    METHOD(Variant, lightmap_set_probe_interior);
    METHOD(Variant, lightmap_set_probe_capture_data);
    METHOD(PackedArray<Vector3>, lightmap_get_probe_capture_points);
    METHOD(PackedArray<Color>, lightmap_get_probe_capture_sh);
    METHOD(PackedArray<int32_t>, lightmap_get_probe_capture_tetrahedra);
    METHOD(PackedArray<int32_t>, lightmap_get_probe_capture_bsp_tree);
    METHOD(Variant, lightmap_set_baked_exposure_normalization);
    METHOD(Variant, lightmap_set_probe_capture_update_speed);
    METHOD(::RID, particles_create);
    METHOD(Variant, particles_set_mode);
    METHOD(Variant, particles_set_emitting);
    METHOD(bool, particles_get_emitting);
    METHOD(Variant, particles_set_amount);
    METHOD(Variant, particles_set_amount_ratio);
    METHOD(Variant, particles_set_lifetime);
    METHOD(Variant, particles_set_one_shot);
    METHOD(Variant, particles_set_pre_process_time);
    METHOD(Variant, particles_set_explosiveness_ratio);
    METHOD(Variant, particles_set_randomness_ratio);
    METHOD(Variant, particles_set_interp_to_end);
    METHOD(Variant, particles_set_emitter_velocity);
    METHOD(Variant, particles_set_custom_aabb);
    METHOD(Variant, particles_set_speed_scale);
    METHOD(Variant, particles_set_use_local_coordinates);
    METHOD(Variant, particles_set_process_material);
    METHOD(Variant, particles_set_fixed_fps);
    METHOD(Variant, particles_set_interpolate);
    METHOD(Variant, particles_set_fractional_delta);
    METHOD(Variant, particles_set_collision_base_size);
    METHOD(Variant, particles_set_transform_align);
    METHOD(Variant, particles_set_trails);
    METHOD(Variant, particles_set_trail_bind_poses);
    METHOD(bool, particles_is_inactive);
    METHOD(Variant, particles_request_process);
    METHOD(Variant, particles_restart);
    METHOD(Variant, particles_set_subemitter);
    METHOD(Variant, particles_emit);
    METHOD(Variant, particles_set_draw_order);
    METHOD(Variant, particles_set_draw_passes);
    METHOD(Variant, particles_set_draw_pass_mesh);
    METHOD(Variant, particles_get_current_aabb);
    METHOD(Variant, particles_set_emission_transform);
    METHOD(::RID, particles_collision_create);
    METHOD(Variant, particles_collision_set_collision_type);
    METHOD(Variant, particles_collision_set_cull_mask);
    METHOD(Variant, particles_collision_set_sphere_radius);
    METHOD(Variant, particles_collision_set_box_extents);
    METHOD(Variant, particles_collision_set_attractor_strength);
    METHOD(Variant, particles_collision_set_attractor_directionality);
    METHOD(Variant, particles_collision_set_attractor_attenuation);
    METHOD(Variant, particles_collision_set_field_texture);
    METHOD(Variant, particles_collision_height_field_update);
    METHOD(Variant, particles_collision_set_height_field_resolution);
    METHOD(::RID, fog_volume_create);
    METHOD(Variant, fog_volume_set_shape);
    METHOD(Variant, fog_volume_set_size);
    METHOD(Variant, fog_volume_set_material);
    METHOD(::RID, visibility_notifier_create);
    METHOD(Variant, visibility_notifier_set_aabb);
    METHOD(Variant, visibility_notifier_set_callbacks);
    METHOD(::RID, occluder_create);
    METHOD(Variant, occluder_set_mesh);
    METHOD(::RID, camera_create);
    METHOD(Variant, camera_set_perspective);
    METHOD(Variant, camera_set_orthogonal);
    METHOD(Variant, camera_set_frustum);
    METHOD(Variant, camera_set_transform);
    METHOD(Variant, camera_set_cull_mask);
    METHOD(Variant, camera_set_environment);
    METHOD(Variant, camera_set_camera_attributes);
    METHOD(Variant, camera_set_compositor);
    METHOD(Variant, camera_set_use_vertical_aspect);
    METHOD(::RID, viewport_create);
    METHOD(Variant, viewport_set_use_xr);
    METHOD(Variant, viewport_set_size);
    METHOD(Variant, viewport_set_active);
    METHOD(Variant, viewport_set_parent_viewport);
    METHOD(Variant, viewport_attach_to_screen);
    METHOD(Variant, viewport_set_render_direct_to_screen);
    METHOD(Variant, viewport_set_canvas_cull_mask);
    METHOD(Variant, viewport_set_scaling_3d_mode);
    METHOD(Variant, viewport_set_scaling_3d_scale);
    METHOD(Variant, viewport_set_fsr_sharpness);
    METHOD(Variant, viewport_set_texture_mipmap_bias);
    METHOD(Variant, viewport_set_update_mode);
    METHOD(int64_t, viewport_get_update_mode);
    METHOD(Variant, viewport_set_clear_mode);
    METHOD(::RID, viewport_get_render_target);
    METHOD(::RID, viewport_get_texture);
    METHOD(Variant, viewport_set_disable_3d);
    METHOD(Variant, viewport_set_disable_2d);
    METHOD(Variant, viewport_set_environment_mode);
    METHOD(Variant, viewport_attach_camera);
    METHOD(Variant, viewport_set_scenario);
    METHOD(Variant, viewport_attach_canvas);
    METHOD(Variant, viewport_remove_canvas);
    METHOD(Variant, viewport_set_snap_2d_transforms_to_pixel);
    METHOD(Variant, viewport_set_snap_2d_vertices_to_pixel);
    METHOD(Variant, viewport_set_default_canvas_item_texture_filter);
    METHOD(Variant, viewport_set_default_canvas_item_texture_repeat);
    METHOD(Variant, viewport_set_canvas_transform);
    METHOD(Variant, viewport_set_canvas_stacking);
    METHOD(Variant, viewport_set_transparent_background);
    METHOD(Variant, viewport_set_global_canvas_transform);
    METHOD(Variant, viewport_set_sdf_oversize_and_scale);
    METHOD(Variant, viewport_set_positional_shadow_atlas_size);
    METHOD(Variant, viewport_set_positional_shadow_atlas_quadrant_subdivision);
    METHOD(Variant, viewport_set_msaa_3d);
    METHOD(Variant, viewport_set_msaa_2d);
    METHOD(Variant, viewport_set_use_hdr_2d);
    METHOD(Variant, viewport_set_screen_space_aa);
    METHOD(Variant, viewport_set_use_taa);
    METHOD(Variant, viewport_set_use_debanding);
    METHOD(Variant, viewport_set_use_occlusion_culling);
    METHOD(Variant, viewport_set_occlusion_rays_per_thread);
    METHOD(Variant, viewport_set_occlusion_culling_build_quality);
    METHOD(int64_t, viewport_get_render_info);
    METHOD(Variant, viewport_set_debug_draw);
    METHOD(Variant, viewport_set_measure_render_time);
    METHOD(double, viewport_get_measured_render_time_cpu);
    METHOD(double, viewport_get_measured_render_time_gpu);
    METHOD(Variant, viewport_set_vrs_mode);
    METHOD(Variant, viewport_set_vrs_update_mode);
    METHOD(Variant, viewport_set_vrs_texture);
    METHOD(::RID, sky_create);
    METHOD(Variant, sky_set_radiance_size);
    METHOD(Variant, sky_set_mode);
    METHOD(Variant, sky_set_material);
    METHOD(Object, sky_bake_panorama);
    METHOD(::RID, compositor_effect_create);
    METHOD(Variant, compositor_effect_set_enabled);
    METHOD(Variant, compositor_effect_set_callback);
    METHOD(Variant, compositor_effect_set_flag);
    METHOD(::RID, compositor_create);
    METHOD(Variant, compositor_set_compositor_effects);
    METHOD(::RID, environment_create);
    METHOD(Variant, environment_set_background);
    METHOD(Variant, environment_set_sky);
    METHOD(Variant, environment_set_sky_custom_fov);
    METHOD(Variant, environment_set_sky_orientation);
    METHOD(Variant, environment_set_bg_color);
    METHOD(Variant, environment_set_bg_energy);
    METHOD(Variant, environment_set_canvas_max_layer);
    METHOD(Variant, environment_set_ambient_light);
    METHOD(Variant, environment_set_glow);
    METHOD(Variant, environment_set_tonemap);
    METHOD(Variant, environment_set_adjustment);
    METHOD(Variant, environment_set_ssr);
    METHOD(Variant, environment_set_ssao);
    METHOD(Variant, environment_set_fog);
    METHOD(Variant, environment_set_sdfgi);
    METHOD(Variant, environment_set_volumetric_fog);
    METHOD(Variant, environment_glow_set_use_bicubic_upscale);
    METHOD(Variant, environment_set_ssr_roughness_quality);
    METHOD(Variant, environment_set_ssao_quality);
    METHOD(Variant, environment_set_ssil_quality);
    METHOD(Variant, environment_set_sdfgi_ray_count);
    METHOD(Variant, environment_set_sdfgi_frames_to_converge);
    METHOD(Variant, environment_set_sdfgi_frames_to_update_light);
    METHOD(Variant, environment_set_volumetric_fog_volume_size);
    METHOD(Variant, environment_set_volumetric_fog_filter_active);
    METHOD(Object, environment_bake_panorama);
    METHOD(Variant, screen_space_roughness_limiter_set_active);
    METHOD(Variant, sub_surface_scattering_set_quality);
    METHOD(Variant, sub_surface_scattering_set_scale);
    METHOD(::RID, camera_attributes_create);
    METHOD(Variant, camera_attributes_set_dof_blur_quality);
    METHOD(Variant, camera_attributes_set_dof_blur_bokeh_shape);
    METHOD(Variant, camera_attributes_set_dof_blur);
    METHOD(Variant, camera_attributes_set_exposure);
    METHOD(Variant, camera_attributes_set_auto_exposure);
    METHOD(::RID, scenario_create);
    METHOD(Variant, scenario_set_environment);
    METHOD(Variant, scenario_set_fallback_environment);
    METHOD(Variant, scenario_set_camera_attributes);
    METHOD(Variant, scenario_set_compositor);
    METHOD(::RID, instance_create2);
    METHOD(::RID, instance_create);
    METHOD(Variant, instance_set_base);
    METHOD(Variant, instance_set_scenario);
    METHOD(Variant, instance_set_layer_mask);
    METHOD(Variant, instance_set_pivot_data);
    METHOD(Variant, instance_set_transform);
    METHOD(Variant, instance_attach_object_instance_id);
    METHOD(Variant, instance_set_blend_shape_weight);
    METHOD(Variant, instance_set_surface_override_material);
    METHOD(Variant, instance_set_visible);
    METHOD(Variant, instance_geometry_set_transparency);
    METHOD(Variant, instance_set_custom_aabb);
    METHOD(Variant, instance_attach_skeleton);
    METHOD(Variant, instance_set_extra_visibility_margin);
    METHOD(Variant, instance_set_visibility_parent);
    METHOD(Variant, instance_set_ignore_culling);
    METHOD(Variant, instance_geometry_set_flag);
    METHOD(Variant, instance_geometry_set_cast_shadows_setting);
    METHOD(Variant, instance_geometry_set_material_override);
    METHOD(Variant, instance_geometry_set_material_overlay);
    METHOD(Variant, instance_geometry_set_visibility_range);
    METHOD(Variant, instance_geometry_set_lightmap);
    METHOD(Variant, instance_geometry_set_lod_bias);
    METHOD(Variant, instance_geometry_set_shader_parameter);
    METHOD(Variant, instance_geometry_get_shader_parameter);
    METHOD(Variant, instance_geometry_get_shader_parameter_default_value);
    METHOD(Array, instance_geometry_get_shader_parameter_list);
    METHOD(PackedArray<int64_t>, instances_cull_aabb);
    METHOD(PackedArray<int64_t>, instances_cull_ray);
    METHOD(PackedArray<int64_t>, instances_cull_convex);
    METHOD(Array, bake_render_uv2);
    METHOD(::RID, canvas_create);
    METHOD(Variant, canvas_set_item_mirroring);
    METHOD(Variant, canvas_set_item_repeat);
    METHOD(Variant, canvas_set_modulate);
    METHOD(Variant, canvas_set_disable_scale);
    METHOD(::RID, canvas_texture_create);
    METHOD(Variant, canvas_texture_set_channel);
    METHOD(Variant, canvas_texture_set_shading_parameters);
    METHOD(Variant, canvas_texture_set_texture_filter);
    METHOD(Variant, canvas_texture_set_texture_repeat);
    METHOD(::RID, canvas_item_create);
    METHOD(Variant, canvas_item_set_parent);
    METHOD(Variant, canvas_item_set_default_texture_filter);
    METHOD(Variant, canvas_item_set_default_texture_repeat);
    METHOD(Variant, canvas_item_set_visible);
    METHOD(Variant, canvas_item_set_light_mask);
    METHOD(Variant, canvas_item_set_visibility_layer);
    METHOD(Variant, canvas_item_set_transform);
    METHOD(Variant, canvas_item_set_clip);
    METHOD(Variant, canvas_item_set_distance_field_mode);
    METHOD(Variant, canvas_item_set_custom_rect);
    METHOD(Variant, canvas_item_set_modulate);
    METHOD(Variant, canvas_item_set_self_modulate);
    METHOD(Variant, canvas_item_set_draw_behind_parent);
    METHOD(Variant, canvas_item_set_interpolated);
    METHOD(Variant, canvas_item_reset_physics_interpolation);
    METHOD(Variant, canvas_item_transform_physics_interpolation);
    METHOD(Variant, canvas_item_add_line);
    METHOD(Variant, canvas_item_add_polyline);
    METHOD(Variant, canvas_item_add_multiline);
    METHOD(Variant, canvas_item_add_rect);
    METHOD(Variant, canvas_item_add_circle);
    METHOD(Variant, canvas_item_add_texture_rect);
    METHOD(Variant, canvas_item_add_msdf_texture_rect_region);
    METHOD(Variant, canvas_item_add_lcd_texture_rect_region);
    METHOD(Variant, canvas_item_add_texture_rect_region);
    METHOD(Variant, canvas_item_add_nine_patch);
    METHOD(Variant, canvas_item_add_primitive);
    METHOD(Variant, canvas_item_add_polygon);
    METHOD(Variant, canvas_item_add_triangle_array);
    METHOD(Variant, canvas_item_add_mesh);
    METHOD(Variant, canvas_item_add_multimesh);
    METHOD(Variant, canvas_item_add_particles);
    METHOD(Variant, canvas_item_add_set_transform);
    METHOD(Variant, canvas_item_add_clip_ignore);
    METHOD(Variant, canvas_item_add_animation_slice);
    METHOD(Variant, canvas_item_set_sort_children_by_y);
    METHOD(Variant, canvas_item_set_z_index);
    METHOD(Variant, canvas_item_set_z_as_relative_to_parent);
    METHOD(Variant, canvas_item_set_copy_to_backbuffer);
    METHOD(Variant, canvas_item_clear);
    METHOD(Variant, canvas_item_set_draw_index);
    METHOD(Variant, canvas_item_set_material);
    METHOD(Variant, canvas_item_set_use_parent_material);
    METHOD(Variant, canvas_item_set_visibility_notifier);
    METHOD(Variant, canvas_item_set_canvas_group_mode);
    METHOD(Rect2, debug_canvas_item_get_rect);
    METHOD(::RID, canvas_light_create);
    METHOD(Variant, canvas_light_attach_to_canvas);
    METHOD(Variant, canvas_light_set_enabled);
    METHOD(Variant, canvas_light_set_texture_scale);
    METHOD(Variant, canvas_light_set_transform);
    METHOD(Variant, canvas_light_set_texture);
    METHOD(Variant, canvas_light_set_texture_offset);
    METHOD(Variant, canvas_light_set_color);
    METHOD(Variant, canvas_light_set_height);
    METHOD(Variant, canvas_light_set_energy);
    METHOD(Variant, canvas_light_set_z_range);
    METHOD(Variant, canvas_light_set_layer_range);
    METHOD(Variant, canvas_light_set_item_cull_mask);
    METHOD(Variant, canvas_light_set_item_shadow_cull_mask);
    METHOD(Variant, canvas_light_set_mode);
    METHOD(Variant, canvas_light_set_shadow_enabled);
    METHOD(Variant, canvas_light_set_shadow_filter);
    METHOD(Variant, canvas_light_set_shadow_color);
    METHOD(Variant, canvas_light_set_shadow_smooth);
    METHOD(Variant, canvas_light_set_blend_mode);
    METHOD(Variant, canvas_light_set_interpolated);
    METHOD(Variant, canvas_light_reset_physics_interpolation);
    METHOD(Variant, canvas_light_transform_physics_interpolation);
    METHOD(::RID, canvas_light_occluder_create);
    METHOD(Variant, canvas_light_occluder_attach_to_canvas);
    METHOD(Variant, canvas_light_occluder_set_enabled);
    METHOD(Variant, canvas_light_occluder_set_polygon);
    METHOD(Variant, canvas_light_occluder_set_as_sdf_collision);
    METHOD(Variant, canvas_light_occluder_set_transform);
    METHOD(Variant, canvas_light_occluder_set_light_mask);
    METHOD(Variant, canvas_light_occluder_set_interpolated);
    METHOD(Variant, canvas_light_occluder_reset_physics_interpolation);
    METHOD(Variant, canvas_light_occluder_transform_physics_interpolation);
    METHOD(::RID, canvas_occluder_polygon_create);
    METHOD(Variant, canvas_occluder_polygon_set_shape);
    METHOD(Variant, canvas_occluder_polygon_set_cull_mode);
    METHOD(Variant, canvas_set_shadow_texture_size);
    METHOD(Variant, global_shader_parameter_add);
    METHOD(Variant, global_shader_parameter_remove);
    METHOD(Array, global_shader_parameter_get_list);
    METHOD(Variant, global_shader_parameter_set);
    METHOD(Variant, global_shader_parameter_set_override);
    METHOD(Variant, global_shader_parameter_get);
    METHOD(int64_t, global_shader_parameter_get_type);
    METHOD(Variant, free_rid);
    METHOD(Variant, request_frame_drawn_callback);
    METHOD(bool, has_changed);
    METHOD(int64_t, get_rendering_info);
    METHOD(String, get_video_adapter_name);
    METHOD(String, get_video_adapter_vendor);
    METHOD(int64_t, get_video_adapter_type);
    METHOD(String, get_video_adapter_api_version);
    METHOD(::RID, make_sphere_mesh);
    METHOD(::RID, get_test_cube);
    METHOD(::RID, get_test_texture);
    METHOD(::RID, get_white_texture);
    METHOD(void, set_boot_image);
    METHOD(Color, get_default_clear_color);
    METHOD(void, set_default_clear_color);
    METHOD(bool, has_os_feature);
    METHOD(void, set_debug_generate_wireframes);
    METHOD(bool, is_render_loop_enabled);
    METHOD(void, set_render_loop_enabled);
    METHOD(double, get_frame_setup_time_cpu);
    METHOD(Variant, force_sync);
    METHOD(Variant, force_draw);
    METHOD(Object, get_rendering_device);
    METHOD(Object, create_local_rendering_device);
    METHOD(bool, is_on_render_thread);
    METHOD(Variant, call_on_render_thread);
    METHOD(bool, has_feature);
    static constexpr int64_t NO_INDEX_ARRAY = -1;
    static constexpr int64_t ARRAY_WEIGHTS_SIZE = 4;
    static constexpr int64_t CANVAS_ITEM_Z_MIN = -4096;
    static constexpr int64_t CANVAS_ITEM_Z_MAX = 4096;
    static constexpr int64_t MAX_GLOW_LEVELS = 7;
    static constexpr int64_t MAX_CURSORS = 8;
    static constexpr int64_t MAX_2D_DIRECTIONAL_LIGHTS = 8;
    static constexpr int64_t MAX_MESH_SURFACES = 256;
    static constexpr int64_t TEXTURE_LAYERED_2D_ARRAY = 0;
    static constexpr int64_t TEXTURE_LAYERED_CUBEMAP = 1;
    static constexpr int64_t TEXTURE_LAYERED_CUBEMAP_ARRAY = 2;
    static constexpr int64_t CUBEMAP_LAYER_LEFT = 0;
    static constexpr int64_t CUBEMAP_LAYER_RIGHT = 1;
    static constexpr int64_t CUBEMAP_LAYER_BOTTOM = 2;
    static constexpr int64_t CUBEMAP_LAYER_TOP = 3;
    static constexpr int64_t CUBEMAP_LAYER_FRONT = 4;
    static constexpr int64_t CUBEMAP_LAYER_BACK = 5;
    static constexpr int64_t SHADER_SPATIAL = 0;
    static constexpr int64_t SHADER_CANVAS_ITEM = 1;
    static constexpr int64_t SHADER_PARTICLES = 2;
    static constexpr int64_t SHADER_SKY = 3;
    static constexpr int64_t SHADER_FOG = 4;
    static constexpr int64_t SHADER_MAX = 5;
    static constexpr int64_t MATERIAL_RENDER_PRIORITY_MIN = -128;
    static constexpr int64_t MATERIAL_RENDER_PRIORITY_MAX = 127;
    static constexpr int64_t ARRAY_VERTEX = 0;
    static constexpr int64_t ARRAY_NORMAL = 1;
    static constexpr int64_t ARRAY_TANGENT = 2;
    static constexpr int64_t ARRAY_COLOR = 3;
    static constexpr int64_t ARRAY_TEX_UV = 4;
    static constexpr int64_t ARRAY_TEX_UV2 = 5;
    static constexpr int64_t ARRAY_CUSTOM0 = 6;
    static constexpr int64_t ARRAY_CUSTOM1 = 7;
    static constexpr int64_t ARRAY_CUSTOM2 = 8;
    static constexpr int64_t ARRAY_CUSTOM3 = 9;
    static constexpr int64_t ARRAY_BONES = 10;
    static constexpr int64_t ARRAY_WEIGHTS = 11;
    static constexpr int64_t ARRAY_INDEX = 12;
    static constexpr int64_t ARRAY_MAX = 13;
    static constexpr int64_t ARRAY_CUSTOM_COUNT = 4;
    static constexpr int64_t ARRAY_CUSTOM_RGBA8_UNORM = 0;
    static constexpr int64_t ARRAY_CUSTOM_RGBA8_SNORM = 1;
    static constexpr int64_t ARRAY_CUSTOM_RG_HALF = 2;
    static constexpr int64_t ARRAY_CUSTOM_RGBA_HALF = 3;
    static constexpr int64_t ARRAY_CUSTOM_R_FLOAT = 4;
    static constexpr int64_t ARRAY_CUSTOM_RG_FLOAT = 5;
    static constexpr int64_t ARRAY_CUSTOM_RGB_FLOAT = 6;
    static constexpr int64_t ARRAY_CUSTOM_RGBA_FLOAT = 7;
    static constexpr int64_t ARRAY_CUSTOM_MAX = 8;
    static constexpr int64_t ARRAY_FORMAT_VERTEX = 1;
    static constexpr int64_t ARRAY_FORMAT_NORMAL = 2;
    static constexpr int64_t ARRAY_FORMAT_TANGENT = 4;
    static constexpr int64_t ARRAY_FORMAT_COLOR = 8;
    static constexpr int64_t ARRAY_FORMAT_TEX_UV = 16;
    static constexpr int64_t ARRAY_FORMAT_TEX_UV2 = 32;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM0 = 64;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM1 = 128;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM2 = 256;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM3 = 512;
    static constexpr int64_t ARRAY_FORMAT_BONES = 1024;
    static constexpr int64_t ARRAY_FORMAT_WEIGHTS = 2048;
    static constexpr int64_t ARRAY_FORMAT_INDEX = 4096;
    static constexpr int64_t ARRAY_FORMAT_BLEND_SHAPE_MASK = 7;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM_BASE = 13;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM_BITS = 3;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM0_SHIFT = 13;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM1_SHIFT = 16;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM2_SHIFT = 19;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM3_SHIFT = 22;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM_MASK = 7;
    static constexpr int64_t ARRAY_COMPRESS_FLAGS_BASE = 25;
    static constexpr int64_t ARRAY_FLAG_USE_2D_VERTICES = 33554432;
    static constexpr int64_t ARRAY_FLAG_USE_DYNAMIC_UPDATE = 67108864;
    static constexpr int64_t ARRAY_FLAG_USE_8_BONE_WEIGHTS = 134217728;
    static constexpr int64_t ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY = 268435456;
    static constexpr int64_t ARRAY_FLAG_COMPRESS_ATTRIBUTES = 536870912;
    static constexpr int64_t ARRAY_FLAG_FORMAT_VERSION_BASE = 35;
    static constexpr int64_t ARRAY_FLAG_FORMAT_VERSION_SHIFT = 35;
    static constexpr int64_t ARRAY_FLAG_FORMAT_VERSION_1 = 0;
    static constexpr int64_t ARRAY_FLAG_FORMAT_VERSION_2 = 34359738368;
    static constexpr int64_t ARRAY_FLAG_FORMAT_CURRENT_VERSION = 34359738368;
    static constexpr int64_t ARRAY_FLAG_FORMAT_VERSION_MASK = 255;
    static constexpr int64_t PRIMITIVE_POINTS = 0;
    static constexpr int64_t PRIMITIVE_LINES = 1;
    static constexpr int64_t PRIMITIVE_LINE_STRIP = 2;
    static constexpr int64_t PRIMITIVE_TRIANGLES = 3;
    static constexpr int64_t PRIMITIVE_TRIANGLE_STRIP = 4;
    static constexpr int64_t PRIMITIVE_MAX = 5;
    static constexpr int64_t BLEND_SHAPE_MODE_NORMALIZED = 0;
    static constexpr int64_t BLEND_SHAPE_MODE_RELATIVE = 1;
    static constexpr int64_t MULTIMESH_TRANSFORM_2D = 0;
    static constexpr int64_t MULTIMESH_TRANSFORM_3D = 1;
    static constexpr int64_t LIGHT_PROJECTOR_FILTER_NEAREST = 0;
    static constexpr int64_t LIGHT_PROJECTOR_FILTER_LINEAR = 1;
    static constexpr int64_t LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS = 2;
    static constexpr int64_t LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS = 3;
    static constexpr int64_t LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS_ANISOTROPIC = 4;
    static constexpr int64_t LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS_ANISOTROPIC = 5;
    static constexpr int64_t LIGHT_DIRECTIONAL = 0;
    static constexpr int64_t LIGHT_OMNI = 1;
    static constexpr int64_t LIGHT_SPOT = 2;
    static constexpr int64_t LIGHT_PARAM_ENERGY = 0;
    static constexpr int64_t LIGHT_PARAM_INDIRECT_ENERGY = 1;
    static constexpr int64_t LIGHT_PARAM_VOLUMETRIC_FOG_ENERGY = 2;
    static constexpr int64_t LIGHT_PARAM_SPECULAR = 3;
    static constexpr int64_t LIGHT_PARAM_RANGE = 4;
    static constexpr int64_t LIGHT_PARAM_SIZE = 5;
    static constexpr int64_t LIGHT_PARAM_ATTENUATION = 6;
    static constexpr int64_t LIGHT_PARAM_SPOT_ANGLE = 7;
    static constexpr int64_t LIGHT_PARAM_SPOT_ATTENUATION = 8;
    static constexpr int64_t LIGHT_PARAM_SHADOW_MAX_DISTANCE = 9;
    static constexpr int64_t LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET = 10;
    static constexpr int64_t LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET = 11;
    static constexpr int64_t LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET = 12;
    static constexpr int64_t LIGHT_PARAM_SHADOW_FADE_START = 13;
    static constexpr int64_t LIGHT_PARAM_SHADOW_NORMAL_BIAS = 14;
    static constexpr int64_t LIGHT_PARAM_SHADOW_BIAS = 15;
    static constexpr int64_t LIGHT_PARAM_SHADOW_PANCAKE_SIZE = 16;
    static constexpr int64_t LIGHT_PARAM_SHADOW_OPACITY = 17;
    static constexpr int64_t LIGHT_PARAM_SHADOW_BLUR = 18;
    static constexpr int64_t LIGHT_PARAM_TRANSMITTANCE_BIAS = 19;
    static constexpr int64_t LIGHT_PARAM_INTENSITY = 20;
    static constexpr int64_t LIGHT_PARAM_MAX = 21;
    static constexpr int64_t LIGHT_BAKE_DISABLED = 0;
    static constexpr int64_t LIGHT_BAKE_STATIC = 1;
    static constexpr int64_t LIGHT_BAKE_DYNAMIC = 2;
    static constexpr int64_t LIGHT_OMNI_SHADOW_DUAL_PARABOLOID = 0;
    static constexpr int64_t LIGHT_OMNI_SHADOW_CUBE = 1;
    static constexpr int64_t LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL = 0;
    static constexpr int64_t LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS = 1;
    static constexpr int64_t LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS = 2;
    static constexpr int64_t LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_AND_SKY = 0;
    static constexpr int64_t LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_ONLY = 1;
    static constexpr int64_t LIGHT_DIRECTIONAL_SKY_MODE_SKY_ONLY = 2;
    static constexpr int64_t SHADOW_QUALITY_HARD = 0;
    static constexpr int64_t SHADOW_QUALITY_SOFT_VERY_LOW = 1;
    static constexpr int64_t SHADOW_QUALITY_SOFT_LOW = 2;
    static constexpr int64_t SHADOW_QUALITY_SOFT_MEDIUM = 3;
    static constexpr int64_t SHADOW_QUALITY_SOFT_HIGH = 4;
    static constexpr int64_t SHADOW_QUALITY_SOFT_ULTRA = 5;
    static constexpr int64_t SHADOW_QUALITY_MAX = 6;
    static constexpr int64_t REFLECTION_PROBE_UPDATE_ONCE = 0;
    static constexpr int64_t REFLECTION_PROBE_UPDATE_ALWAYS = 1;
    static constexpr int64_t REFLECTION_PROBE_AMBIENT_DISABLED = 0;
    static constexpr int64_t REFLECTION_PROBE_AMBIENT_ENVIRONMENT = 1;
    static constexpr int64_t REFLECTION_PROBE_AMBIENT_COLOR = 2;
    static constexpr int64_t DECAL_TEXTURE_ALBEDO = 0;
    static constexpr int64_t DECAL_TEXTURE_NORMAL = 1;
    static constexpr int64_t DECAL_TEXTURE_ORM = 2;
    static constexpr int64_t DECAL_TEXTURE_EMISSION = 3;
    static constexpr int64_t DECAL_TEXTURE_MAX = 4;
    static constexpr int64_t DECAL_FILTER_NEAREST = 0;
    static constexpr int64_t DECAL_FILTER_LINEAR = 1;
    static constexpr int64_t DECAL_FILTER_NEAREST_MIPMAPS = 2;
    static constexpr int64_t DECAL_FILTER_LINEAR_MIPMAPS = 3;
    static constexpr int64_t DECAL_FILTER_NEAREST_MIPMAPS_ANISOTROPIC = 4;
    static constexpr int64_t DECAL_FILTER_LINEAR_MIPMAPS_ANISOTROPIC = 5;
    static constexpr int64_t VOXEL_GI_QUALITY_LOW = 0;
    static constexpr int64_t VOXEL_GI_QUALITY_HIGH = 1;
    static constexpr int64_t PARTICLES_MODE_2D = 0;
    static constexpr int64_t PARTICLES_MODE_3D = 1;
    static constexpr int64_t PARTICLES_TRANSFORM_ALIGN_DISABLED = 0;
    static constexpr int64_t PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD = 1;
    static constexpr int64_t PARTICLES_TRANSFORM_ALIGN_Y_TO_VELOCITY = 2;
    static constexpr int64_t PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY = 3;
    static constexpr int64_t PARTICLES_EMIT_FLAG_POSITION = 1;
    static constexpr int64_t PARTICLES_EMIT_FLAG_ROTATION_SCALE = 2;
    static constexpr int64_t PARTICLES_EMIT_FLAG_VELOCITY = 4;
    static constexpr int64_t PARTICLES_EMIT_FLAG_COLOR = 8;
    static constexpr int64_t PARTICLES_EMIT_FLAG_CUSTOM = 16;
    static constexpr int64_t PARTICLES_DRAW_ORDER_INDEX = 0;
    static constexpr int64_t PARTICLES_DRAW_ORDER_LIFETIME = 1;
    static constexpr int64_t PARTICLES_DRAW_ORDER_REVERSE_LIFETIME = 2;
    static constexpr int64_t PARTICLES_DRAW_ORDER_VIEW_DEPTH = 3;
    static constexpr int64_t PARTICLES_COLLISION_TYPE_SPHERE_ATTRACT = 0;
    static constexpr int64_t PARTICLES_COLLISION_TYPE_BOX_ATTRACT = 1;
    static constexpr int64_t PARTICLES_COLLISION_TYPE_VECTOR_FIELD_ATTRACT = 2;
    static constexpr int64_t PARTICLES_COLLISION_TYPE_SPHERE_COLLIDE = 3;
    static constexpr int64_t PARTICLES_COLLISION_TYPE_BOX_COLLIDE = 4;
    static constexpr int64_t PARTICLES_COLLISION_TYPE_SDF_COLLIDE = 5;
    static constexpr int64_t PARTICLES_COLLISION_TYPE_HEIGHTFIELD_COLLIDE = 6;
    static constexpr int64_t PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_256 = 0;
    static constexpr int64_t PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_512 = 1;
    static constexpr int64_t PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_1024 = 2;
    static constexpr int64_t PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_2048 = 3;
    static constexpr int64_t PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_4096 = 4;
    static constexpr int64_t PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_8192 = 5;
    static constexpr int64_t PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_MAX = 6;
    static constexpr int64_t FOG_VOLUME_SHAPE_ELLIPSOID = 0;
    static constexpr int64_t FOG_VOLUME_SHAPE_CONE = 1;
    static constexpr int64_t FOG_VOLUME_SHAPE_CYLINDER = 2;
    static constexpr int64_t FOG_VOLUME_SHAPE_BOX = 3;
    static constexpr int64_t FOG_VOLUME_SHAPE_WORLD = 4;
    static constexpr int64_t FOG_VOLUME_SHAPE_MAX = 5;
    static constexpr int64_t VIEWPORT_SCALING_3D_MODE_BILINEAR = 0;
    static constexpr int64_t VIEWPORT_SCALING_3D_MODE_FSR = 1;
    static constexpr int64_t VIEWPORT_SCALING_3D_MODE_FSR2 = 2;
    static constexpr int64_t VIEWPORT_SCALING_3D_MODE_MAX = 3;
    static constexpr int64_t VIEWPORT_UPDATE_DISABLED = 0;
    static constexpr int64_t VIEWPORT_UPDATE_ONCE = 1;
    static constexpr int64_t VIEWPORT_UPDATE_WHEN_VISIBLE = 2;
    static constexpr int64_t VIEWPORT_UPDATE_WHEN_PARENT_VISIBLE = 3;
    static constexpr int64_t VIEWPORT_UPDATE_ALWAYS = 4;
    static constexpr int64_t VIEWPORT_CLEAR_ALWAYS = 0;
    static constexpr int64_t VIEWPORT_CLEAR_NEVER = 1;
    static constexpr int64_t VIEWPORT_CLEAR_ONLY_NEXT_FRAME = 2;
    static constexpr int64_t VIEWPORT_ENVIRONMENT_DISABLED = 0;
    static constexpr int64_t VIEWPORT_ENVIRONMENT_ENABLED = 1;
    static constexpr int64_t VIEWPORT_ENVIRONMENT_INHERIT = 2;
    static constexpr int64_t VIEWPORT_ENVIRONMENT_MAX = 3;
    static constexpr int64_t VIEWPORT_SDF_OVERSIZE_100_PERCENT = 0;
    static constexpr int64_t VIEWPORT_SDF_OVERSIZE_120_PERCENT = 1;
    static constexpr int64_t VIEWPORT_SDF_OVERSIZE_150_PERCENT = 2;
    static constexpr int64_t VIEWPORT_SDF_OVERSIZE_200_PERCENT = 3;
    static constexpr int64_t VIEWPORT_SDF_OVERSIZE_MAX = 4;
    static constexpr int64_t VIEWPORT_SDF_SCALE_100_PERCENT = 0;
    static constexpr int64_t VIEWPORT_SDF_SCALE_50_PERCENT = 1;
    static constexpr int64_t VIEWPORT_SDF_SCALE_25_PERCENT = 2;
    static constexpr int64_t VIEWPORT_SDF_SCALE_MAX = 3;
    static constexpr int64_t VIEWPORT_MSAA_DISABLED = 0;
    static constexpr int64_t VIEWPORT_MSAA_2X = 1;
    static constexpr int64_t VIEWPORT_MSAA_4X = 2;
    static constexpr int64_t VIEWPORT_MSAA_8X = 3;
    static constexpr int64_t VIEWPORT_MSAA_MAX = 4;
    static constexpr int64_t VIEWPORT_SCREEN_SPACE_AA_DISABLED = 0;
    static constexpr int64_t VIEWPORT_SCREEN_SPACE_AA_FXAA = 1;
    static constexpr int64_t VIEWPORT_SCREEN_SPACE_AA_MAX = 2;
    static constexpr int64_t VIEWPORT_OCCLUSION_BUILD_QUALITY_LOW = 0;
    static constexpr int64_t VIEWPORT_OCCLUSION_BUILD_QUALITY_MEDIUM = 1;
    static constexpr int64_t VIEWPORT_OCCLUSION_BUILD_QUALITY_HIGH = 2;
    static constexpr int64_t VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME = 0;
    static constexpr int64_t VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME = 1;
    static constexpr int64_t VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME = 2;
    static constexpr int64_t VIEWPORT_RENDER_INFO_MAX = 3;
    static constexpr int64_t VIEWPORT_RENDER_INFO_TYPE_VISIBLE = 0;
    static constexpr int64_t VIEWPORT_RENDER_INFO_TYPE_SHADOW = 1;
    static constexpr int64_t VIEWPORT_RENDER_INFO_TYPE_CANVAS = 2;
    static constexpr int64_t VIEWPORT_RENDER_INFO_TYPE_MAX = 3;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_DISABLED = 0;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_UNSHADED = 1;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_LIGHTING = 2;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_OVERDRAW = 3;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_WIREFRAME = 4;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_NORMAL_BUFFER = 5;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_VOXEL_GI_ALBEDO = 6;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_VOXEL_GI_LIGHTING = 7;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_VOXEL_GI_EMISSION = 8;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_SHADOW_ATLAS = 9;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS = 10;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_SCENE_LUMINANCE = 11;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_SSAO = 12;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_SSIL = 13;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_PSSM_SPLITS = 14;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_DECAL_ATLAS = 15;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_SDFGI = 16;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_SDFGI_PROBES = 17;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_GI_BUFFER = 18;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_DISABLE_LOD = 19;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_CLUSTER_OMNI_LIGHTS = 20;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_CLUSTER_SPOT_LIGHTS = 21;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_CLUSTER_DECALS = 22;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_CLUSTER_REFLECTION_PROBES = 23;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_OCCLUDERS = 24;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_MOTION_VECTORS = 25;
    static constexpr int64_t VIEWPORT_DEBUG_DRAW_INTERNAL_BUFFER = 26;
    static constexpr int64_t VIEWPORT_VRS_DISABLED = 0;
    static constexpr int64_t VIEWPORT_VRS_TEXTURE = 1;
    static constexpr int64_t VIEWPORT_VRS_XR = 2;
    static constexpr int64_t VIEWPORT_VRS_MAX = 3;
    static constexpr int64_t VIEWPORT_VRS_UPDATE_DISABLED = 0;
    static constexpr int64_t VIEWPORT_VRS_UPDATE_ONCE = 1;
    static constexpr int64_t VIEWPORT_VRS_UPDATE_ALWAYS = 2;
    static constexpr int64_t VIEWPORT_VRS_UPDATE_MAX = 3;
    static constexpr int64_t SKY_MODE_AUTOMATIC = 0;
    static constexpr int64_t SKY_MODE_QUALITY = 1;
    static constexpr int64_t SKY_MODE_INCREMENTAL = 2;
    static constexpr int64_t SKY_MODE_REALTIME = 3;
    static constexpr int64_t COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_COLOR = 1;
    static constexpr int64_t COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_DEPTH = 2;
    static constexpr int64_t COMPOSITOR_EFFECT_FLAG_NEEDS_MOTION_VECTORS = 4;
    static constexpr int64_t COMPOSITOR_EFFECT_FLAG_NEEDS_ROUGHNESS = 8;
    static constexpr int64_t COMPOSITOR_EFFECT_FLAG_NEEDS_SEPARATE_SPECULAR = 16;
    static constexpr int64_t COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_OPAQUE = 0;
    static constexpr int64_t COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_OPAQUE = 1;
    static constexpr int64_t COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_SKY = 2;
    static constexpr int64_t COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT = 3;
    static constexpr int64_t COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_TRANSPARENT = 4;
    static constexpr int64_t COMPOSITOR_EFFECT_CALLBACK_TYPE_ANY = -1;
    static constexpr int64_t ENV_BG_CLEAR_COLOR = 0;
    static constexpr int64_t ENV_BG_COLOR = 1;
    static constexpr int64_t ENV_BG_SKY = 2;
    static constexpr int64_t ENV_BG_CANVAS = 3;
    static constexpr int64_t ENV_BG_KEEP = 4;
    static constexpr int64_t ENV_BG_CAMERA_FEED = 5;
    static constexpr int64_t ENV_BG_MAX = 6;
    static constexpr int64_t ENV_AMBIENT_SOURCE_BG = 0;
    static constexpr int64_t ENV_AMBIENT_SOURCE_DISABLED = 1;
    static constexpr int64_t ENV_AMBIENT_SOURCE_COLOR = 2;
    static constexpr int64_t ENV_AMBIENT_SOURCE_SKY = 3;
    static constexpr int64_t ENV_REFLECTION_SOURCE_BG = 0;
    static constexpr int64_t ENV_REFLECTION_SOURCE_DISABLED = 1;
    static constexpr int64_t ENV_REFLECTION_SOURCE_SKY = 2;
    static constexpr int64_t ENV_GLOW_BLEND_MODE_ADDITIVE = 0;
    static constexpr int64_t ENV_GLOW_BLEND_MODE_SCREEN = 1;
    static constexpr int64_t ENV_GLOW_BLEND_MODE_SOFTLIGHT = 2;
    static constexpr int64_t ENV_GLOW_BLEND_MODE_REPLACE = 3;
    static constexpr int64_t ENV_GLOW_BLEND_MODE_MIX = 4;
    static constexpr int64_t ENV_FOG_MODE_EXPONENTIAL = 0;
    static constexpr int64_t ENV_FOG_MODE_DEPTH = 1;
    static constexpr int64_t ENV_TONE_MAPPER_LINEAR = 0;
    static constexpr int64_t ENV_TONE_MAPPER_REINHARD = 1;
    static constexpr int64_t ENV_TONE_MAPPER_FILMIC = 2;
    static constexpr int64_t ENV_TONE_MAPPER_ACES = 3;
    static constexpr int64_t ENV_SSR_ROUGHNESS_QUALITY_DISABLED = 0;
    static constexpr int64_t ENV_SSR_ROUGHNESS_QUALITY_LOW = 1;
    static constexpr int64_t ENV_SSR_ROUGHNESS_QUALITY_MEDIUM = 2;
    static constexpr int64_t ENV_SSR_ROUGHNESS_QUALITY_HIGH = 3;
    static constexpr int64_t ENV_SSAO_QUALITY_VERY_LOW = 0;
    static constexpr int64_t ENV_SSAO_QUALITY_LOW = 1;
    static constexpr int64_t ENV_SSAO_QUALITY_MEDIUM = 2;
    static constexpr int64_t ENV_SSAO_QUALITY_HIGH = 3;
    static constexpr int64_t ENV_SSAO_QUALITY_ULTRA = 4;
    static constexpr int64_t ENV_SSIL_QUALITY_VERY_LOW = 0;
    static constexpr int64_t ENV_SSIL_QUALITY_LOW = 1;
    static constexpr int64_t ENV_SSIL_QUALITY_MEDIUM = 2;
    static constexpr int64_t ENV_SSIL_QUALITY_HIGH = 3;
    static constexpr int64_t ENV_SSIL_QUALITY_ULTRA = 4;
    static constexpr int64_t ENV_SDFGI_Y_SCALE_50_PERCENT = 0;
    static constexpr int64_t ENV_SDFGI_Y_SCALE_75_PERCENT = 1;
    static constexpr int64_t ENV_SDFGI_Y_SCALE_100_PERCENT = 2;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_4 = 0;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_8 = 1;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_16 = 2;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_32 = 3;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_64 = 4;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_96 = 5;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_128 = 6;
    static constexpr int64_t ENV_SDFGI_RAY_COUNT_MAX = 7;
    static constexpr int64_t ENV_SDFGI_CONVERGE_IN_5_FRAMES = 0;
    static constexpr int64_t ENV_SDFGI_CONVERGE_IN_10_FRAMES = 1;
    static constexpr int64_t ENV_SDFGI_CONVERGE_IN_15_FRAMES = 2;
    static constexpr int64_t ENV_SDFGI_CONVERGE_IN_20_FRAMES = 3;
    static constexpr int64_t ENV_SDFGI_CONVERGE_IN_25_FRAMES = 4;
    static constexpr int64_t ENV_SDFGI_CONVERGE_IN_30_FRAMES = 5;
    static constexpr int64_t ENV_SDFGI_CONVERGE_MAX = 6;
    static constexpr int64_t ENV_SDFGI_UPDATE_LIGHT_IN_1_FRAME = 0;
    static constexpr int64_t ENV_SDFGI_UPDATE_LIGHT_IN_2_FRAMES = 1;
    static constexpr int64_t ENV_SDFGI_UPDATE_LIGHT_IN_4_FRAMES = 2;
    static constexpr int64_t ENV_SDFGI_UPDATE_LIGHT_IN_8_FRAMES = 3;
    static constexpr int64_t ENV_SDFGI_UPDATE_LIGHT_IN_16_FRAMES = 4;
    static constexpr int64_t ENV_SDFGI_UPDATE_LIGHT_MAX = 5;
    static constexpr int64_t SUB_SURFACE_SCATTERING_QUALITY_DISABLED = 0;
    static constexpr int64_t SUB_SURFACE_SCATTERING_QUALITY_LOW = 1;
    static constexpr int64_t SUB_SURFACE_SCATTERING_QUALITY_MEDIUM = 2;
    static constexpr int64_t SUB_SURFACE_SCATTERING_QUALITY_HIGH = 3;
    static constexpr int64_t DOF_BOKEH_BOX = 0;
    static constexpr int64_t DOF_BOKEH_HEXAGON = 1;
    static constexpr int64_t DOF_BOKEH_CIRCLE = 2;
    static constexpr int64_t DOF_BLUR_QUALITY_VERY_LOW = 0;
    static constexpr int64_t DOF_BLUR_QUALITY_LOW = 1;
    static constexpr int64_t DOF_BLUR_QUALITY_MEDIUM = 2;
    static constexpr int64_t DOF_BLUR_QUALITY_HIGH = 3;
    static constexpr int64_t INSTANCE_NONE = 0;
    static constexpr int64_t INSTANCE_MESH = 1;
    static constexpr int64_t INSTANCE_MULTIMESH = 2;
    static constexpr int64_t INSTANCE_PARTICLES = 3;
    static constexpr int64_t INSTANCE_PARTICLES_COLLISION = 4;
    static constexpr int64_t INSTANCE_LIGHT = 5;
    static constexpr int64_t INSTANCE_REFLECTION_PROBE = 6;
    static constexpr int64_t INSTANCE_DECAL = 7;
    static constexpr int64_t INSTANCE_VOXEL_GI = 8;
    static constexpr int64_t INSTANCE_LIGHTMAP = 9;
    static constexpr int64_t INSTANCE_OCCLUDER = 10;
    static constexpr int64_t INSTANCE_VISIBLITY_NOTIFIER = 11;
    static constexpr int64_t INSTANCE_FOG_VOLUME = 12;
    static constexpr int64_t INSTANCE_MAX = 13;
    static constexpr int64_t INSTANCE_GEOMETRY_MASK = 14;
    static constexpr int64_t INSTANCE_FLAG_USE_BAKED_LIGHT = 0;
    static constexpr int64_t INSTANCE_FLAG_USE_DYNAMIC_GI = 1;
    static constexpr int64_t INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE = 2;
    static constexpr int64_t INSTANCE_FLAG_IGNORE_OCCLUSION_CULLING = 3;
    static constexpr int64_t INSTANCE_FLAG_MAX = 4;
    static constexpr int64_t SHADOW_CASTING_SETTING_OFF = 0;
    static constexpr int64_t SHADOW_CASTING_SETTING_ON = 1;
    static constexpr int64_t SHADOW_CASTING_SETTING_DOUBLE_SIDED = 2;
    static constexpr int64_t SHADOW_CASTING_SETTING_SHADOWS_ONLY = 3;
    static constexpr int64_t VISIBILITY_RANGE_FADE_DISABLED = 0;
    static constexpr int64_t VISIBILITY_RANGE_FADE_SELF = 1;
    static constexpr int64_t VISIBILITY_RANGE_FADE_DEPENDENCIES = 2;
    static constexpr int64_t BAKE_CHANNEL_ALBEDO_ALPHA = 0;
    static constexpr int64_t BAKE_CHANNEL_NORMAL = 1;
    static constexpr int64_t BAKE_CHANNEL_ORM = 2;
    static constexpr int64_t BAKE_CHANNEL_EMISSION = 3;
    static constexpr int64_t CANVAS_TEXTURE_CHANNEL_DIFFUSE = 0;
    static constexpr int64_t CANVAS_TEXTURE_CHANNEL_NORMAL = 1;
    static constexpr int64_t CANVAS_TEXTURE_CHANNEL_SPECULAR = 2;
    static constexpr int64_t NINE_PATCH_STRETCH = 0;
    static constexpr int64_t NINE_PATCH_TILE = 1;
    static constexpr int64_t NINE_PATCH_TILE_FIT = 2;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_DEFAULT = 0;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_NEAREST = 1;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_LINEAR = 2;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 3;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 4;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC = 5;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC = 6;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_FILTER_MAX = 7;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_REPEAT_DEFAULT = 0;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_REPEAT_DISABLED = 1;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_REPEAT_ENABLED = 2;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_REPEAT_MIRROR = 3;
    static constexpr int64_t CANVAS_ITEM_TEXTURE_REPEAT_MAX = 4;
    static constexpr int64_t CANVAS_GROUP_MODE_DISABLED = 0;
    static constexpr int64_t CANVAS_GROUP_MODE_CLIP_ONLY = 1;
    static constexpr int64_t CANVAS_GROUP_MODE_CLIP_AND_DRAW = 2;
    static constexpr int64_t CANVAS_GROUP_MODE_TRANSPARENT = 3;
    static constexpr int64_t CANVAS_LIGHT_MODE_POINT = 0;
    static constexpr int64_t CANVAS_LIGHT_MODE_DIRECTIONAL = 1;
    static constexpr int64_t CANVAS_LIGHT_BLEND_MODE_ADD = 0;
    static constexpr int64_t CANVAS_LIGHT_BLEND_MODE_SUB = 1;
    static constexpr int64_t CANVAS_LIGHT_BLEND_MODE_MIX = 2;
    static constexpr int64_t CANVAS_LIGHT_FILTER_NONE = 0;
    static constexpr int64_t CANVAS_LIGHT_FILTER_PCF5 = 1;
    static constexpr int64_t CANVAS_LIGHT_FILTER_PCF13 = 2;
    static constexpr int64_t CANVAS_LIGHT_FILTER_MAX = 3;
    static constexpr int64_t CANVAS_OCCLUDER_POLYGON_CULL_DISABLED = 0;
    static constexpr int64_t CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE = 1;
    static constexpr int64_t CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE = 2;
    static constexpr int64_t GLOBAL_VAR_TYPE_BOOL = 0;
    static constexpr int64_t GLOBAL_VAR_TYPE_BVEC2 = 1;
    static constexpr int64_t GLOBAL_VAR_TYPE_BVEC3 = 2;
    static constexpr int64_t GLOBAL_VAR_TYPE_BVEC4 = 3;
    static constexpr int64_t GLOBAL_VAR_TYPE_INT = 4;
    static constexpr int64_t GLOBAL_VAR_TYPE_IVEC2 = 5;
    static constexpr int64_t GLOBAL_VAR_TYPE_IVEC3 = 6;
    static constexpr int64_t GLOBAL_VAR_TYPE_IVEC4 = 7;
    static constexpr int64_t GLOBAL_VAR_TYPE_RECT2I = 8;
    static constexpr int64_t GLOBAL_VAR_TYPE_UINT = 9;
    static constexpr int64_t GLOBAL_VAR_TYPE_UVEC2 = 10;
    static constexpr int64_t GLOBAL_VAR_TYPE_UVEC3 = 11;
    static constexpr int64_t GLOBAL_VAR_TYPE_UVEC4 = 12;
    static constexpr int64_t GLOBAL_VAR_TYPE_FLOAT = 13;
    static constexpr int64_t GLOBAL_VAR_TYPE_VEC2 = 14;
    static constexpr int64_t GLOBAL_VAR_TYPE_VEC3 = 15;
    static constexpr int64_t GLOBAL_VAR_TYPE_VEC4 = 16;
    static constexpr int64_t GLOBAL_VAR_TYPE_COLOR = 17;
    static constexpr int64_t GLOBAL_VAR_TYPE_RECT2 = 18;
    static constexpr int64_t GLOBAL_VAR_TYPE_MAT2 = 19;
    static constexpr int64_t GLOBAL_VAR_TYPE_MAT3 = 20;
    static constexpr int64_t GLOBAL_VAR_TYPE_MAT4 = 21;
    static constexpr int64_t GLOBAL_VAR_TYPE_TRANSFORM_2D = 22;
    static constexpr int64_t GLOBAL_VAR_TYPE_TRANSFORM = 23;
    static constexpr int64_t GLOBAL_VAR_TYPE_SAMPLER2D = 24;
    static constexpr int64_t GLOBAL_VAR_TYPE_SAMPLER2DARRAY = 25;
    static constexpr int64_t GLOBAL_VAR_TYPE_SAMPLER3D = 26;
    static constexpr int64_t GLOBAL_VAR_TYPE_SAMPLERCUBE = 27;
    static constexpr int64_t GLOBAL_VAR_TYPE_MAX = 28;
    static constexpr int64_t RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME = 0;
    static constexpr int64_t RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME = 1;
    static constexpr int64_t RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME = 2;
    static constexpr int64_t RENDERING_INFO_TEXTURE_MEM_USED = 3;
    static constexpr int64_t RENDERING_INFO_BUFFER_MEM_USED = 4;
    static constexpr int64_t RENDERING_INFO_VIDEO_MEM_USED = 5;
    static constexpr int64_t FEATURE_SHADERS = 0;
    static constexpr int64_t FEATURE_MULTITHREADED = 1;
    static RenderingServer get_singleton() { return RenderingServer(Object("RenderingServer").address()); }
};
struct Resource : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(resource_local_to_scene, bool);
    PROPERTY(resource_path, String);
    PROPERTY(resource_name, String);
    PROPERTY(resource_scene_unique_id, String);
    METHOD(::RID, _get_rid);
    METHOD(Variant, _setup_local_to_scene);
    METHOD(void, set_path);
    METHOD(Variant, take_over_path);
    METHOD(String, get_path);
    METHOD(void, set_name);
    METHOD(String, get_name);
    METHOD(::RID, get_rid);
    METHOD(void, set_local_to_scene);
    METHOD(bool, is_local_to_scene);
    METHOD(Object, get_local_scene);
    METHOD(Variant, setup_local_to_scene);
    METHOD(String, generate_scene_unique_id);
    METHOD(void, set_scene_unique_id);
    METHOD(String, get_scene_unique_id);
    METHOD(Variant, emit_changed);
    METHOD(Object, duplicate);
};
struct ResourceImporter : public RefCounted {
    using RefCounted::RefCounted;
    static constexpr int64_t IMPORT_ORDER_DEFAULT = 0;
    static constexpr int64_t IMPORT_ORDER_SCENE = 100;
};
struct ResourceImporterBMFont : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterBitMap : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterCSVTranslation : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterDynamicFont : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterImage : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterImageFont : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterLayeredTexture : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterMP3 : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterOBJ : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterOggVorbis : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
    METHOD(Object, load_from_buffer);
    METHOD(Object, load_from_file);
};
struct ResourceImporterScene : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterShaderFile : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterTexture : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterTextureAtlas : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourceImporterWAV : public ResourceImporter {
    using ResourceImporter::ResourceImporter;
};
struct ResourcePreloader : public Node {
    using Node::Node;
    PROPERTY(resources, Array);
    METHOD(Variant, _set_resources);
    METHOD(Array, _get_resources);
    METHOD(Variant, add_resource);
    METHOD(Variant, remove_resource);
    METHOD(Variant, rename_resource);
    METHOD(bool, has_resource);
    METHOD(Object, get_resource);
    METHOD(PackedArray<std::string>, get_resource_list);
};
struct ResourceUID : public Object {
    using Object::Object;
    METHOD(String, id_to_text);
    METHOD(int64_t, text_to_id);
    METHOD(int64_t, create_id);
    METHOD(bool, has_id);
    METHOD(Variant, add_id);
    METHOD(void, set_id);
    METHOD(String, get_id_path);
    METHOD(Variant, remove_id);
    static constexpr int64_t INVALID_ID = -1;
    static ResourceUID get_singleton() { return ResourceUID(Object("ResourceUID").address()); }
};
struct RichTextEffect : public Resource {
    using Resource::Resource;
    METHOD(bool, _process_custom_fx);
};
struct RichTextLabel : public Control {
    using Control::Control;
    PROPERTY(bbcode_enabled, bool);
    PROPERTY(text, String);
    PROPERTY(fit_content, bool);
    PROPERTY(scroll_active, bool);
    PROPERTY(scroll_following, bool);
    PROPERTY(autowrap_mode, int64_t);
    PROPERTY(tab_size, int64_t);
    PROPERTY(context_menu_enabled, bool);
    PROPERTY(shortcut_keys_enabled, bool);
    PROPERTY(custom_effects, Array);
    PROPERTY(meta_underlined, bool);
    PROPERTY(hint_underlined, bool);
    PROPERTY(threaded, bool);
    PROPERTY(progress_bar_delay, int64_t);
    PROPERTY(selection_enabled, bool);
    PROPERTY(deselect_on_focus_loss_enabled, bool);
    PROPERTY(drag_and_drop_selection_enabled, bool);
    PROPERTY(visible_characters, int64_t);
    PROPERTY(visible_characters_behavior, int64_t);
    PROPERTY(visible_ratio, double);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    PROPERTY(structured_text_bidi_override, int64_t);
    PROPERTY(structured_text_bidi_override_options, Array);
    METHOD(String, get_parsed_text);
    METHOD(Variant, add_text);
    METHOD(void, set_text);
    METHOD(Variant, add_image);
    METHOD(Variant, update_image);
    METHOD(Variant, newline);
    METHOD(bool, remove_paragraph);
    METHOD(bool, invalidate_paragraph);
    METHOD(Variant, push_font);
    METHOD(Variant, push_font_size);
    METHOD(Variant, push_normal);
    METHOD(Variant, push_bold);
    METHOD(Variant, push_bold_italics);
    METHOD(Variant, push_italics);
    METHOD(Variant, push_mono);
    METHOD(Variant, push_color);
    METHOD(Variant, push_outline_size);
    METHOD(Variant, push_outline_color);
    METHOD(Variant, push_paragraph);
    METHOD(Variant, push_indent);
    METHOD(Variant, push_list);
    METHOD(Variant, push_meta);
    METHOD(Variant, push_hint);
    METHOD(Variant, push_language);
    METHOD(Variant, push_underline);
    METHOD(Variant, push_strikethrough);
    METHOD(Variant, push_table);
    METHOD(Variant, push_dropcap);
    METHOD(void, set_table_column_expand);
    METHOD(void, set_cell_row_background_color);
    METHOD(void, set_cell_border_color);
    METHOD(void, set_cell_size_override);
    METHOD(void, set_cell_padding);
    METHOD(Variant, push_cell);
    METHOD(Variant, push_fgcolor);
    METHOD(Variant, push_bgcolor);
    METHOD(Variant, push_customfx);
    METHOD(Variant, push_context);
    METHOD(Variant, pop_context);
    METHOD(Variant, pop);
    METHOD(Variant, pop_all);
    METHOD(Variant, clear);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_autowrap_mode);
    METHOD(int64_t, get_autowrap_mode);
    METHOD(void, set_meta_underline);
    METHOD(bool, is_meta_underlined);
    METHOD(void, set_hint_underline);
    METHOD(bool, is_hint_underlined);
    METHOD(void, set_scroll_active);
    METHOD(bool, is_scroll_active);
    METHOD(void, set_scroll_follow);
    METHOD(bool, is_scroll_following);
    METHOD(Object, get_v_scroll_bar);
    METHOD(Variant, scroll_to_line);
    METHOD(Variant, scroll_to_paragraph);
    METHOD(Variant, scroll_to_selection);
    METHOD(void, set_tab_size);
    METHOD(int64_t, get_tab_size);
    METHOD(void, set_fit_content);
    METHOD(bool, is_fit_content_enabled);
    METHOD(void, set_selection_enabled);
    METHOD(bool, is_selection_enabled);
    METHOD(void, set_context_menu_enabled);
    METHOD(bool, is_context_menu_enabled);
    METHOD(void, set_shortcut_keys_enabled);
    METHOD(bool, is_shortcut_keys_enabled);
    METHOD(void, set_deselect_on_focus_loss_enabled);
    METHOD(bool, is_deselect_on_focus_loss_enabled);
    METHOD(void, set_drag_and_drop_selection_enabled);
    METHOD(bool, is_drag_and_drop_selection_enabled);
    METHOD(int64_t, get_selection_from);
    METHOD(int64_t, get_selection_to);
    METHOD(Variant, select_all);
    METHOD(String, get_selected_text);
    METHOD(Variant, deselect);
    METHOD(Variant, parse_bbcode);
    METHOD(Variant, append_text);
    METHOD(String, get_text);
    METHOD(bool, is_ready);
    METHOD(void, set_threaded);
    METHOD(bool, is_threaded);
    METHOD(void, set_progress_bar_delay);
    METHOD(int64_t, get_progress_bar_delay);
    METHOD(void, set_visible_characters);
    METHOD(int64_t, get_visible_characters);
    METHOD(int64_t, get_visible_characters_behavior);
    METHOD(void, set_visible_characters_behavior);
    METHOD(void, set_visible_ratio);
    METHOD(double, get_visible_ratio);
    METHOD(int64_t, get_character_line);
    METHOD(int64_t, get_character_paragraph);
    METHOD(int64_t, get_total_character_count);
    METHOD(void, set_use_bbcode);
    METHOD(bool, is_using_bbcode);
    METHOD(int64_t, get_line_count);
    METHOD(int64_t, get_visible_line_count);
    METHOD(int64_t, get_paragraph_count);
    METHOD(int64_t, get_visible_paragraph_count);
    METHOD(int64_t, get_content_height);
    METHOD(int64_t, get_content_width);
    METHOD(double, get_line_offset);
    METHOD(double, get_paragraph_offset);
    METHOD(Dictionary, parse_expressions_for_values);
    METHOD(void, set_effects);
    METHOD(Array, get_effects);
    METHOD(Variant, install_effect);
    METHOD(Object, get_menu);
    METHOD(bool, is_menu_visible);
    METHOD(Variant, menu_option);
    static constexpr int64_t LIST_NUMBERS = 0;
    static constexpr int64_t LIST_LETTERS = 1;
    static constexpr int64_t LIST_ROMAN = 2;
    static constexpr int64_t LIST_DOTS = 3;
    static constexpr int64_t MENU_COPY = 0;
    static constexpr int64_t MENU_SELECT_ALL = 1;
    static constexpr int64_t MENU_MAX = 2;
    static constexpr int64_t META_UNDERLINE_NEVER = 0;
    static constexpr int64_t META_UNDERLINE_ALWAYS = 1;
    static constexpr int64_t META_UNDERLINE_ON_HOVER = 2;
    static constexpr int64_t UPDATE_TEXTURE = 1;
    static constexpr int64_t UPDATE_SIZE = 2;
    static constexpr int64_t UPDATE_COLOR = 4;
    static constexpr int64_t UPDATE_ALIGNMENT = 8;
    static constexpr int64_t UPDATE_REGION = 16;
    static constexpr int64_t UPDATE_PAD = 32;
    static constexpr int64_t UPDATE_TOOLTIP = 64;
    static constexpr int64_t UPDATE_WIDTH_IN_PERCENT = 128;
};
struct RigidBody2D : public PhysicsBody2D {
    using PhysicsBody2D::PhysicsBody2D;
    PROPERTY(mass, double);
    PROPERTY(physics_material_override, Object);
    PROPERTY(gravity_scale, double);
    PROPERTY(center_of_mass_mode, int64_t);
    PROPERTY(center_of_mass, Vector2);
    PROPERTY(inertia, double);
    PROPERTY(sleeping, bool);
    PROPERTY(can_sleep, bool);
    PROPERTY(lock_rotation, bool);
    PROPERTY(freeze, bool);
    PROPERTY(freeze_mode, int64_t);
    PROPERTY(custom_integrator, bool);
    PROPERTY(continuous_cd, int64_t);
    PROPERTY(contact_monitor, bool);
    PROPERTY(max_contacts_reported, int64_t);
    PROPERTY(linear_velocity, Vector2);
    PROPERTY(linear_damp_mode, int64_t);
    PROPERTY(linear_damp, double);
    PROPERTY(angular_velocity, double);
    PROPERTY(angular_damp_mode, int64_t);
    PROPERTY(angular_damp, double);
    PROPERTY(constant_force, Vector2);
    PROPERTY(constant_torque, double);
    METHOD(Variant, _integrate_forces);
    METHOD(void, set_mass);
    METHOD(double, get_mass);
    METHOD(double, get_inertia);
    METHOD(void, set_inertia);
    METHOD(void, set_center_of_mass_mode);
    METHOD(int64_t, get_center_of_mass_mode);
    METHOD(void, set_center_of_mass);
    METHOD(Vector2, get_center_of_mass);
    METHOD(void, set_physics_material_override);
    METHOD(Object, get_physics_material_override);
    METHOD(void, set_gravity_scale);
    METHOD(double, get_gravity_scale);
    METHOD(void, set_linear_damp_mode);
    METHOD(int64_t, get_linear_damp_mode);
    METHOD(void, set_angular_damp_mode);
    METHOD(int64_t, get_angular_damp_mode);
    METHOD(void, set_linear_damp);
    METHOD(double, get_linear_damp);
    METHOD(void, set_angular_damp);
    METHOD(double, get_angular_damp);
    METHOD(void, set_linear_velocity);
    METHOD(Vector2, get_linear_velocity);
    METHOD(void, set_angular_velocity);
    METHOD(double, get_angular_velocity);
    METHOD(void, set_max_contacts_reported);
    METHOD(int64_t, get_max_contacts_reported);
    METHOD(int64_t, get_contact_count);
    METHOD(void, set_use_custom_integrator);
    METHOD(bool, is_using_custom_integrator);
    METHOD(void, set_contact_monitor);
    METHOD(bool, is_contact_monitor_enabled);
    METHOD(void, set_continuous_collision_detection_mode);
    METHOD(int64_t, get_continuous_collision_detection_mode);
    METHOD(void, set_axis_velocity);
    METHOD(Variant, apply_central_impulse);
    METHOD(Variant, apply_impulse);
    METHOD(Variant, apply_torque_impulse);
    METHOD(Variant, apply_central_force);
    METHOD(Variant, apply_force);
    METHOD(Variant, apply_torque);
    METHOD(Variant, add_constant_central_force);
    METHOD(Variant, add_constant_force);
    METHOD(Variant, add_constant_torque);
    METHOD(void, set_constant_force);
    METHOD(Vector2, get_constant_force);
    METHOD(void, set_constant_torque);
    METHOD(double, get_constant_torque);
    METHOD(void, set_sleeping);
    METHOD(bool, is_sleeping);
    METHOD(void, set_can_sleep);
    METHOD(bool, is_able_to_sleep);
    METHOD(void, set_lock_rotation_enabled);
    METHOD(bool, is_lock_rotation_enabled);
    METHOD(void, set_freeze_enabled);
    METHOD(bool, is_freeze_enabled);
    METHOD(void, set_freeze_mode);
    METHOD(int64_t, get_freeze_mode);
    METHOD(Array, get_colliding_bodies);
    static constexpr int64_t FREEZE_MODE_STATIC = 0;
    static constexpr int64_t FREEZE_MODE_KINEMATIC = 1;
    static constexpr int64_t CENTER_OF_MASS_MODE_AUTO = 0;
    static constexpr int64_t CENTER_OF_MASS_MODE_CUSTOM = 1;
    static constexpr int64_t DAMP_MODE_COMBINE = 0;
    static constexpr int64_t DAMP_MODE_REPLACE = 1;
    static constexpr int64_t CCD_MODE_DISABLED = 0;
    static constexpr int64_t CCD_MODE_CAST_RAY = 1;
    static constexpr int64_t CCD_MODE_CAST_SHAPE = 2;
};
struct RigidBody3D : public PhysicsBody3D {
    using PhysicsBody3D::PhysicsBody3D;
    PROPERTY(mass, double);
    PROPERTY(physics_material_override, Object);
    PROPERTY(gravity_scale, double);
    PROPERTY(center_of_mass_mode, int64_t);
    PROPERTY(center_of_mass, Vector3);
    PROPERTY(inertia, Vector3);
    PROPERTY(sleeping, bool);
    PROPERTY(can_sleep, bool);
    PROPERTY(lock_rotation, bool);
    PROPERTY(freeze, bool);
    PROPERTY(freeze_mode, int64_t);
    PROPERTY(custom_integrator, bool);
    PROPERTY(continuous_cd, bool);
    PROPERTY(contact_monitor, bool);
    PROPERTY(max_contacts_reported, int64_t);
    PROPERTY(linear_velocity, Vector3);
    PROPERTY(linear_damp_mode, int64_t);
    PROPERTY(linear_damp, double);
    PROPERTY(angular_velocity, Vector3);
    PROPERTY(angular_damp_mode, int64_t);
    PROPERTY(angular_damp, double);
    PROPERTY(constant_force, Vector3);
    PROPERTY(constant_torque, Vector3);
    METHOD(Variant, _integrate_forces);
    METHOD(void, set_mass);
    METHOD(double, get_mass);
    METHOD(void, set_inertia);
    METHOD(Vector3, get_inertia);
    METHOD(void, set_center_of_mass_mode);
    METHOD(int64_t, get_center_of_mass_mode);
    METHOD(void, set_center_of_mass);
    METHOD(Vector3, get_center_of_mass);
    METHOD(void, set_physics_material_override);
    METHOD(Object, get_physics_material_override);
    METHOD(void, set_linear_velocity);
    METHOD(Vector3, get_linear_velocity);
    METHOD(void, set_angular_velocity);
    METHOD(Vector3, get_angular_velocity);
    METHOD(Basis, get_inverse_inertia_tensor);
    METHOD(void, set_gravity_scale);
    METHOD(double, get_gravity_scale);
    METHOD(void, set_linear_damp_mode);
    METHOD(int64_t, get_linear_damp_mode);
    METHOD(void, set_angular_damp_mode);
    METHOD(int64_t, get_angular_damp_mode);
    METHOD(void, set_linear_damp);
    METHOD(double, get_linear_damp);
    METHOD(void, set_angular_damp);
    METHOD(double, get_angular_damp);
    METHOD(void, set_max_contacts_reported);
    METHOD(int64_t, get_max_contacts_reported);
    METHOD(int64_t, get_contact_count);
    METHOD(void, set_use_custom_integrator);
    METHOD(bool, is_using_custom_integrator);
    METHOD(void, set_contact_monitor);
    METHOD(bool, is_contact_monitor_enabled);
    METHOD(void, set_use_continuous_collision_detection);
    METHOD(bool, is_using_continuous_collision_detection);
    METHOD(void, set_axis_velocity);
    METHOD(Variant, apply_central_impulse);
    METHOD(Variant, apply_impulse);
    METHOD(Variant, apply_torque_impulse);
    METHOD(Variant, apply_central_force);
    METHOD(Variant, apply_force);
    METHOD(Variant, apply_torque);
    METHOD(Variant, add_constant_central_force);
    METHOD(Variant, add_constant_force);
    METHOD(Variant, add_constant_torque);
    METHOD(void, set_constant_force);
    METHOD(Vector3, get_constant_force);
    METHOD(void, set_constant_torque);
    METHOD(Vector3, get_constant_torque);
    METHOD(void, set_sleeping);
    METHOD(bool, is_sleeping);
    METHOD(void, set_can_sleep);
    METHOD(bool, is_able_to_sleep);
    METHOD(void, set_lock_rotation_enabled);
    METHOD(bool, is_lock_rotation_enabled);
    METHOD(void, set_freeze_enabled);
    METHOD(bool, is_freeze_enabled);
    METHOD(void, set_freeze_mode);
    METHOD(int64_t, get_freeze_mode);
    METHOD(Array, get_colliding_bodies);
    static constexpr int64_t FREEZE_MODE_STATIC = 0;
    static constexpr int64_t FREEZE_MODE_KINEMATIC = 1;
    static constexpr int64_t CENTER_OF_MASS_MODE_AUTO = 0;
    static constexpr int64_t CENTER_OF_MASS_MODE_CUSTOM = 1;
    static constexpr int64_t DAMP_MODE_COMBINE = 0;
    static constexpr int64_t DAMP_MODE_REPLACE = 1;
};
struct Sandbox : public Node {
    using Node::Node;
    PROPERTY(references_max, int64_t);
    PROPERTY(memory_max, int64_t);
    PROPERTY(execution_timeout, int64_t);
    PROPERTY(use_unboxed_arguments, bool);
    PROPERTY(use_precise_simulation, bool);
    PROPERTY(restrictions, bool);
    PROPERTY(monitor_heap_usage, int64_t);
    PROPERTY(monitor_exceptions, int64_t);
    PROPERTY(monitor_execution_timeouts, int64_t);
    PROPERTY(monitor_calls_made, int64_t);
    PROPERTY(monitor_global_calls_made, int64_t);
    PROPERTY(monitor_global_exceptions, int64_t);
    PROPERTY(monitor_global_execution_timeouts, int64_t);
    PROPERTY(monitor_global_instance_count, int64_t);
    PROPERTY(monitor_accumulated_startup_time, double);
    METHOD(Object, FromBuffer);
    METHOD(Object, FromProgram);
    METHOD(void, set_program);
    METHOD(Object, get_program);
    METHOD(bool, has_program_loaded);
    METHOD(Variant, load_buffer);
    METHOD(Variant, vmcall);
    METHOD(Variant, vmcallv);
    METHOD(Variant, vmcallable);
    METHOD(Variant, vmcallable_address);
    METHOD(void, set_restrictions);
    METHOD(bool, get_restrictions);
    METHOD(Variant, add_allowed_object);
    METHOD(Variant, remove_allowed_object);
    METHOD(Variant, clear_allowed_objects);
    METHOD(void, set_class_allowed_callback);
    METHOD(void, set_object_allowed_callback);
    METHOD(void, set_method_allowed_callback);
    METHOD(void, set_property_allowed_callback);
    METHOD(void, set_resource_allowed_callback);
    METHOD(bool, is_allowed_class);
    METHOD(bool, is_allowed_object);
    METHOD(bool, is_allowed_method);
    METHOD(bool, is_allowed_property);
    METHOD(bool, is_allowed_resource);
    METHOD(bool, restrictive_callback_function);
    METHOD(void, set_redirect_stdout);
    METHOD(Array, get_general_registers);
    METHOD(Array, get_floating_point_registers);
    METHOD(void, set_argument_registers);
    METHOD(String, get_current_instruction);
    METHOD(Variant, make_resumable);
    METHOD(bool, resume);
    METHOD(Variant, assault);
    METHOD(bool, has_function);
    METHOD(PackedArray<std::string>, get_functions);
    METHOD(String, generate_api);
    METHOD(String, emit_binary_translation);
    METHOD(bool, is_binary_translated);
    METHOD(Variant, set);
    METHOD(Variant, get);
    METHOD(Array, get_property_list);
    METHOD(void, set_max_refs);
    METHOD(int64_t, get_max_refs);
    METHOD(void, set_memory_max);
    METHOD(int64_t, get_memory_max);
    METHOD(void, set_instructions_max);
    METHOD(int64_t, get_instructions_max);
    METHOD(void, set_use_unboxed_arguments);
    METHOD(bool, get_use_unboxed_arguments);
    METHOD(void, set_use_precise_simulation);
    METHOD(bool, get_use_precise_simulation);
    METHOD(int64_t, get_heap_usage);
    METHOD(int64_t, get_exceptions);
    METHOD(int64_t, get_timeouts);
    METHOD(int64_t, get_calls_made);
    METHOD(int64_t, get_global_calls_made);
    METHOD(int64_t, get_global_exceptions);
    METHOD(int64_t, get_global_timeouts);
    METHOD(int64_t, get_global_instance_count);
    METHOD(double, get_accumulated_startup_time);
};
struct SceneCacheInterface : public RefCounted {
    using RefCounted::RefCounted;
};
struct SceneImportSettingsData : public Object {
    using Object::Object;
};
struct SceneRPCInterface : public RefCounted {
    using RefCounted::RefCounted;
};
struct SceneReplicationConfig : public Resource {
    using Resource::Resource;
    METHOD(Array, get_properties);
    METHOD(Variant, add_property);
    METHOD(bool, has_property);
    METHOD(Variant, remove_property);
    METHOD(int64_t, property_get_index);
    METHOD(bool, property_get_spawn);
    METHOD(Variant, property_set_spawn);
    METHOD(int64_t, property_get_replication_mode);
    METHOD(Variant, property_set_replication_mode);
    METHOD(bool, property_get_sync);
    METHOD(Variant, property_set_sync);
    METHOD(bool, property_get_watch);
    METHOD(Variant, property_set_watch);
    static constexpr int64_t REPLICATION_MODE_NEVER = 0;
    static constexpr int64_t REPLICATION_MODE_ALWAYS = 1;
    static constexpr int64_t REPLICATION_MODE_ON_CHANGE = 2;
};
struct SceneReplicationInterface : public RefCounted {
    using RefCounted::RefCounted;
};
struct SceneState : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, get_node_count);
    METHOD(String, get_node_type);
    METHOD(String, get_node_name);
    METHOD(String, get_node_path);
    METHOD(String, get_node_owner_path);
    METHOD(bool, is_node_instance_placeholder);
    METHOD(String, get_node_instance_placeholder);
    METHOD(Object, get_node_instance);
    METHOD(PackedArray<std::string>, get_node_groups);
    METHOD(int64_t, get_node_index);
    METHOD(int64_t, get_node_property_count);
    METHOD(String, get_node_property_name);
    METHOD(Variant, get_node_property_value);
    METHOD(int64_t, get_connection_count);
    METHOD(String, get_connection_source);
    METHOD(String, get_connection_signal);
    METHOD(String, get_connection_target);
    METHOD(String, get_connection_method);
    METHOD(int64_t, get_connection_flags);
    METHOD(Array, get_connection_binds);
    METHOD(int64_t, get_connection_unbinds);
    static constexpr int64_t GEN_EDIT_STATE_DISABLED = 0;
    static constexpr int64_t GEN_EDIT_STATE_INSTANCE = 1;
    static constexpr int64_t GEN_EDIT_STATE_MAIN = 2;
    static constexpr int64_t GEN_EDIT_STATE_MAIN_INHERITED = 3;
};
struct SceneTileProxyObject : public Object {
    using Object::Object;
};
struct SceneTree : public MainLoop {
    using MainLoop::MainLoop;
    PROPERTY(auto_accept_quit, bool);
    PROPERTY(quit_on_go_back, bool);
    PROPERTY(debug_collisions_hint, bool);
    PROPERTY(debug_paths_hint, bool);
    PROPERTY(debug_navigation_hint, bool);
    PROPERTY(paused, bool);
    PROPERTY(edited_scene_root, Object);
    PROPERTY(current_scene, Object);
    PROPERTY(root, Object);
    PROPERTY(multiplayer_poll, bool);
    PROPERTY(physics_interpolation, bool);
    METHOD(Object, get_root);
    METHOD(bool, has_group);
    METHOD(bool, is_auto_accept_quit);
    METHOD(void, set_auto_accept_quit);
    METHOD(bool, is_quit_on_go_back);
    METHOD(void, set_quit_on_go_back);
    METHOD(void, set_debug_collisions_hint);
    METHOD(bool, is_debugging_collisions_hint);
    METHOD(void, set_debug_paths_hint);
    METHOD(bool, is_debugging_paths_hint);
    METHOD(void, set_debug_navigation_hint);
    METHOD(bool, is_debugging_navigation_hint);
    METHOD(void, set_edited_scene_root);
    METHOD(Object, get_edited_scene_root);
    METHOD(void, set_pause);
    METHOD(bool, is_paused);
    METHOD(Object, create_timer);
    METHOD(Object, create_tween);
    METHOD(Array, get_processed_tweens);
    METHOD(int64_t, get_node_count);
    METHOD(int64_t, get_frame);
    METHOD(Variant, quit);
    METHOD(void, set_physics_interpolation_enabled);
    METHOD(bool, is_physics_interpolation_enabled);
    METHOD(Variant, queue_delete);
    METHOD(Variant, call_group_flags);
    METHOD(Variant, notify_group_flags);
    METHOD(void, set_group_flags);
    METHOD(Variant, call_group);
    METHOD(Variant, notify_group);
    METHOD(void, set_group);
    METHOD(Array, get_nodes_in_group);
    METHOD(Object, get_first_node_in_group);
    METHOD(int64_t, get_node_count_in_group);
    METHOD(void, set_current_scene);
    METHOD(Object, get_current_scene);
    METHOD(int64_t, change_scene_to_file);
    METHOD(int64_t, change_scene_to_packed);
    METHOD(int64_t, reload_current_scene);
    METHOD(Variant, unload_current_scene);
    METHOD(void, set_multiplayer);
    METHOD(Object, get_multiplayer);
    METHOD(void, set_multiplayer_poll_enabled);
    METHOD(bool, is_multiplayer_poll_enabled);
    static constexpr int64_t GROUP_CALL_DEFAULT = 0;
    static constexpr int64_t GROUP_CALL_REVERSE = 1;
    static constexpr int64_t GROUP_CALL_DEFERRED = 2;
    static constexpr int64_t GROUP_CALL_UNIQUE = 4;
};
struct SceneTreeTimer : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(time_left, double);
    METHOD(void, set_time_left);
    METHOD(double, get_time_left);
};
struct Script : public Resource {
    using Resource::Resource;
    PROPERTY(source_code, String);
    METHOD(bool, can_instantiate);
    METHOD(bool, instance_has);
    METHOD(bool, has_source_code);
    METHOD(String, get_source_code);
    METHOD(void, set_source_code);
    METHOD(int64_t, reload);
    METHOD(Object, get_base_script);
    METHOD(String, get_instance_base_type);
    METHOD(String, get_global_name);
    METHOD(bool, has_script_signal);
    METHOD(Array, get_script_property_list);
    METHOD(Array, get_script_method_list);
    METHOD(Array, get_script_signal_list);
    METHOD(Dictionary, get_script_constant_map);
    METHOD(Variant, get_property_default_value);
    METHOD(bool, is_tool);
    METHOD(bool, is_abstract);
};
struct ScriptExtension : public Script {
    using Script::Script;
    METHOD(bool, _editor_can_reload_from_file);
    METHOD(Variant, _placeholder_erased);
    METHOD(bool, _can_instantiate);
    METHOD(Object, _get_base_script);
    METHOD(String, _get_global_name);
    METHOD(bool, _inherits_script);
    METHOD(String, _get_instance_base_type);
    METHOD(int64_t, _instance_create);
    METHOD(int64_t, _placeholder_instance_create);
    METHOD(bool, _instance_has);
    METHOD(bool, _has_source_code);
    METHOD(String, _get_source_code);
    METHOD(Variant, _set_source_code);
    METHOD(int64_t, _reload);
    METHOD(Array, _get_documentation);
    METHOD(String, _get_class_icon_path);
    METHOD(bool, _has_method);
    METHOD(bool, _has_static_method);
    METHOD(Variant, _get_script_method_argument_count);
    METHOD(Dictionary, _get_method_info);
    METHOD(bool, _is_tool);
    METHOD(bool, _is_valid);
    METHOD(bool, _is_abstract);
    METHOD(Object, _get_language);
    METHOD(bool, _has_script_signal);
    METHOD(Array, _get_script_signal_list);
    METHOD(bool, _has_property_default_value);
    METHOD(Variant, _get_property_default_value);
    METHOD(Variant, _update_exports);
    METHOD(Array, _get_script_method_list);
    METHOD(Array, _get_script_property_list);
    METHOD(int64_t, _get_member_line);
    METHOD(Dictionary, _get_constants);
    METHOD(Array, _get_members);
    METHOD(bool, _is_placeholder_fallback_enabled);
    METHOD(Variant, _get_rpc_config);
};
struct ScriptLanguage : public Object {
    using Object::Object;
    static constexpr int64_t SCRIPT_NAME_CASING_AUTO = 0;
    static constexpr int64_t SCRIPT_NAME_CASING_PASCAL_CASE = 1;
    static constexpr int64_t SCRIPT_NAME_CASING_SNAKE_CASE = 2;
    static constexpr int64_t SCRIPT_NAME_CASING_KEBAB_CASE = 3;
};
struct ScriptLanguageExtension : public ScriptLanguage {
    using ScriptLanguage::ScriptLanguage;
    METHOD(String, _get_name);
    METHOD(Variant, _init);
    METHOD(String, _get_type);
    METHOD(String, _get_extension);
    METHOD(Variant, _finish);
    METHOD(PackedArray<std::string>, _get_reserved_words);
    METHOD(bool, _is_control_flow_keyword);
    METHOD(PackedArray<std::string>, _get_comment_delimiters);
    METHOD(PackedArray<std::string>, _get_doc_comment_delimiters);
    METHOD(PackedArray<std::string>, _get_string_delimiters);
    METHOD(Object, _make_template);
    METHOD(Array, _get_built_in_templates);
    METHOD(bool, _is_using_templates);
    METHOD(Dictionary, _validate);
    METHOD(String, _validate_path);
    METHOD(Object, _create_script);
    METHOD(bool, _has_named_classes);
    METHOD(bool, _supports_builtin_mode);
    METHOD(bool, _supports_documentation);
    METHOD(bool, _can_inherit_from_file);
    METHOD(int64_t, _find_function);
    METHOD(String, _make_function);
    METHOD(bool, _can_make_function);
    METHOD(int64_t, _open_in_external_editor);
    METHOD(bool, _overrides_external_editor);
    METHOD(int64_t, _preferred_file_name_casing);
    METHOD(Dictionary, _complete_code);
    METHOD(Dictionary, _lookup_code);
    METHOD(String, _auto_indent_code);
    METHOD(Variant, _add_global_constant);
    METHOD(Variant, _add_named_global_constant);
    METHOD(Variant, _remove_named_global_constant);
    METHOD(Variant, _thread_enter);
    METHOD(Variant, _thread_exit);
    METHOD(String, _debug_get_error);
    METHOD(int64_t, _debug_get_stack_level_count);
    METHOD(int64_t, _debug_get_stack_level_line);
    METHOD(String, _debug_get_stack_level_function);
    METHOD(String, _debug_get_stack_level_source);
    METHOD(Dictionary, _debug_get_stack_level_locals);
    METHOD(Dictionary, _debug_get_stack_level_members);
    METHOD(int64_t, _debug_get_stack_level_instance);
    METHOD(Dictionary, _debug_get_globals);
    METHOD(String, _debug_parse_stack_level_expression);
    METHOD(Array, _debug_get_current_stack_info);
    METHOD(Variant, _reload_all_scripts);
    METHOD(Variant, _reload_tool_script);
    METHOD(PackedArray<std::string>, _get_recognized_extensions);
    METHOD(Array, _get_public_functions);
    METHOD(Dictionary, _get_public_constants);
    METHOD(Array, _get_public_annotations);
    METHOD(Variant, _profiling_start);
    METHOD(Variant, _profiling_stop);
    METHOD(Variant, _profiling_set_save_native_calls);
    METHOD(int64_t, _profiling_get_accumulated_data);
    METHOD(int64_t, _profiling_get_frame_data);
    METHOD(Variant, _frame);
    METHOD(bool, _handles_global_class_type);
    METHOD(Dictionary, _get_global_class_name);
    static constexpr int64_t LOOKUP_RESULT_SCRIPT_LOCATION = 0;
    static constexpr int64_t LOOKUP_RESULT_CLASS = 1;
    static constexpr int64_t LOOKUP_RESULT_CLASS_CONSTANT = 2;
    static constexpr int64_t LOOKUP_RESULT_CLASS_PROPERTY = 3;
    static constexpr int64_t LOOKUP_RESULT_CLASS_METHOD = 4;
    static constexpr int64_t LOOKUP_RESULT_CLASS_SIGNAL = 5;
    static constexpr int64_t LOOKUP_RESULT_CLASS_ENUM = 6;
    static constexpr int64_t LOOKUP_RESULT_CLASS_TBD_GLOBALSCOPE = 7;
    static constexpr int64_t LOOKUP_RESULT_CLASS_ANNOTATION = 8;
    static constexpr int64_t LOOKUP_RESULT_MAX = 9;
    static constexpr int64_t LOCATION_LOCAL = 0;
    static constexpr int64_t LOCATION_PARENT_MASK = 256;
    static constexpr int64_t LOCATION_OTHER_USER_CODE = 512;
    static constexpr int64_t LOCATION_OTHER = 1024;
    static constexpr int64_t CODE_COMPLETION_KIND_CLASS = 0;
    static constexpr int64_t CODE_COMPLETION_KIND_FUNCTION = 1;
    static constexpr int64_t CODE_COMPLETION_KIND_SIGNAL = 2;
    static constexpr int64_t CODE_COMPLETION_KIND_VARIABLE = 3;
    static constexpr int64_t CODE_COMPLETION_KIND_MEMBER = 4;
    static constexpr int64_t CODE_COMPLETION_KIND_ENUM = 5;
    static constexpr int64_t CODE_COMPLETION_KIND_CONSTANT = 6;
    static constexpr int64_t CODE_COMPLETION_KIND_NODE_PATH = 7;
    static constexpr int64_t CODE_COMPLETION_KIND_FILE_PATH = 8;
    static constexpr int64_t CODE_COMPLETION_KIND_PLAIN_TEXT = 9;
    static constexpr int64_t CODE_COMPLETION_KIND_MAX = 10;
};
struct ScrollBar : public Range {
    using Range::Range;
    PROPERTY(custom_step, double);
    METHOD(void, set_custom_step);
    METHOD(double, get_custom_step);
};
struct SectionedInspectorFilter : public Object {
    using Object::Object;
};
struct Semaphore : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, wait);
    METHOD(bool, try_wait);
    METHOD(Variant, post);
};
struct Separator : public Control {
    using Control::Control;
};
struct Shader : public Resource {
    using Resource::Resource;
    PROPERTY(code, String);
    METHOD(int64_t, get_mode);
    METHOD(void, set_code);
    METHOD(String, get_code);
    METHOD(void, set_default_texture_parameter);
    METHOD(Object, get_default_texture_parameter);
    METHOD(Array, get_shader_uniform_list);
    static constexpr int64_t MODE_SPATIAL = 0;
    static constexpr int64_t MODE_CANVAS_ITEM = 1;
    static constexpr int64_t MODE_PARTICLES = 2;
    static constexpr int64_t MODE_SKY = 3;
    static constexpr int64_t MODE_FOG = 4;
};
struct ShaderGlobalsOverride : public Node {
    using Node::Node;
    METHOD(Variant, _activate);
};
struct ShaderInclude : public Resource {
    using Resource::Resource;
    PROPERTY(code, String);
    METHOD(void, set_code);
    METHOD(String, get_code);
};
struct Shape2D : public Resource {
    using Resource::Resource;
    PROPERTY(custom_solver_bias, double);
    METHOD(void, set_custom_solver_bias);
    METHOD(double, get_custom_solver_bias);
    METHOD(bool, collide);
    METHOD(bool, collide_with_motion);
    METHOD(PackedArray<Vector2>, collide_and_get_contacts);
    METHOD(PackedArray<Vector2>, collide_with_motion_and_get_contacts);
    METHOD(Variant, draw);
    METHOD(Rect2, get_rect);
};
struct Shape3D : public Resource {
    using Resource::Resource;
    PROPERTY(custom_solver_bias, double);
    PROPERTY(margin, double);
    METHOD(void, set_custom_solver_bias);
    METHOD(double, get_custom_solver_bias);
    METHOD(void, set_margin);
    METHOD(double, get_margin);
    METHOD(Object, get_debug_mesh);
};
struct ShapeCast2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(enabled, bool);
    PROPERTY(shape, Object);
    PROPERTY(exclude_parent, bool);
    PROPERTY(target_position, Vector2);
    PROPERTY(margin, double);
    PROPERTY(max_results, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(collision_result, Array);
    PROPERTY(collide_with_areas, bool);
    PROPERTY(collide_with_bodies, bool);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(void, set_target_position);
    METHOD(Vector2, get_target_position);
    METHOD(void, set_margin);
    METHOD(double, get_margin);
    METHOD(void, set_max_results);
    METHOD(int64_t, get_max_results);
    METHOD(bool, is_colliding);
    METHOD(int64_t, get_collision_count);
    METHOD(Variant, force_shapecast_update);
    METHOD(Object, get_collider);
    METHOD(::RID, get_collider_rid);
    METHOD(int64_t, get_collider_shape);
    METHOD(Vector2, get_collision_point);
    METHOD(Vector2, get_collision_normal);
    METHOD(double, get_closest_collision_safe_fraction);
    METHOD(double, get_closest_collision_unsafe_fraction);
    METHOD(Variant, add_exception_rid);
    METHOD(Variant, add_exception);
    METHOD(Variant, remove_exception_rid);
    METHOD(Variant, remove_exception);
    METHOD(Variant, clear_exceptions);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_exclude_parent_body);
    METHOD(bool, get_exclude_parent_body);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(Array, _get_collision_result);
};
struct ShapeCast3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(enabled, bool);
    PROPERTY(shape, Object);
    PROPERTY(exclude_parent, bool);
    PROPERTY(target_position, Vector3);
    PROPERTY(margin, double);
    PROPERTY(max_results, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(collision_result, Array);
    PROPERTY(collide_with_areas, bool);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(debug_shape_custom_color, Color);
    METHOD(Variant, resource_changed);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(void, set_target_position);
    METHOD(Vector3, get_target_position);
    METHOD(void, set_margin);
    METHOD(double, get_margin);
    METHOD(void, set_max_results);
    METHOD(int64_t, get_max_results);
    METHOD(bool, is_colliding);
    METHOD(int64_t, get_collision_count);
    METHOD(Variant, force_shapecast_update);
    METHOD(Object, get_collider);
    METHOD(::RID, get_collider_rid);
    METHOD(int64_t, get_collider_shape);
    METHOD(Vector3, get_collision_point);
    METHOD(Vector3, get_collision_normal);
    METHOD(double, get_closest_collision_safe_fraction);
    METHOD(double, get_closest_collision_unsafe_fraction);
    METHOD(Variant, add_exception_rid);
    METHOD(Variant, add_exception);
    METHOD(Variant, remove_exception_rid);
    METHOD(Variant, remove_exception);
    METHOD(Variant, clear_exceptions);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_exclude_parent_body);
    METHOD(bool, get_exclude_parent_body);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(Array, _get_collision_result);
    METHOD(void, set_debug_shape_custom_color);
    METHOD(Color, get_debug_shape_custom_color);
};
struct Shortcut : public Resource {
    using Resource::Resource;
    PROPERTY(events, Array);
    METHOD(void, set_events);
    METHOD(Array, get_events);
    METHOD(bool, has_valid_event);
    METHOD(bool, matches_event);
    METHOD(String, get_as_text);
};
struct ShortcutBin : public Node {
    using Node::Node;
};
struct Skeleton2D : public Node2D {
    using Node2D::Node2D;
    METHOD(int64_t, get_bone_count);
    METHOD(Object, get_bone);
    METHOD(::RID, get_skeleton);
    METHOD(void, set_modification_stack);
    METHOD(Object, get_modification_stack);
    METHOD(Variant, execute_modifications);
    METHOD(void, set_bone_local_pose_override);
    METHOD(Transform2D, get_bone_local_pose_override);
};
struct Skeleton3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(motion_scale, double);
    PROPERTY(show_rest_only, bool);
    PROPERTY(modifier_callback_mode_process, int64_t);
    PROPERTY(animate_physical_bones, bool);
    METHOD(int64_t, add_bone);
    METHOD(int64_t, find_bone);
    METHOD(String, get_bone_name);
    METHOD(void, set_bone_name);
    METHOD(String, get_concatenated_bone_names);
    METHOD(int64_t, get_bone_parent);
    METHOD(void, set_bone_parent);
    METHOD(int64_t, get_bone_count);
    METHOD(int64_t, get_version);
    METHOD(Variant, unparent_bone_and_rest);
    METHOD(PackedArray<int32_t>, get_bone_children);
    METHOD(PackedArray<int32_t>, get_parentless_bones);
    METHOD(Transform3D, get_bone_rest);
    METHOD(void, set_bone_rest);
    METHOD(Transform3D, get_bone_global_rest);
    METHOD(Object, create_skin_from_rest_transforms);
    METHOD(Object, register_skin);
    METHOD(Variant, localize_rests);
    METHOD(Variant, clear_bones);
    METHOD(Transform3D, get_bone_pose);
    METHOD(void, set_bone_pose);
    METHOD(void, set_bone_pose_position);
    METHOD(void, set_bone_pose_rotation);
    METHOD(void, set_bone_pose_scale);
    METHOD(Vector3, get_bone_pose_position);
    METHOD(Quaternion, get_bone_pose_rotation);
    METHOD(Vector3, get_bone_pose_scale);
    METHOD(Variant, reset_bone_pose);
    METHOD(Variant, reset_bone_poses);
    METHOD(bool, is_bone_enabled);
    METHOD(void, set_bone_enabled);
    METHOD(Transform3D, get_bone_global_pose);
    METHOD(void, set_bone_global_pose);
    METHOD(Variant, force_update_all_bone_transforms);
    METHOD(Variant, force_update_bone_child_transform);
    METHOD(void, set_motion_scale);
    METHOD(double, get_motion_scale);
    METHOD(void, set_show_rest_only);
    METHOD(bool, is_show_rest_only);
    METHOD(void, set_modifier_callback_mode_process);
    METHOD(int64_t, get_modifier_callback_mode_process);
    METHOD(Variant, clear_bones_global_pose_override);
    METHOD(void, set_bone_global_pose_override);
    METHOD(Transform3D, get_bone_global_pose_override);
    METHOD(Transform3D, get_bone_global_pose_no_override);
    METHOD(void, set_animate_physical_bones);
    METHOD(bool, get_animate_physical_bones);
    METHOD(Variant, physical_bones_stop_simulation);
    METHOD(Variant, physical_bones_start_simulation);
    METHOD(Variant, physical_bones_add_collision_exception);
    METHOD(Variant, physical_bones_remove_collision_exception);
    static constexpr int64_t NOTIFICATION_UPDATE_SKELETON = 50;
    static constexpr int64_t MODIFIER_CALLBACK_MODE_PROCESS_PHYSICS = 0;
    static constexpr int64_t MODIFIER_CALLBACK_MODE_PROCESS_IDLE = 1;
};
struct SkeletonModification2D : public Resource {
    using Resource::Resource;
    PROPERTY(enabled, bool);
    PROPERTY(execution_mode, int64_t);
    METHOD(Variant, _execute);
    METHOD(Variant, _setup_modification);
    METHOD(Variant, _draw_editor_gizmo);
    METHOD(void, set_enabled);
    METHOD(bool, get_enabled);
    METHOD(Object, get_modification_stack);
    METHOD(void, set_is_setup);
    METHOD(bool, get_is_setup);
    METHOD(void, set_execution_mode);
    METHOD(int64_t, get_execution_mode);
    METHOD(double, clamp_angle);
    METHOD(void, set_editor_draw_gizmo);
    METHOD(bool, get_editor_draw_gizmo);
};
struct SkeletonModification2DCCDIK : public SkeletonModification2D {
    using SkeletonModification2D::SkeletonModification2D;
    PROPERTY(target_nodepath, String);
    PROPERTY(tip_nodepath, String);
    PROPERTY(ccdik_data_chain_length, int64_t);
    METHOD(void, set_target_node);
    METHOD(String, get_target_node);
    METHOD(void, set_tip_node);
    METHOD(String, get_tip_node);
    METHOD(void, set_ccdik_data_chain_length);
    METHOD(int64_t, get_ccdik_data_chain_length);
    METHOD(void, set_ccdik_joint_bone2d_node);
    METHOD(String, get_ccdik_joint_bone2d_node);
    METHOD(void, set_ccdik_joint_bone_index);
    METHOD(int64_t, get_ccdik_joint_bone_index);
    METHOD(void, set_ccdik_joint_rotate_from_joint);
    METHOD(bool, get_ccdik_joint_rotate_from_joint);
    METHOD(void, set_ccdik_joint_enable_constraint);
    METHOD(bool, get_ccdik_joint_enable_constraint);
    METHOD(void, set_ccdik_joint_constraint_angle_min);
    METHOD(double, get_ccdik_joint_constraint_angle_min);
    METHOD(void, set_ccdik_joint_constraint_angle_max);
    METHOD(double, get_ccdik_joint_constraint_angle_max);
    METHOD(void, set_ccdik_joint_constraint_angle_invert);
    METHOD(bool, get_ccdik_joint_constraint_angle_invert);
};
struct SkeletonModification2DFABRIK : public SkeletonModification2D {
    using SkeletonModification2D::SkeletonModification2D;
    PROPERTY(target_nodepath, String);
    PROPERTY(fabrik_data_chain_length, int64_t);
    METHOD(void, set_target_node);
    METHOD(String, get_target_node);
    METHOD(void, set_fabrik_data_chain_length);
    METHOD(int64_t, get_fabrik_data_chain_length);
    METHOD(void, set_fabrik_joint_bone2d_node);
    METHOD(String, get_fabrik_joint_bone2d_node);
    METHOD(void, set_fabrik_joint_bone_index);
    METHOD(int64_t, get_fabrik_joint_bone_index);
    METHOD(void, set_fabrik_joint_magnet_position);
    METHOD(Vector2, get_fabrik_joint_magnet_position);
    METHOD(void, set_fabrik_joint_use_target_rotation);
    METHOD(bool, get_fabrik_joint_use_target_rotation);
};
struct SkeletonModification2DJiggle : public SkeletonModification2D {
    using SkeletonModification2D::SkeletonModification2D;
    PROPERTY(target_nodepath, String);
    PROPERTY(jiggle_data_chain_length, int64_t);
    PROPERTY(stiffness, double);
    PROPERTY(mass, double);
    PROPERTY(damping, double);
    PROPERTY(use_gravity, bool);
    PROPERTY(gravity, Vector2);
    METHOD(void, set_target_node);
    METHOD(String, get_target_node);
    METHOD(void, set_jiggle_data_chain_length);
    METHOD(int64_t, get_jiggle_data_chain_length);
    METHOD(void, set_stiffness);
    METHOD(double, get_stiffness);
    METHOD(void, set_mass);
    METHOD(double, get_mass);
    METHOD(void, set_damping);
    METHOD(double, get_damping);
    METHOD(void, set_use_gravity);
    METHOD(bool, get_use_gravity);
    METHOD(void, set_gravity);
    METHOD(Vector2, get_gravity);
    METHOD(void, set_use_colliders);
    METHOD(bool, get_use_colliders);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_jiggle_joint_bone2d_node);
    METHOD(String, get_jiggle_joint_bone2d_node);
    METHOD(void, set_jiggle_joint_bone_index);
    METHOD(int64_t, get_jiggle_joint_bone_index);
    METHOD(void, set_jiggle_joint_override);
    METHOD(bool, get_jiggle_joint_override);
    METHOD(void, set_jiggle_joint_stiffness);
    METHOD(double, get_jiggle_joint_stiffness);
    METHOD(void, set_jiggle_joint_mass);
    METHOD(double, get_jiggle_joint_mass);
    METHOD(void, set_jiggle_joint_damping);
    METHOD(double, get_jiggle_joint_damping);
    METHOD(void, set_jiggle_joint_use_gravity);
    METHOD(bool, get_jiggle_joint_use_gravity);
    METHOD(void, set_jiggle_joint_gravity);
    METHOD(Vector2, get_jiggle_joint_gravity);
};
struct SkeletonModification2DLookAt : public SkeletonModification2D {
    using SkeletonModification2D::SkeletonModification2D;
    PROPERTY(bone_index, int64_t);
    PROPERTY(bone2d_node, String);
    PROPERTY(target_nodepath, String);
    METHOD(void, set_bone2d_node);
    METHOD(String, get_bone2d_node);
    METHOD(void, set_bone_index);
    METHOD(int64_t, get_bone_index);
    METHOD(void, set_target_node);
    METHOD(String, get_target_node);
    METHOD(void, set_additional_rotation);
    METHOD(double, get_additional_rotation);
    METHOD(void, set_enable_constraint);
    METHOD(bool, get_enable_constraint);
    METHOD(void, set_constraint_angle_min);
    METHOD(double, get_constraint_angle_min);
    METHOD(void, set_constraint_angle_max);
    METHOD(double, get_constraint_angle_max);
    METHOD(void, set_constraint_angle_invert);
    METHOD(bool, get_constraint_angle_invert);
};
struct SkeletonModification2DPhysicalBones : public SkeletonModification2D {
    using SkeletonModification2D::SkeletonModification2D;
    PROPERTY(physical_bone_chain_length, int64_t);
    METHOD(void, set_physical_bone_chain_length);
    METHOD(int64_t, get_physical_bone_chain_length);
    METHOD(void, set_physical_bone_node);
    METHOD(String, get_physical_bone_node);
    METHOD(Variant, fetch_physical_bones);
    METHOD(Variant, start_simulation);
    METHOD(Variant, stop_simulation);
};
struct SkeletonModification2DStackHolder : public SkeletonModification2D {
    using SkeletonModification2D::SkeletonModification2D;
    METHOD(void, set_held_modification_stack);
    METHOD(Object, get_held_modification_stack);
};
struct SkeletonModification2DTwoBoneIK : public SkeletonModification2D {
    using SkeletonModification2D::SkeletonModification2D;
    PROPERTY(target_nodepath, String);
    PROPERTY(target_minimum_distance, double);
    PROPERTY(target_maximum_distance, double);
    PROPERTY(flip_bend_direction, bool);
    METHOD(void, set_target_node);
    METHOD(String, get_target_node);
    METHOD(void, set_target_minimum_distance);
    METHOD(double, get_target_minimum_distance);
    METHOD(void, set_target_maximum_distance);
    METHOD(double, get_target_maximum_distance);
    METHOD(void, set_flip_bend_direction);
    METHOD(bool, get_flip_bend_direction);
    METHOD(void, set_joint_one_bone2d_node);
    METHOD(String, get_joint_one_bone2d_node);
    METHOD(void, set_joint_one_bone_idx);
    METHOD(int64_t, get_joint_one_bone_idx);
    METHOD(void, set_joint_two_bone2d_node);
    METHOD(String, get_joint_two_bone2d_node);
    METHOD(void, set_joint_two_bone_idx);
    METHOD(int64_t, get_joint_two_bone_idx);
};
struct SkeletonModificationStack2D : public Resource {
    using Resource::Resource;
    PROPERTY(enabled, bool);
    PROPERTY(strength, double);
    PROPERTY(modification_count, int64_t);
    METHOD(Variant, setup);
    METHOD(Variant, execute);
    METHOD(Variant, enable_all_modifications);
    METHOD(Object, get_modification);
    METHOD(Variant, add_modification);
    METHOD(Variant, delete_modification);
    METHOD(void, set_modification);
    METHOD(void, set_modification_count);
    METHOD(int64_t, get_modification_count);
    METHOD(bool, get_is_setup);
    METHOD(void, set_enabled);
    METHOD(bool, get_enabled);
    METHOD(void, set_strength);
    METHOD(double, get_strength);
    METHOD(Object, get_skeleton);
};
struct SkeletonModifier3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(active, bool);
    PROPERTY(influence, double);
    METHOD(Variant, _process_modification);
    METHOD(Object, get_skeleton);
    METHOD(void, set_active);
    METHOD(bool, is_active);
    METHOD(void, set_influence);
    METHOD(double, get_influence);
};
struct SkeletonProfile : public Resource {
    using Resource::Resource;
    PROPERTY(root_bone, String);
    PROPERTY(scale_base_bone, String);
    PROPERTY(group_size, int64_t);
    PROPERTY(bone_size, int64_t);
    METHOD(void, set_root_bone);
    METHOD(String, get_root_bone);
    METHOD(void, set_scale_base_bone);
    METHOD(String, get_scale_base_bone);
    METHOD(void, set_group_size);
    METHOD(int64_t, get_group_size);
    METHOD(String, get_group_name);
    METHOD(void, set_group_name);
    METHOD(Object, get_texture);
    METHOD(void, set_texture);
    METHOD(void, set_bone_size);
    METHOD(int64_t, get_bone_size);
    METHOD(int64_t, find_bone);
    METHOD(String, get_bone_name);
    METHOD(void, set_bone_name);
    METHOD(String, get_bone_parent);
    METHOD(void, set_bone_parent);
    METHOD(int64_t, get_tail_direction);
    METHOD(void, set_tail_direction);
    METHOD(String, get_bone_tail);
    METHOD(void, set_bone_tail);
    METHOD(Transform3D, get_reference_pose);
    METHOD(void, set_reference_pose);
    METHOD(Vector2, get_handle_offset);
    METHOD(void, set_handle_offset);
    METHOD(String, get_group);
    METHOD(void, set_group);
    METHOD(bool, is_required);
    METHOD(void, set_required);
    static constexpr int64_t TAIL_DIRECTION_AVERAGE_CHILDREN = 0;
    static constexpr int64_t TAIL_DIRECTION_SPECIFIC_CHILD = 1;
    static constexpr int64_t TAIL_DIRECTION_END = 2;
};
struct SkeletonProfileHumanoid : public SkeletonProfile {
    using SkeletonProfile::SkeletonProfile;
};
struct Skin : public Resource {
    using Resource::Resource;
    METHOD(void, set_bind_count);
    METHOD(int64_t, get_bind_count);
    METHOD(Variant, add_bind);
    METHOD(Variant, add_named_bind);
    METHOD(void, set_bind_pose);
    METHOD(Transform3D, get_bind_pose);
    METHOD(void, set_bind_name);
    METHOD(String, get_bind_name);
    METHOD(void, set_bind_bone);
    METHOD(int64_t, get_bind_bone);
    METHOD(Variant, clear_binds);
};
struct SkinReference : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(::RID, get_skeleton);
    METHOD(Object, get_skin);
};
struct Sky : public Resource {
    using Resource::Resource;
    PROPERTY(sky_material, Object);
    PROPERTY(process_mode, int64_t);
    PROPERTY(radiance_size, int64_t);
    METHOD(void, set_radiance_size);
    METHOD(int64_t, get_radiance_size);
    METHOD(void, set_process_mode);
    METHOD(int64_t, get_process_mode);
    METHOD(void, set_material);
    METHOD(Object, get_material);
    static constexpr int64_t RADIANCE_SIZE_32 = 0;
    static constexpr int64_t RADIANCE_SIZE_64 = 1;
    static constexpr int64_t RADIANCE_SIZE_128 = 2;
    static constexpr int64_t RADIANCE_SIZE_256 = 3;
    static constexpr int64_t RADIANCE_SIZE_512 = 4;
    static constexpr int64_t RADIANCE_SIZE_1024 = 5;
    static constexpr int64_t RADIANCE_SIZE_2048 = 6;
    static constexpr int64_t RADIANCE_SIZE_MAX = 7;
    static constexpr int64_t PROCESS_MODE_AUTOMATIC = 0;
    static constexpr int64_t PROCESS_MODE_QUALITY = 1;
    static constexpr int64_t PROCESS_MODE_INCREMENTAL = 2;
    static constexpr int64_t PROCESS_MODE_REALTIME = 3;
};
struct Slider : public Range {
    using Range::Range;
    PROPERTY(editable, bool);
    PROPERTY(scrollable, bool);
    PROPERTY(tick_count, int64_t);
    PROPERTY(ticks_on_borders, bool);
    METHOD(void, set_ticks);
    METHOD(int64_t, get_ticks);
    METHOD(bool, get_ticks_on_borders);
    METHOD(void, set_ticks_on_borders);
    METHOD(void, set_editable);
    METHOD(bool, is_editable);
    METHOD(void, set_scrollable);
    METHOD(bool, is_scrollable);
};
struct SliderJoint3D : public Joint3D {
    using Joint3D::Joint3D;
    METHOD(void, set_param);
    METHOD(double, get_param);
    static constexpr int64_t PARAM_LINEAR_LIMIT_UPPER = 0;
    static constexpr int64_t PARAM_LINEAR_LIMIT_LOWER = 1;
    static constexpr int64_t PARAM_LINEAR_LIMIT_SOFTNESS = 2;
    static constexpr int64_t PARAM_LINEAR_LIMIT_RESTITUTION = 3;
    static constexpr int64_t PARAM_LINEAR_LIMIT_DAMPING = 4;
    static constexpr int64_t PARAM_LINEAR_MOTION_SOFTNESS = 5;
    static constexpr int64_t PARAM_LINEAR_MOTION_RESTITUTION = 6;
    static constexpr int64_t PARAM_LINEAR_MOTION_DAMPING = 7;
    static constexpr int64_t PARAM_LINEAR_ORTHOGONAL_SOFTNESS = 8;
    static constexpr int64_t PARAM_LINEAR_ORTHOGONAL_RESTITUTION = 9;
    static constexpr int64_t PARAM_LINEAR_ORTHOGONAL_DAMPING = 10;
    static constexpr int64_t PARAM_ANGULAR_LIMIT_UPPER = 11;
    static constexpr int64_t PARAM_ANGULAR_LIMIT_LOWER = 12;
    static constexpr int64_t PARAM_ANGULAR_LIMIT_SOFTNESS = 13;
    static constexpr int64_t PARAM_ANGULAR_LIMIT_RESTITUTION = 14;
    static constexpr int64_t PARAM_ANGULAR_LIMIT_DAMPING = 15;
    static constexpr int64_t PARAM_ANGULAR_MOTION_SOFTNESS = 16;
    static constexpr int64_t PARAM_ANGULAR_MOTION_RESTITUTION = 17;
    static constexpr int64_t PARAM_ANGULAR_MOTION_DAMPING = 18;
    static constexpr int64_t PARAM_ANGULAR_ORTHOGONAL_SOFTNESS = 19;
    static constexpr int64_t PARAM_ANGULAR_ORTHOGONAL_RESTITUTION = 20;
    static constexpr int64_t PARAM_ANGULAR_ORTHOGONAL_DAMPING = 21;
    static constexpr int64_t PARAM_MAX = 22;
};
struct SphereShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(radius, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
};
struct SpinBox : public Range {
    using Range::Range;
    PROPERTY(alignment, int64_t);
    PROPERTY(editable, bool);
    PROPERTY(update_on_text_changed, bool);
    PROPERTY(prefix, String);
    PROPERTY(suffix, String);
    PROPERTY(custom_arrow_step, double);
    PROPERTY(select_all_on_focus, bool);
    METHOD(void, set_horizontal_alignment);
    METHOD(int64_t, get_horizontal_alignment);
    METHOD(void, set_suffix);
    METHOD(String, get_suffix);
    METHOD(void, set_prefix);
    METHOD(String, get_prefix);
    METHOD(void, set_editable);
    METHOD(void, set_custom_arrow_step);
    METHOD(double, get_custom_arrow_step);
    METHOD(bool, is_editable);
    METHOD(void, set_update_on_text_changed);
    METHOD(bool, get_update_on_text_changed);
    METHOD(void, set_select_all_on_focus);
    METHOD(bool, is_select_all_on_focus);
    METHOD(Variant, apply);
    METHOD(Object, get_line_edit);
};
struct SplitContainerDragger : public Control {
    using Control::Control;
};
struct SpringArm3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(collision_mask, int64_t);
    PROPERTY(shape, Object);
    PROPERTY(spring_length, double);
    PROPERTY(margin, double);
    METHOD(double, get_hit_length);
    METHOD(void, set_length);
    METHOD(double, get_length);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(Variant, add_excluded_object);
    METHOD(bool, remove_excluded_object);
    METHOD(Variant, clear_excluded_objects);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_margin);
    METHOD(double, get_margin);
};
struct Sprite2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(texture, Object);
    PROPERTY(centered, bool);
    PROPERTY(offset, Vector2);
    PROPERTY(flip_h, bool);
    PROPERTY(flip_v, bool);
    PROPERTY(hframes, int64_t);
    PROPERTY(vframes, int64_t);
    PROPERTY(frame, int64_t);
    PROPERTY(frame_coords, Vector2i);
    PROPERTY(region_enabled, bool);
    PROPERTY(region_rect, Rect2);
    PROPERTY(region_filter_clip_enabled, bool);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_centered);
    METHOD(bool, is_centered);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_flip_h);
    METHOD(bool, is_flipped_h);
    METHOD(void, set_flip_v);
    METHOD(bool, is_flipped_v);
    METHOD(void, set_region_enabled);
    METHOD(bool, is_region_enabled);
    METHOD(bool, is_pixel_opaque);
    METHOD(void, set_region_rect);
    METHOD(Rect2, get_region_rect);
    METHOD(void, set_region_filter_clip_enabled);
    METHOD(bool, is_region_filter_clip_enabled);
    METHOD(void, set_frame);
    METHOD(int64_t, get_frame);
    METHOD(void, set_frame_coords);
    METHOD(Vector2i, get_frame_coords);
    METHOD(void, set_vframes);
    METHOD(int64_t, get_vframes);
    METHOD(void, set_hframes);
    METHOD(int64_t, get_hframes);
    METHOD(Rect2, get_rect);
};
struct SpriteFrames : public Resource {
    using Resource::Resource;
    PROPERTY(animations, Array);
    METHOD(Variant, add_animation);
    METHOD(bool, has_animation);
    METHOD(Variant, remove_animation);
    METHOD(Variant, rename_animation);
    METHOD(PackedArray<std::string>, get_animation_names);
    METHOD(void, set_animation_speed);
    METHOD(double, get_animation_speed);
    METHOD(void, set_animation_loop);
    METHOD(bool, get_animation_loop);
    METHOD(Variant, add_frame);
    METHOD(void, set_frame);
    METHOD(Variant, remove_frame);
    METHOD(int64_t, get_frame_count);
    METHOD(Object, get_frame_texture);
    METHOD(double, get_frame_duration);
    METHOD(Variant, clear);
    METHOD(Variant, clear_all);
    METHOD(Variant, _set_animations);
    METHOD(Array, _get_animations);
};
struct StaticBody2D : public PhysicsBody2D {
    using PhysicsBody2D::PhysicsBody2D;
    PROPERTY(physics_material_override, Object);
    PROPERTY(constant_linear_velocity, Vector2);
    PROPERTY(constant_angular_velocity, double);
    METHOD(void, set_constant_linear_velocity);
    METHOD(void, set_constant_angular_velocity);
    METHOD(Vector2, get_constant_linear_velocity);
    METHOD(double, get_constant_angular_velocity);
    METHOD(void, set_physics_material_override);
    METHOD(Object, get_physics_material_override);
};
struct StaticBody3D : public PhysicsBody3D {
    using PhysicsBody3D::PhysicsBody3D;
    PROPERTY(physics_material_override, Object);
    PROPERTY(constant_linear_velocity, Vector3);
    PROPERTY(constant_angular_velocity, Vector3);
    METHOD(void, set_constant_linear_velocity);
    METHOD(void, set_constant_angular_velocity);
    METHOD(Vector3, get_constant_linear_velocity);
    METHOD(Vector3, get_constant_angular_velocity);
    METHOD(void, set_physics_material_override);
    METHOD(Object, get_physics_material_override);
};
struct StatusIndicator : public Node {
    using Node::Node;
    PROPERTY(tooltip, String);
    PROPERTY(icon, Object);
    PROPERTY(menu, String);
    PROPERTY(visible, bool);
    METHOD(void, set_tooltip);
    METHOD(String, get_tooltip);
    METHOD(void, set_icon);
    METHOD(Object, get_icon);
    METHOD(void, set_visible);
    METHOD(bool, is_visible);
    METHOD(void, set_menu);
    METHOD(String, get_menu);
    METHOD(Rect2, get_rect);
};
struct StyleBox : public Resource {
    using Resource::Resource;
    PROPERTY(content_margin_left, double);
    PROPERTY(content_margin_top, double);
    PROPERTY(content_margin_right, double);
    PROPERTY(content_margin_bottom, double);
    METHOD(Variant, _draw);
    METHOD(Rect2, _get_draw_rect);
    METHOD(Vector2, _get_minimum_size);
    METHOD(bool, _test_mask);
    METHOD(Vector2, get_minimum_size);
    METHOD(void, set_content_margin);
    METHOD(void, set_content_margin_all);
    METHOD(double, get_content_margin);
    METHOD(double, get_margin);
    METHOD(Vector2, get_offset);
    METHOD(Variant, draw);
    METHOD(Object, get_current_item_drawn);
    METHOD(bool, test_mask);
};
struct StyleBoxEmpty : public StyleBox {
    using StyleBox::StyleBox;
};
struct StyleBoxFlat : public StyleBox {
    using StyleBox::StyleBox;
    PROPERTY(bg_color, Color);
    PROPERTY(draw_center, bool);
    PROPERTY(skew, Vector2);
    PROPERTY(border_width_left, int64_t);
    PROPERTY(border_width_top, int64_t);
    PROPERTY(border_width_right, int64_t);
    PROPERTY(border_width_bottom, int64_t);
    PROPERTY(border_color, Color);
    PROPERTY(border_blend, bool);
    PROPERTY(corner_radius_top_left, int64_t);
    PROPERTY(corner_radius_top_right, int64_t);
    PROPERTY(corner_radius_bottom_right, int64_t);
    PROPERTY(corner_radius_bottom_left, int64_t);
    PROPERTY(corner_detail, int64_t);
    PROPERTY(expand_margin_left, double);
    PROPERTY(expand_margin_top, double);
    PROPERTY(expand_margin_right, double);
    PROPERTY(expand_margin_bottom, double);
    PROPERTY(shadow_color, Color);
    PROPERTY(shadow_size, int64_t);
    PROPERTY(shadow_offset, Vector2);
    PROPERTY(anti_aliasing, bool);
    PROPERTY(anti_aliasing_size, double);
    METHOD(void, set_bg_color);
    METHOD(Color, get_bg_color);
    METHOD(void, set_border_color);
    METHOD(Color, get_border_color);
    METHOD(void, set_border_width_all);
    METHOD(int64_t, get_border_width_min);
    METHOD(void, set_border_width);
    METHOD(int64_t, get_border_width);
    METHOD(void, set_border_blend);
    METHOD(bool, get_border_blend);
    METHOD(void, set_corner_radius_all);
    METHOD(void, set_corner_radius);
    METHOD(int64_t, get_corner_radius);
    METHOD(void, set_expand_margin);
    METHOD(void, set_expand_margin_all);
    METHOD(double, get_expand_margin);
    METHOD(void, set_draw_center);
    METHOD(bool, is_draw_center_enabled);
    METHOD(void, set_skew);
    METHOD(Vector2, get_skew);
    METHOD(void, set_shadow_color);
    METHOD(Color, get_shadow_color);
    METHOD(void, set_shadow_size);
    METHOD(int64_t, get_shadow_size);
    METHOD(void, set_shadow_offset);
    METHOD(Vector2, get_shadow_offset);
    METHOD(void, set_anti_aliased);
    METHOD(bool, is_anti_aliased);
    METHOD(void, set_aa_size);
    METHOD(double, get_aa_size);
    METHOD(void, set_corner_detail);
    METHOD(int64_t, get_corner_detail);
};
struct StyleBoxLine : public StyleBox {
    using StyleBox::StyleBox;
    PROPERTY(color, Color);
    PROPERTY(grow_begin, double);
    PROPERTY(grow_end, double);
    PROPERTY(thickness, int64_t);
    PROPERTY(vertical, bool);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_thickness);
    METHOD(int64_t, get_thickness);
    METHOD(void, set_grow_begin);
    METHOD(double, get_grow_begin);
    METHOD(void, set_grow_end);
    METHOD(double, get_grow_end);
    METHOD(void, set_vertical);
    METHOD(bool, is_vertical);
};
struct StyleBoxTexture : public StyleBox {
    using StyleBox::StyleBox;
    PROPERTY(texture, Object);
    PROPERTY(texture_margin_left, double);
    PROPERTY(texture_margin_top, double);
    PROPERTY(texture_margin_right, double);
    PROPERTY(texture_margin_bottom, double);
    PROPERTY(expand_margin_left, double);
    PROPERTY(expand_margin_top, double);
    PROPERTY(expand_margin_right, double);
    PROPERTY(expand_margin_bottom, double);
    PROPERTY(axis_stretch_horizontal, int64_t);
    PROPERTY(axis_stretch_vertical, int64_t);
    PROPERTY(region_rect, Rect2);
    PROPERTY(modulate_color, Color);
    PROPERTY(draw_center, bool);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_texture_margin);
    METHOD(void, set_texture_margin_all);
    METHOD(double, get_texture_margin);
    METHOD(void, set_expand_margin);
    METHOD(void, set_expand_margin_all);
    METHOD(double, get_expand_margin);
    METHOD(void, set_region_rect);
    METHOD(Rect2, get_region_rect);
    METHOD(void, set_draw_center);
    METHOD(bool, is_draw_center_enabled);
    METHOD(void, set_modulate);
    METHOD(Color, get_modulate);
    METHOD(void, set_h_axis_stretch_mode);
    METHOD(int64_t, get_h_axis_stretch_mode);
    METHOD(void, set_v_axis_stretch_mode);
    METHOD(int64_t, get_v_axis_stretch_mode);
    static constexpr int64_t AXIS_STRETCH_MODE_STRETCH = 0;
    static constexpr int64_t AXIS_STRETCH_MODE_TILE = 1;
    static constexpr int64_t AXIS_STRETCH_MODE_TILE_FIT = 2;
};
struct SurfaceTool : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(void, set_skin_weight_count);
    METHOD(int64_t, get_skin_weight_count);
    METHOD(void, set_custom_format);
    METHOD(int64_t, get_custom_format);
    METHOD(Variant, begin);
    METHOD(Variant, add_vertex);
    METHOD(void, set_color);
    METHOD(void, set_normal);
    METHOD(void, set_tangent);
    METHOD(void, set_uv);
    METHOD(void, set_uv2);
    METHOD(void, set_bones);
    METHOD(void, set_weights);
    METHOD(void, set_custom);
    METHOD(void, set_smooth_group);
    METHOD(Variant, add_triangle_fan);
    METHOD(Variant, add_index);
    METHOD(Variant, index);
    METHOD(Variant, deindex);
    METHOD(Variant, generate_normals);
    METHOD(Variant, generate_tangents);
    METHOD(Variant, optimize_indices_for_cache);
    METHOD(Variant, get_aabb);
    METHOD(PackedArray<int32_t>, generate_lod);
    METHOD(void, set_material);
    METHOD(int64_t, get_primitive_type);
    METHOD(Variant, clear);
    METHOD(Variant, create_from);
    METHOD(Variant, create_from_arrays);
    METHOD(Variant, create_from_blend_shape);
    METHOD(Variant, append_from);
    METHOD(Object, commit);
    METHOD(Array, commit_to_arrays);
    static constexpr int64_t CUSTOM_RGBA8_UNORM = 0;
    static constexpr int64_t CUSTOM_RGBA8_SNORM = 1;
    static constexpr int64_t CUSTOM_RG_HALF = 2;
    static constexpr int64_t CUSTOM_RGBA_HALF = 3;
    static constexpr int64_t CUSTOM_R_FLOAT = 4;
    static constexpr int64_t CUSTOM_RG_FLOAT = 5;
    static constexpr int64_t CUSTOM_RGB_FLOAT = 6;
    static constexpr int64_t CUSTOM_RGBA_FLOAT = 7;
    static constexpr int64_t CUSTOM_MAX = 8;
    static constexpr int64_t SKIN_4_WEIGHTS = 0;
    static constexpr int64_t SKIN_8_WEIGHTS = 1;
};
struct SurfaceUpgradeTool : public Object {
    using Object::Object;
};
struct SyntaxHighlighter : public Resource {
    using Resource::Resource;
    METHOD(Dictionary, _get_line_syntax_highlighting);
    METHOD(Variant, _clear_highlighting_cache);
    METHOD(Variant, _update_cache);
    METHOD(Dictionary, get_line_syntax_highlighting);
    METHOD(Variant, update_cache);
    METHOD(Variant, clear_highlighting_cache);
    METHOD(Object, get_text_edit);
};
struct TCPServer : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, listen);
    METHOD(bool, is_connection_available);
    METHOD(bool, is_listening);
    METHOD(int64_t, get_local_port);
    METHOD(Object, take_connection);
    METHOD(Variant, stop);
};
struct TLSOptions : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Object, client);
    METHOD(Object, client_unsafe);
    METHOD(Object, server);
    METHOD(bool, is_server);
    METHOD(bool, is_unsafe_client);
    METHOD(String, get_common_name_override);
    METHOD(Object, get_trusted_ca_chain);
    METHOD(Object, get_private_key);
    METHOD(Object, get_own_certificate);
};
struct TabBar : public Control {
    using Control::Control;
    PROPERTY(current_tab, int64_t);
    PROPERTY(tab_alignment, int64_t);
    PROPERTY(clip_tabs, bool);
    PROPERTY(tab_close_display_policy, int64_t);
    PROPERTY(max_tab_width, int64_t);
    PROPERTY(scrolling_enabled, bool);
    PROPERTY(drag_to_rearrange_enabled, bool);
    PROPERTY(tabs_rearrange_group, int64_t);
    PROPERTY(scroll_to_selected, bool);
    PROPERTY(select_with_rmb, bool);
    PROPERTY(deselect_enabled, bool);
    PROPERTY(tab_count, int64_t);
    METHOD(void, set_tab_count);
    METHOD(int64_t, get_tab_count);
    METHOD(void, set_current_tab);
    METHOD(int64_t, get_current_tab);
    METHOD(int64_t, get_previous_tab);
    METHOD(bool, select_previous_available);
    METHOD(bool, select_next_available);
    METHOD(void, set_tab_title);
    METHOD(String, get_tab_title);
    METHOD(void, set_tab_tooltip);
    METHOD(String, get_tab_tooltip);
    METHOD(void, set_tab_text_direction);
    METHOD(int64_t, get_tab_text_direction);
    METHOD(void, set_tab_language);
    METHOD(String, get_tab_language);
    METHOD(void, set_tab_icon);
    METHOD(Object, get_tab_icon);
    METHOD(void, set_tab_icon_max_width);
    METHOD(int64_t, get_tab_icon_max_width);
    METHOD(void, set_tab_button_icon);
    METHOD(Object, get_tab_button_icon);
    METHOD(void, set_tab_disabled);
    METHOD(bool, is_tab_disabled);
    METHOD(void, set_tab_hidden);
    METHOD(bool, is_tab_hidden);
    METHOD(void, set_tab_metadata);
    METHOD(Variant, get_tab_metadata);
    METHOD(Variant, remove_tab);
    METHOD(Variant, add_tab);
    METHOD(int64_t, get_tab_idx_at_point);
    METHOD(void, set_tab_alignment);
    METHOD(int64_t, get_tab_alignment);
    METHOD(void, set_clip_tabs);
    METHOD(bool, get_clip_tabs);
    METHOD(int64_t, get_tab_offset);
    METHOD(bool, get_offset_buttons_visible);
    METHOD(Variant, ensure_tab_visible);
    METHOD(Rect2, get_tab_rect);
    METHOD(Variant, move_tab);
    METHOD(void, set_tab_close_display_policy);
    METHOD(int64_t, get_tab_close_display_policy);
    METHOD(void, set_max_tab_width);
    METHOD(int64_t, get_max_tab_width);
    METHOD(void, set_scrolling_enabled);
    METHOD(bool, get_scrolling_enabled);
    METHOD(void, set_drag_to_rearrange_enabled);
    METHOD(bool, get_drag_to_rearrange_enabled);
    METHOD(void, set_tabs_rearrange_group);
    METHOD(int64_t, get_tabs_rearrange_group);
    METHOD(void, set_scroll_to_selected);
    METHOD(bool, get_scroll_to_selected);
    METHOD(void, set_select_with_rmb);
    METHOD(bool, get_select_with_rmb);
    METHOD(void, set_deselect_enabled);
    METHOD(bool, get_deselect_enabled);
    METHOD(Variant, clear_tabs);
    static constexpr int64_t ALIGNMENT_LEFT = 0;
    static constexpr int64_t ALIGNMENT_CENTER = 1;
    static constexpr int64_t ALIGNMENT_RIGHT = 2;
    static constexpr int64_t ALIGNMENT_MAX = 3;
    static constexpr int64_t CLOSE_BUTTON_SHOW_NEVER = 0;
    static constexpr int64_t CLOSE_BUTTON_SHOW_ACTIVE_ONLY = 1;
    static constexpr int64_t CLOSE_BUTTON_SHOW_ALWAYS = 2;
    static constexpr int64_t CLOSE_BUTTON_MAX = 3;
};
struct TextEdit : public Control {
    using Control::Control;
    PROPERTY(text, String);
    PROPERTY(placeholder_text, String);
    PROPERTY(editable, bool);
    PROPERTY(context_menu_enabled, bool);
    PROPERTY(shortcut_keys_enabled, bool);
    PROPERTY(selecting_enabled, bool);
    PROPERTY(deselect_on_focus_loss_enabled, bool);
    PROPERTY(drag_and_drop_selection_enabled, bool);
    PROPERTY(virtual_keyboard_enabled, bool);
    PROPERTY(middle_mouse_paste_enabled, bool);
    PROPERTY(wrap_mode, int64_t);
    PROPERTY(autowrap_mode, int64_t);
    PROPERTY(indent_wrapped_lines, bool);
    PROPERTY(scroll_smooth, bool);
    PROPERTY(scroll_v_scroll_speed, double);
    PROPERTY(scroll_past_end_of_file, bool);
    PROPERTY(scroll_vertical, double);
    PROPERTY(scroll_horizontal, int64_t);
    PROPERTY(scroll_fit_content_height, bool);
    PROPERTY(minimap_draw, bool);
    PROPERTY(minimap_width, int64_t);
    PROPERTY(caret_type, int64_t);
    PROPERTY(caret_blink, bool);
    PROPERTY(caret_blink_interval, double);
    PROPERTY(caret_draw_when_editable_disabled, bool);
    PROPERTY(caret_move_on_right_click, bool);
    PROPERTY(caret_mid_grapheme, bool);
    PROPERTY(caret_multiple, bool);
    PROPERTY(use_default_word_separators, bool);
    PROPERTY(use_custom_word_separators, bool);
    PROPERTY(custom_word_separators, String);
    PROPERTY(syntax_highlighter, Object);
    PROPERTY(highlight_all_occurrences, bool);
    PROPERTY(highlight_current_line, bool);
    PROPERTY(draw_control_chars, bool);
    PROPERTY(draw_tabs, bool);
    PROPERTY(draw_spaces, bool);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    PROPERTY(structured_text_bidi_override, int64_t);
    PROPERTY(structured_text_bidi_override_options, Array);
    METHOD(Variant, _handle_unicode_input);
    METHOD(Variant, _backspace);
    METHOD(Variant, _cut);
    METHOD(Variant, _copy);
    METHOD(Variant, _paste);
    METHOD(Variant, _paste_primary_clipboard);
    METHOD(bool, has_ime_text);
    METHOD(Variant, cancel_ime);
    METHOD(Variant, apply_ime);
    METHOD(void, set_editable);
    METHOD(bool, is_editable);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    METHOD(void, set_tab_size);
    METHOD(int64_t, get_tab_size);
    METHOD(void, set_indent_wrapped_lines);
    METHOD(bool, is_indent_wrapped_lines);
    METHOD(void, set_overtype_mode_enabled);
    METHOD(bool, is_overtype_mode_enabled);
    METHOD(void, set_context_menu_enabled);
    METHOD(bool, is_context_menu_enabled);
    METHOD(void, set_shortcut_keys_enabled);
    METHOD(bool, is_shortcut_keys_enabled);
    METHOD(void, set_virtual_keyboard_enabled);
    METHOD(bool, is_virtual_keyboard_enabled);
    METHOD(void, set_middle_mouse_paste_enabled);
    METHOD(bool, is_middle_mouse_paste_enabled);
    METHOD(Variant, clear);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(int64_t, get_line_count);
    METHOD(void, set_placeholder);
    METHOD(String, get_placeholder);
    METHOD(void, set_line);
    METHOD(String, get_line);
    METHOD(int64_t, get_line_width);
    METHOD(int64_t, get_line_height);
    METHOD(int64_t, get_indent_level);
    METHOD(int64_t, get_first_non_whitespace_column);
    METHOD(Variant, swap_lines);
    METHOD(Variant, insert_line_at);
    METHOD(Variant, remove_line_at);
    METHOD(Variant, insert_text_at_caret);
    METHOD(Variant, insert_text);
    METHOD(Variant, remove_text);
    METHOD(int64_t, get_last_unhidden_line);
    METHOD(int64_t, get_next_visible_line_offset_from);
    METHOD(Vector2i, get_next_visible_line_index_offset_from);
    METHOD(Variant, backspace);
    METHOD(Variant, cut);
    METHOD(Variant, copy);
    METHOD(Variant, paste);
    METHOD(Variant, paste_primary_clipboard);
    METHOD(Variant, start_action);
    METHOD(Variant, end_action);
    METHOD(Variant, begin_complex_operation);
    METHOD(Variant, end_complex_operation);
    METHOD(bool, has_undo);
    METHOD(bool, has_redo);
    METHOD(Variant, undo);
    METHOD(Variant, redo);
    METHOD(Variant, clear_undo_history);
    METHOD(Variant, tag_saved_version);
    METHOD(int64_t, get_version);
    METHOD(int64_t, get_saved_version);
    METHOD(void, set_search_text);
    METHOD(void, set_search_flags);
    METHOD(Vector2i, search);
    METHOD(void, set_tooltip_request_func);
    METHOD(Vector2, get_local_mouse_pos);
    METHOD(String, get_word_at_pos);
    METHOD(Vector2i, get_line_column_at_pos);
    METHOD(Vector2i, get_pos_at_line_column);
    METHOD(Rect2i, get_rect_at_line_column);
    METHOD(int64_t, get_minimap_line_at_pos);
    METHOD(bool, is_dragging_cursor);
    METHOD(bool, is_mouse_over_selection);
    METHOD(void, set_caret_type);
    METHOD(int64_t, get_caret_type);
    METHOD(void, set_caret_blink_enabled);
    METHOD(bool, is_caret_blink_enabled);
    METHOD(void, set_caret_blink_interval);
    METHOD(double, get_caret_blink_interval);
    METHOD(void, set_draw_caret_when_editable_disabled);
    METHOD(bool, is_drawing_caret_when_editable_disabled);
    METHOD(void, set_move_caret_on_right_click_enabled);
    METHOD(bool, is_move_caret_on_right_click_enabled);
    METHOD(void, set_caret_mid_grapheme_enabled);
    METHOD(bool, is_caret_mid_grapheme_enabled);
    METHOD(void, set_multiple_carets_enabled);
    METHOD(bool, is_multiple_carets_enabled);
    METHOD(int64_t, add_caret);
    METHOD(Variant, remove_caret);
    METHOD(Variant, remove_secondary_carets);
    METHOD(int64_t, get_caret_count);
    METHOD(Variant, add_caret_at_carets);
    METHOD(PackedArray<int32_t>, get_sorted_carets);
    METHOD(Variant, collapse_carets);
    METHOD(Variant, merge_overlapping_carets);
    METHOD(Variant, begin_multicaret_edit);
    METHOD(Variant, end_multicaret_edit);
    METHOD(bool, is_in_mulitcaret_edit);
    METHOD(bool, multicaret_edit_ignore_caret);
    METHOD(bool, is_caret_visible);
    METHOD(Vector2, get_caret_draw_pos);
    METHOD(void, set_caret_line);
    METHOD(int64_t, get_caret_line);
    METHOD(void, set_caret_column);
    METHOD(int64_t, get_caret_column);
    METHOD(int64_t, get_caret_wrap_index);
    METHOD(String, get_word_under_caret);
    METHOD(void, set_use_default_word_separators);
    METHOD(bool, is_default_word_separators_enabled);
    METHOD(void, set_use_custom_word_separators);
    METHOD(bool, is_custom_word_separators_enabled);
    METHOD(void, set_custom_word_separators);
    METHOD(String, get_custom_word_separators);
    METHOD(void, set_selecting_enabled);
    METHOD(bool, is_selecting_enabled);
    METHOD(void, set_deselect_on_focus_loss_enabled);
    METHOD(bool, is_deselect_on_focus_loss_enabled);
    METHOD(void, set_drag_and_drop_selection_enabled);
    METHOD(bool, is_drag_and_drop_selection_enabled);
    METHOD(void, set_selection_mode);
    METHOD(int64_t, get_selection_mode);
    METHOD(Variant, select_all);
    METHOD(Variant, select_word_under_caret);
    METHOD(Variant, add_selection_for_next_occurrence);
    METHOD(Variant, skip_selection_for_next_occurrence);
    METHOD(Variant, select);
    METHOD(bool, has_selection);
    METHOD(String, get_selected_text);
    METHOD(int64_t, get_selection_at_line_column);
    METHOD(Array, get_line_ranges_from_carets);
    METHOD(int64_t, get_selection_origin_line);
    METHOD(int64_t, get_selection_origin_column);
    METHOD(void, set_selection_origin_line);
    METHOD(void, set_selection_origin_column);
    METHOD(int64_t, get_selection_from_line);
    METHOD(int64_t, get_selection_from_column);
    METHOD(int64_t, get_selection_to_line);
    METHOD(int64_t, get_selection_to_column);
    METHOD(bool, is_caret_after_selection_origin);
    METHOD(Variant, deselect);
    METHOD(Variant, delete_selection);
    METHOD(void, set_line_wrapping_mode);
    METHOD(int64_t, get_line_wrapping_mode);
    METHOD(void, set_autowrap_mode);
    METHOD(int64_t, get_autowrap_mode);
    METHOD(bool, is_line_wrapped);
    METHOD(int64_t, get_line_wrap_count);
    METHOD(int64_t, get_line_wrap_index_at_column);
    METHOD(PackedArray<std::string>, get_line_wrapped_text);
    METHOD(void, set_smooth_scroll_enabled);
    METHOD(bool, is_smooth_scroll_enabled);
    METHOD(Object, get_v_scroll_bar);
    METHOD(Object, get_h_scroll_bar);
    METHOD(void, set_v_scroll);
    METHOD(double, get_v_scroll);
    METHOD(void, set_h_scroll);
    METHOD(int64_t, get_h_scroll);
    METHOD(void, set_scroll_past_end_of_file_enabled);
    METHOD(bool, is_scroll_past_end_of_file_enabled);
    METHOD(void, set_v_scroll_speed);
    METHOD(double, get_v_scroll_speed);
    METHOD(void, set_fit_content_height_enabled);
    METHOD(bool, is_fit_content_height_enabled);
    METHOD(double, get_scroll_pos_for_line);
    METHOD(void, set_line_as_first_visible);
    METHOD(int64_t, get_first_visible_line);
    METHOD(void, set_line_as_center_visible);
    METHOD(void, set_line_as_last_visible);
    METHOD(int64_t, get_last_full_visible_line);
    METHOD(int64_t, get_last_full_visible_line_wrap_index);
    METHOD(int64_t, get_visible_line_count);
    METHOD(int64_t, get_visible_line_count_in_range);
    METHOD(int64_t, get_total_visible_line_count);
    METHOD(Variant, adjust_viewport_to_caret);
    METHOD(Variant, center_viewport_to_caret);
    METHOD(void, set_draw_minimap);
    METHOD(bool, is_drawing_minimap);
    METHOD(void, set_minimap_width);
    METHOD(int64_t, get_minimap_width);
    METHOD(int64_t, get_minimap_visible_lines);
    METHOD(Variant, add_gutter);
    METHOD(Variant, remove_gutter);
    METHOD(int64_t, get_gutter_count);
    METHOD(void, set_gutter_name);
    METHOD(String, get_gutter_name);
    METHOD(void, set_gutter_type);
    METHOD(int64_t, get_gutter_type);
    METHOD(void, set_gutter_width);
    METHOD(int64_t, get_gutter_width);
    METHOD(void, set_gutter_draw);
    METHOD(bool, is_gutter_drawn);
    METHOD(void, set_gutter_clickable);
    METHOD(bool, is_gutter_clickable);
    METHOD(void, set_gutter_overwritable);
    METHOD(bool, is_gutter_overwritable);
    METHOD(Variant, merge_gutters);
    METHOD(void, set_gutter_custom_draw);
    METHOD(int64_t, get_total_gutter_width);
    METHOD(void, set_line_gutter_metadata);
    METHOD(Variant, get_line_gutter_metadata);
    METHOD(void, set_line_gutter_text);
    METHOD(String, get_line_gutter_text);
    METHOD(void, set_line_gutter_icon);
    METHOD(Object, get_line_gutter_icon);
    METHOD(void, set_line_gutter_item_color);
    METHOD(Color, get_line_gutter_item_color);
    METHOD(void, set_line_gutter_clickable);
    METHOD(bool, is_line_gutter_clickable);
    METHOD(void, set_line_background_color);
    METHOD(Color, get_line_background_color);
    METHOD(void, set_syntax_highlighter);
    METHOD(Object, get_syntax_highlighter);
    METHOD(void, set_highlight_current_line);
    METHOD(bool, is_highlight_current_line_enabled);
    METHOD(void, set_highlight_all_occurrences);
    METHOD(bool, is_highlight_all_occurrences_enabled);
    METHOD(bool, get_draw_control_chars);
    METHOD(void, set_draw_control_chars);
    METHOD(void, set_draw_tabs);
    METHOD(bool, is_drawing_tabs);
    METHOD(void, set_draw_spaces);
    METHOD(bool, is_drawing_spaces);
    METHOD(Object, get_menu);
    METHOD(bool, is_menu_visible);
    METHOD(Variant, menu_option);
    METHOD(Variant, adjust_carets_after_edit);
    METHOD(PackedArray<int32_t>, get_caret_index_edit_order);
    METHOD(int64_t, get_selection_line);
    METHOD(int64_t, get_selection_column);
    static constexpr int64_t MENU_CUT = 0;
    static constexpr int64_t MENU_COPY = 1;
    static constexpr int64_t MENU_PASTE = 2;
    static constexpr int64_t MENU_CLEAR = 3;
    static constexpr int64_t MENU_SELECT_ALL = 4;
    static constexpr int64_t MENU_UNDO = 5;
    static constexpr int64_t MENU_REDO = 6;
    static constexpr int64_t MENU_SUBMENU_TEXT_DIR = 7;
    static constexpr int64_t MENU_DIR_INHERITED = 8;
    static constexpr int64_t MENU_DIR_AUTO = 9;
    static constexpr int64_t MENU_DIR_LTR = 10;
    static constexpr int64_t MENU_DIR_RTL = 11;
    static constexpr int64_t MENU_DISPLAY_UCC = 12;
    static constexpr int64_t MENU_SUBMENU_INSERT_UCC = 13;
    static constexpr int64_t MENU_INSERT_LRM = 14;
    static constexpr int64_t MENU_INSERT_RLM = 15;
    static constexpr int64_t MENU_INSERT_LRE = 16;
    static constexpr int64_t MENU_INSERT_RLE = 17;
    static constexpr int64_t MENU_INSERT_LRO = 18;
    static constexpr int64_t MENU_INSERT_RLO = 19;
    static constexpr int64_t MENU_INSERT_PDF = 20;
    static constexpr int64_t MENU_INSERT_ALM = 21;
    static constexpr int64_t MENU_INSERT_LRI = 22;
    static constexpr int64_t MENU_INSERT_RLI = 23;
    static constexpr int64_t MENU_INSERT_FSI = 24;
    static constexpr int64_t MENU_INSERT_PDI = 25;
    static constexpr int64_t MENU_INSERT_ZWJ = 26;
    static constexpr int64_t MENU_INSERT_ZWNJ = 27;
    static constexpr int64_t MENU_INSERT_WJ = 28;
    static constexpr int64_t MENU_INSERT_SHY = 29;
    static constexpr int64_t MENU_MAX = 30;
    static constexpr int64_t ACTION_NONE = 0;
    static constexpr int64_t ACTION_TYPING = 1;
    static constexpr int64_t ACTION_BACKSPACE = 2;
    static constexpr int64_t ACTION_DELETE = 3;
    static constexpr int64_t SEARCH_MATCH_CASE = 1;
    static constexpr int64_t SEARCH_WHOLE_WORDS = 2;
    static constexpr int64_t SEARCH_BACKWARDS = 4;
    static constexpr int64_t CARET_TYPE_LINE = 0;
    static constexpr int64_t CARET_TYPE_BLOCK = 1;
    static constexpr int64_t SELECTION_MODE_NONE = 0;
    static constexpr int64_t SELECTION_MODE_SHIFT = 1;
    static constexpr int64_t SELECTION_MODE_POINTER = 2;
    static constexpr int64_t SELECTION_MODE_WORD = 3;
    static constexpr int64_t SELECTION_MODE_LINE = 4;
    static constexpr int64_t LINE_WRAPPING_NONE = 0;
    static constexpr int64_t LINE_WRAPPING_BOUNDARY = 1;
    static constexpr int64_t GUTTER_TYPE_STRING = 0;
    static constexpr int64_t GUTTER_TYPE_ICON = 1;
    static constexpr int64_t GUTTER_TYPE_CUSTOM = 2;
};
struct TextLine : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(direction, int64_t);
    PROPERTY(orientation, int64_t);
    PROPERTY(preserve_invalid, bool);
    PROPERTY(preserve_control, bool);
    PROPERTY(width, double);
    PROPERTY(alignment, int64_t);
    PROPERTY(flags, int64_t);
    PROPERTY(text_overrun_behavior, int64_t);
    PROPERTY(ellipsis_char, String);
    METHOD(Variant, clear);
    METHOD(void, set_direction);
    METHOD(int64_t, get_direction);
    METHOD(void, set_orientation);
    METHOD(int64_t, get_orientation);
    METHOD(void, set_preserve_invalid);
    METHOD(bool, get_preserve_invalid);
    METHOD(void, set_preserve_control);
    METHOD(bool, get_preserve_control);
    METHOD(void, set_bidi_override);
    METHOD(bool, add_string);
    METHOD(bool, add_object);
    METHOD(bool, resize_object);
    METHOD(void, set_width);
    METHOD(double, get_width);
    METHOD(void, set_horizontal_alignment);
    METHOD(int64_t, get_horizontal_alignment);
    METHOD(Variant, tab_align);
    METHOD(void, set_flags);
    METHOD(int64_t, get_flags);
    METHOD(void, set_text_overrun_behavior);
    METHOD(int64_t, get_text_overrun_behavior);
    METHOD(void, set_ellipsis_char);
    METHOD(String, get_ellipsis_char);
    METHOD(Array, get_objects);
    METHOD(Rect2, get_object_rect);
    METHOD(Vector2, get_size);
    METHOD(::RID, get_rid);
    METHOD(double, get_line_ascent);
    METHOD(double, get_line_descent);
    METHOD(double, get_line_width);
    METHOD(double, get_line_underline_position);
    METHOD(double, get_line_underline_thickness);
    METHOD(Variant, draw);
    METHOD(Variant, draw_outline);
    METHOD(int64_t, hit_test);
};
struct TextParagraph : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(direction, int64_t);
    PROPERTY(custom_punctuation, String);
    PROPERTY(orientation, int64_t);
    PROPERTY(preserve_invalid, bool);
    PROPERTY(preserve_control, bool);
    PROPERTY(alignment, int64_t);
    PROPERTY(break_flags, int64_t);
    PROPERTY(justification_flags, int64_t);
    PROPERTY(text_overrun_behavior, int64_t);
    PROPERTY(ellipsis_char, String);
    PROPERTY(width, double);
    PROPERTY(max_lines_visible, int64_t);
    METHOD(Variant, clear);
    METHOD(void, set_direction);
    METHOD(int64_t, get_direction);
    METHOD(void, set_custom_punctuation);
    METHOD(String, get_custom_punctuation);
    METHOD(void, set_orientation);
    METHOD(int64_t, get_orientation);
    METHOD(void, set_preserve_invalid);
    METHOD(bool, get_preserve_invalid);
    METHOD(void, set_preserve_control);
    METHOD(bool, get_preserve_control);
    METHOD(void, set_bidi_override);
    METHOD(bool, set_dropcap);
    METHOD(Variant, clear_dropcap);
    METHOD(bool, add_string);
    METHOD(bool, add_object);
    METHOD(bool, resize_object);
    METHOD(void, set_alignment);
    METHOD(int64_t, get_alignment);
    METHOD(Variant, tab_align);
    METHOD(void, set_break_flags);
    METHOD(int64_t, get_break_flags);
    METHOD(void, set_justification_flags);
    METHOD(int64_t, get_justification_flags);
    METHOD(void, set_text_overrun_behavior);
    METHOD(int64_t, get_text_overrun_behavior);
    METHOD(void, set_ellipsis_char);
    METHOD(String, get_ellipsis_char);
    METHOD(void, set_width);
    METHOD(double, get_width);
    METHOD(Vector2, get_non_wrapped_size);
    METHOD(Vector2, get_size);
    METHOD(::RID, get_rid);
    METHOD(::RID, get_line_rid);
    METHOD(::RID, get_dropcap_rid);
    METHOD(int64_t, get_line_count);
    METHOD(void, set_max_lines_visible);
    METHOD(int64_t, get_max_lines_visible);
    METHOD(Array, get_line_objects);
    METHOD(Rect2, get_line_object_rect);
    METHOD(Vector2, get_line_size);
    METHOD(Vector2i, get_line_range);
    METHOD(double, get_line_ascent);
    METHOD(double, get_line_descent);
    METHOD(double, get_line_width);
    METHOD(double, get_line_underline_position);
    METHOD(double, get_line_underline_thickness);
    METHOD(Vector2, get_dropcap_size);
    METHOD(int64_t, get_dropcap_lines);
    METHOD(Variant, draw);
    METHOD(Variant, draw_outline);
    METHOD(Variant, draw_line);
    METHOD(Variant, draw_line_outline);
    METHOD(Variant, draw_dropcap);
    METHOD(Variant, draw_dropcap_outline);
    METHOD(int64_t, hit_test);
};
struct TextServer : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(bool, has_feature);
    METHOD(String, get_name);
    METHOD(int64_t, get_features);
    METHOD(bool, load_support_data);
    METHOD(String, get_support_data_filename);
    METHOD(String, get_support_data_info);
    METHOD(bool, save_support_data);
    METHOD(bool, is_locale_right_to_left);
    METHOD(int64_t, name_to_tag);
    METHOD(String, tag_to_name);
    METHOD(bool, has);
    METHOD(Variant, free_rid);
    METHOD(::RID, create_font);
    METHOD(::RID, create_font_linked_variation);
    METHOD(Variant, font_set_data);
    METHOD(Variant, font_set_face_index);
    METHOD(int64_t, font_get_face_index);
    METHOD(int64_t, font_get_face_count);
    METHOD(Variant, font_set_style);
    METHOD(int64_t, font_get_style);
    METHOD(Variant, font_set_name);
    METHOD(String, font_get_name);
    METHOD(Dictionary, font_get_ot_name_strings);
    METHOD(Variant, font_set_style_name);
    METHOD(String, font_get_style_name);
    METHOD(Variant, font_set_weight);
    METHOD(int64_t, font_get_weight);
    METHOD(Variant, font_set_stretch);
    METHOD(int64_t, font_get_stretch);
    METHOD(Variant, font_set_antialiasing);
    METHOD(int64_t, font_get_antialiasing);
    METHOD(Variant, font_set_disable_embedded_bitmaps);
    METHOD(bool, font_get_disable_embedded_bitmaps);
    METHOD(Variant, font_set_generate_mipmaps);
    METHOD(bool, font_get_generate_mipmaps);
    METHOD(Variant, font_set_multichannel_signed_distance_field);
    METHOD(bool, font_is_multichannel_signed_distance_field);
    METHOD(Variant, font_set_msdf_pixel_range);
    METHOD(int64_t, font_get_msdf_pixel_range);
    METHOD(Variant, font_set_msdf_size);
    METHOD(int64_t, font_get_msdf_size);
    METHOD(Variant, font_set_fixed_size);
    METHOD(int64_t, font_get_fixed_size);
    METHOD(Variant, font_set_fixed_size_scale_mode);
    METHOD(int64_t, font_get_fixed_size_scale_mode);
    METHOD(Variant, font_set_allow_system_fallback);
    METHOD(bool, font_is_allow_system_fallback);
    METHOD(Variant, font_set_force_autohinter);
    METHOD(bool, font_is_force_autohinter);
    METHOD(Variant, font_set_hinting);
    METHOD(int64_t, font_get_hinting);
    METHOD(Variant, font_set_subpixel_positioning);
    METHOD(int64_t, font_get_subpixel_positioning);
    METHOD(Variant, font_set_embolden);
    METHOD(double, font_get_embolden);
    METHOD(Variant, font_set_spacing);
    METHOD(int64_t, font_get_spacing);
    METHOD(Variant, font_set_baseline_offset);
    METHOD(double, font_get_baseline_offset);
    METHOD(Variant, font_set_transform);
    METHOD(Transform2D, font_get_transform);
    METHOD(Variant, font_set_variation_coordinates);
    METHOD(Dictionary, font_get_variation_coordinates);
    METHOD(Variant, font_set_oversampling);
    METHOD(double, font_get_oversampling);
    METHOD(Array, font_get_size_cache_list);
    METHOD(Variant, font_clear_size_cache);
    METHOD(Variant, font_remove_size_cache);
    METHOD(Variant, font_set_ascent);
    METHOD(double, font_get_ascent);
    METHOD(Variant, font_set_descent);
    METHOD(double, font_get_descent);
    METHOD(Variant, font_set_underline_position);
    METHOD(double, font_get_underline_position);
    METHOD(Variant, font_set_underline_thickness);
    METHOD(double, font_get_underline_thickness);
    METHOD(Variant, font_set_scale);
    METHOD(double, font_get_scale);
    METHOD(int64_t, font_get_texture_count);
    METHOD(Variant, font_clear_textures);
    METHOD(Variant, font_remove_texture);
    METHOD(Variant, font_set_texture_image);
    METHOD(Object, font_get_texture_image);
    METHOD(Variant, font_set_texture_offsets);
    METHOD(PackedArray<int32_t>, font_get_texture_offsets);
    METHOD(PackedArray<int32_t>, font_get_glyph_list);
    METHOD(Variant, font_clear_glyphs);
    METHOD(Variant, font_remove_glyph);
    METHOD(Vector2, font_get_glyph_advance);
    METHOD(Variant, font_set_glyph_advance);
    METHOD(Vector2, font_get_glyph_offset);
    METHOD(Variant, font_set_glyph_offset);
    METHOD(Vector2, font_get_glyph_size);
    METHOD(Variant, font_set_glyph_size);
    METHOD(Rect2, font_get_glyph_uv_rect);
    METHOD(Variant, font_set_glyph_uv_rect);
    METHOD(int64_t, font_get_glyph_texture_idx);
    METHOD(Variant, font_set_glyph_texture_idx);
    METHOD(::RID, font_get_glyph_texture_rid);
    METHOD(Vector2, font_get_glyph_texture_size);
    METHOD(Dictionary, font_get_glyph_contours);
    METHOD(Array, font_get_kerning_list);
    METHOD(Variant, font_clear_kerning_map);
    METHOD(Variant, font_remove_kerning);
    METHOD(Variant, font_set_kerning);
    METHOD(Vector2, font_get_kerning);
    METHOD(int64_t, font_get_glyph_index);
    METHOD(int64_t, font_get_char_from_glyph_index);
    METHOD(bool, font_has_char);
    METHOD(String, font_get_supported_chars);
    METHOD(Variant, font_render_range);
    METHOD(Variant, font_render_glyph);
    METHOD(Variant, font_draw_glyph);
    METHOD(Variant, font_draw_glyph_outline);
    METHOD(bool, font_is_language_supported);
    METHOD(Variant, font_set_language_support_override);
    METHOD(bool, font_get_language_support_override);
    METHOD(Variant, font_remove_language_support_override);
    METHOD(PackedArray<std::string>, font_get_language_support_overrides);
    METHOD(bool, font_is_script_supported);
    METHOD(Variant, font_set_script_support_override);
    METHOD(bool, font_get_script_support_override);
    METHOD(Variant, font_remove_script_support_override);
    METHOD(PackedArray<std::string>, font_get_script_support_overrides);
    METHOD(Variant, font_set_opentype_feature_overrides);
    METHOD(Dictionary, font_get_opentype_feature_overrides);
    METHOD(Dictionary, font_supported_feature_list);
    METHOD(Dictionary, font_supported_variation_list);
    METHOD(double, font_get_global_oversampling);
    METHOD(Variant, font_set_global_oversampling);
    METHOD(Vector2, get_hex_code_box_size);
    METHOD(Variant, draw_hex_code_box);
    METHOD(::RID, create_shaped_text);
    METHOD(Variant, shaped_text_clear);
    METHOD(Variant, shaped_text_set_direction);
    METHOD(int64_t, shaped_text_get_direction);
    METHOD(int64_t, shaped_text_get_inferred_direction);
    METHOD(Variant, shaped_text_set_bidi_override);
    METHOD(Variant, shaped_text_set_custom_punctuation);
    METHOD(String, shaped_text_get_custom_punctuation);
    METHOD(Variant, shaped_text_set_custom_ellipsis);
    METHOD(int64_t, shaped_text_get_custom_ellipsis);
    METHOD(Variant, shaped_text_set_orientation);
    METHOD(int64_t, shaped_text_get_orientation);
    METHOD(Variant, shaped_text_set_preserve_invalid);
    METHOD(bool, shaped_text_get_preserve_invalid);
    METHOD(Variant, shaped_text_set_preserve_control);
    METHOD(bool, shaped_text_get_preserve_control);
    METHOD(Variant, shaped_text_set_spacing);
    METHOD(int64_t, shaped_text_get_spacing);
    METHOD(bool, shaped_text_add_string);
    METHOD(bool, shaped_text_add_object);
    METHOD(bool, shaped_text_resize_object);
    METHOD(int64_t, shaped_get_span_count);
    METHOD(Variant, shaped_get_span_meta);
    METHOD(Variant, shaped_set_span_update_font);
    METHOD(::RID, shaped_text_substr);
    METHOD(::RID, shaped_text_get_parent);
    METHOD(double, shaped_text_fit_to_width);
    METHOD(double, shaped_text_tab_align);
    METHOD(bool, shaped_text_shape);
    METHOD(bool, shaped_text_is_ready);
    METHOD(bool, shaped_text_has_visible_chars);
    METHOD(Array, shaped_text_get_glyphs);
    METHOD(Array, shaped_text_sort_logical);
    METHOD(int64_t, shaped_text_get_glyph_count);
    METHOD(Vector2i, shaped_text_get_range);
    METHOD(PackedArray<int32_t>, shaped_text_get_line_breaks_adv);
    METHOD(PackedArray<int32_t>, shaped_text_get_line_breaks);
    METHOD(PackedArray<int32_t>, shaped_text_get_word_breaks);
    METHOD(int64_t, shaped_text_get_trim_pos);
    METHOD(int64_t, shaped_text_get_ellipsis_pos);
    METHOD(Array, shaped_text_get_ellipsis_glyphs);
    METHOD(int64_t, shaped_text_get_ellipsis_glyph_count);
    METHOD(Variant, shaped_text_overrun_trim_to_width);
    METHOD(Array, shaped_text_get_objects);
    METHOD(Rect2, shaped_text_get_object_rect);
    METHOD(Vector2i, shaped_text_get_object_range);
    METHOD(int64_t, shaped_text_get_object_glyph);
    METHOD(Vector2, shaped_text_get_size);
    METHOD(double, shaped_text_get_ascent);
    METHOD(double, shaped_text_get_descent);
    METHOD(double, shaped_text_get_width);
    METHOD(double, shaped_text_get_underline_position);
    METHOD(double, shaped_text_get_underline_thickness);
    METHOD(Dictionary, shaped_text_get_carets);
    METHOD(PackedArray<Vector2>, shaped_text_get_selection);
    METHOD(int64_t, shaped_text_hit_test_grapheme);
    METHOD(int64_t, shaped_text_hit_test_position);
    METHOD(Vector2, shaped_text_get_grapheme_bounds);
    METHOD(int64_t, shaped_text_next_grapheme_pos);
    METHOD(int64_t, shaped_text_prev_grapheme_pos);
    METHOD(PackedArray<int32_t>, shaped_text_get_character_breaks);
    METHOD(int64_t, shaped_text_next_character_pos);
    METHOD(int64_t, shaped_text_prev_character_pos);
    METHOD(int64_t, shaped_text_closest_character_pos);
    METHOD(Variant, shaped_text_draw);
    METHOD(Variant, shaped_text_draw_outline);
    METHOD(int64_t, shaped_text_get_dominant_direction_in_range);
    METHOD(String, format_number);
    METHOD(String, parse_number);
    METHOD(String, percent_sign);
    METHOD(PackedArray<int32_t>, string_get_word_breaks);
    METHOD(PackedArray<int32_t>, string_get_character_breaks);
    METHOD(int64_t, is_confusable);
    METHOD(bool, spoof_check);
    METHOD(String, strip_diacritics);
    METHOD(bool, is_valid_identifier);
    METHOD(bool, is_valid_letter);
    METHOD(String, string_to_upper);
    METHOD(String, string_to_lower);
    METHOD(String, string_to_title);
    METHOD(Array, parse_structured_text);
    static constexpr int64_t FONT_ANTIALIASING_NONE = 0;
    static constexpr int64_t FONT_ANTIALIASING_GRAY = 1;
    static constexpr int64_t FONT_ANTIALIASING_LCD = 2;
    static constexpr int64_t FONT_LCD_SUBPIXEL_LAYOUT_NONE = 0;
    static constexpr int64_t FONT_LCD_SUBPIXEL_LAYOUT_HRGB = 1;
    static constexpr int64_t FONT_LCD_SUBPIXEL_LAYOUT_HBGR = 2;
    static constexpr int64_t FONT_LCD_SUBPIXEL_LAYOUT_VRGB = 3;
    static constexpr int64_t FONT_LCD_SUBPIXEL_LAYOUT_VBGR = 4;
    static constexpr int64_t FONT_LCD_SUBPIXEL_LAYOUT_MAX = 5;
    static constexpr int64_t DIRECTION_AUTO = 0;
    static constexpr int64_t DIRECTION_LTR = 1;
    static constexpr int64_t DIRECTION_RTL = 2;
    static constexpr int64_t DIRECTION_INHERITED = 3;
    static constexpr int64_t ORIENTATION_HORIZONTAL = 0;
    static constexpr int64_t ORIENTATION_VERTICAL = 1;
    static constexpr int64_t JUSTIFICATION_NONE = 0;
    static constexpr int64_t JUSTIFICATION_KASHIDA = 1;
    static constexpr int64_t JUSTIFICATION_WORD_BOUND = 2;
    static constexpr int64_t JUSTIFICATION_TRIM_EDGE_SPACES = 4;
    static constexpr int64_t JUSTIFICATION_AFTER_LAST_TAB = 8;
    static constexpr int64_t JUSTIFICATION_CONSTRAIN_ELLIPSIS = 16;
    static constexpr int64_t JUSTIFICATION_SKIP_LAST_LINE = 32;
    static constexpr int64_t JUSTIFICATION_SKIP_LAST_LINE_WITH_VISIBLE_CHARS = 64;
    static constexpr int64_t JUSTIFICATION_DO_NOT_SKIP_SINGLE_LINE = 128;
    static constexpr int64_t AUTOWRAP_OFF = 0;
    static constexpr int64_t AUTOWRAP_ARBITRARY = 1;
    static constexpr int64_t AUTOWRAP_WORD = 2;
    static constexpr int64_t AUTOWRAP_WORD_SMART = 3;
    static constexpr int64_t BREAK_NONE = 0;
    static constexpr int64_t BREAK_MANDATORY = 1;
    static constexpr int64_t BREAK_WORD_BOUND = 2;
    static constexpr int64_t BREAK_GRAPHEME_BOUND = 4;
    static constexpr int64_t BREAK_ADAPTIVE = 8;
    static constexpr int64_t BREAK_TRIM_EDGE_SPACES = 16;
    static constexpr int64_t BREAK_TRIM_INDENT = 32;
    static constexpr int64_t VC_CHARS_BEFORE_SHAPING = 0;
    static constexpr int64_t VC_CHARS_AFTER_SHAPING = 1;
    static constexpr int64_t VC_GLYPHS_AUTO = 2;
    static constexpr int64_t VC_GLYPHS_LTR = 3;
    static constexpr int64_t VC_GLYPHS_RTL = 4;
    static constexpr int64_t OVERRUN_NO_TRIMMING = 0;
    static constexpr int64_t OVERRUN_TRIM_CHAR = 1;
    static constexpr int64_t OVERRUN_TRIM_WORD = 2;
    static constexpr int64_t OVERRUN_TRIM_ELLIPSIS = 3;
    static constexpr int64_t OVERRUN_TRIM_WORD_ELLIPSIS = 4;
    static constexpr int64_t OVERRUN_NO_TRIM = 0;
    static constexpr int64_t OVERRUN_TRIM = 1;
    static constexpr int64_t OVERRUN_TRIM_WORD_ONLY = 2;
    static constexpr int64_t OVERRUN_ADD_ELLIPSIS = 4;
    static constexpr int64_t OVERRUN_ENFORCE_ELLIPSIS = 8;
    static constexpr int64_t OVERRUN_JUSTIFICATION_AWARE = 16;
    static constexpr int64_t GRAPHEME_IS_VALID = 1;
    static constexpr int64_t GRAPHEME_IS_RTL = 2;
    static constexpr int64_t GRAPHEME_IS_VIRTUAL = 4;
    static constexpr int64_t GRAPHEME_IS_SPACE = 8;
    static constexpr int64_t GRAPHEME_IS_BREAK_HARD = 16;
    static constexpr int64_t GRAPHEME_IS_BREAK_SOFT = 32;
    static constexpr int64_t GRAPHEME_IS_TAB = 64;
    static constexpr int64_t GRAPHEME_IS_ELONGATION = 128;
    static constexpr int64_t GRAPHEME_IS_PUNCTUATION = 256;
    static constexpr int64_t GRAPHEME_IS_UNDERSCORE = 512;
    static constexpr int64_t GRAPHEME_IS_CONNECTED = 1024;
    static constexpr int64_t GRAPHEME_IS_SAFE_TO_INSERT_TATWEEL = 2048;
    static constexpr int64_t GRAPHEME_IS_EMBEDDED_OBJECT = 4096;
    static constexpr int64_t GRAPHEME_IS_SOFT_HYPHEN = 8192;
    static constexpr int64_t HINTING_NONE = 0;
    static constexpr int64_t HINTING_LIGHT = 1;
    static constexpr int64_t HINTING_NORMAL = 2;
    static constexpr int64_t SUBPIXEL_POSITIONING_DISABLED = 0;
    static constexpr int64_t SUBPIXEL_POSITIONING_AUTO = 1;
    static constexpr int64_t SUBPIXEL_POSITIONING_ONE_HALF = 2;
    static constexpr int64_t SUBPIXEL_POSITIONING_ONE_QUARTER = 3;
    static constexpr int64_t SUBPIXEL_POSITIONING_ONE_HALF_MAX_SIZE = 20;
    static constexpr int64_t SUBPIXEL_POSITIONING_ONE_QUARTER_MAX_SIZE = 16;
    static constexpr int64_t FEATURE_SIMPLE_LAYOUT = 1;
    static constexpr int64_t FEATURE_BIDI_LAYOUT = 2;
    static constexpr int64_t FEATURE_VERTICAL_LAYOUT = 4;
    static constexpr int64_t FEATURE_SHAPING = 8;
    static constexpr int64_t FEATURE_KASHIDA_JUSTIFICATION = 16;
    static constexpr int64_t FEATURE_BREAK_ITERATORS = 32;
    static constexpr int64_t FEATURE_FONT_BITMAP = 64;
    static constexpr int64_t FEATURE_FONT_DYNAMIC = 128;
    static constexpr int64_t FEATURE_FONT_MSDF = 256;
    static constexpr int64_t FEATURE_FONT_SYSTEM = 512;
    static constexpr int64_t FEATURE_FONT_VARIABLE = 1024;
    static constexpr int64_t FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION = 2048;
    static constexpr int64_t FEATURE_USE_SUPPORT_DATA = 4096;
    static constexpr int64_t FEATURE_UNICODE_IDENTIFIERS = 8192;
    static constexpr int64_t FEATURE_UNICODE_SECURITY = 16384;
    static constexpr int64_t CONTOUR_CURVE_TAG_ON = 1;
    static constexpr int64_t CONTOUR_CURVE_TAG_OFF_CONIC = 0;
    static constexpr int64_t CONTOUR_CURVE_TAG_OFF_CUBIC = 2;
    static constexpr int64_t SPACING_GLYPH = 0;
    static constexpr int64_t SPACING_SPACE = 1;
    static constexpr int64_t SPACING_TOP = 2;
    static constexpr int64_t SPACING_BOTTOM = 3;
    static constexpr int64_t SPACING_MAX = 4;
    static constexpr int64_t FONT_BOLD = 1;
    static constexpr int64_t FONT_ITALIC = 2;
    static constexpr int64_t FONT_FIXED_WIDTH = 4;
    static constexpr int64_t STRUCTURED_TEXT_DEFAULT = 0;
    static constexpr int64_t STRUCTURED_TEXT_URI = 1;
    static constexpr int64_t STRUCTURED_TEXT_FILE = 2;
    static constexpr int64_t STRUCTURED_TEXT_EMAIL = 3;
    static constexpr int64_t STRUCTURED_TEXT_LIST = 4;
    static constexpr int64_t STRUCTURED_TEXT_GDSCRIPT = 5;
    static constexpr int64_t STRUCTURED_TEXT_CUSTOM = 6;
    static constexpr int64_t FIXED_SIZE_SCALE_DISABLE = 0;
    static constexpr int64_t FIXED_SIZE_SCALE_INTEGER_ONLY = 1;
    static constexpr int64_t FIXED_SIZE_SCALE_ENABLED = 2;
};
struct TextServerExtension : public TextServer {
    using TextServer::TextServer;
    METHOD(bool, _has_feature);
    METHOD(String, _get_name);
    METHOD(int64_t, _get_features);
    METHOD(Variant, _free_rid);
    METHOD(bool, _has);
    METHOD(bool, _load_support_data);
    METHOD(String, _get_support_data_filename);
    METHOD(String, _get_support_data_info);
    METHOD(bool, _save_support_data);
    METHOD(bool, _is_locale_right_to_left);
    METHOD(int64_t, _name_to_tag);
    METHOD(String, _tag_to_name);
    METHOD(::RID, _create_font);
    METHOD(::RID, _create_font_linked_variation);
    METHOD(Variant, _font_set_data);
    METHOD(Variant, _font_set_data_ptr);
    METHOD(Variant, _font_set_face_index);
    METHOD(int64_t, _font_get_face_index);
    METHOD(int64_t, _font_get_face_count);
    METHOD(Variant, _font_set_style);
    METHOD(int64_t, _font_get_style);
    METHOD(Variant, _font_set_name);
    METHOD(String, _font_get_name);
    METHOD(Dictionary, _font_get_ot_name_strings);
    METHOD(Variant, _font_set_style_name);
    METHOD(String, _font_get_style_name);
    METHOD(Variant, _font_set_weight);
    METHOD(int64_t, _font_get_weight);
    METHOD(Variant, _font_set_stretch);
    METHOD(int64_t, _font_get_stretch);
    METHOD(Variant, _font_set_antialiasing);
    METHOD(int64_t, _font_get_antialiasing);
    METHOD(Variant, _font_set_disable_embedded_bitmaps);
    METHOD(bool, _font_get_disable_embedded_bitmaps);
    METHOD(Variant, _font_set_generate_mipmaps);
    METHOD(bool, _font_get_generate_mipmaps);
    METHOD(Variant, _font_set_multichannel_signed_distance_field);
    METHOD(bool, _font_is_multichannel_signed_distance_field);
    METHOD(Variant, _font_set_msdf_pixel_range);
    METHOD(int64_t, _font_get_msdf_pixel_range);
    METHOD(Variant, _font_set_msdf_size);
    METHOD(int64_t, _font_get_msdf_size);
    METHOD(Variant, _font_set_fixed_size);
    METHOD(int64_t, _font_get_fixed_size);
    METHOD(Variant, _font_set_fixed_size_scale_mode);
    METHOD(int64_t, _font_get_fixed_size_scale_mode);
    METHOD(Variant, _font_set_allow_system_fallback);
    METHOD(bool, _font_is_allow_system_fallback);
    METHOD(Variant, _font_set_force_autohinter);
    METHOD(bool, _font_is_force_autohinter);
    METHOD(Variant, _font_set_hinting);
    METHOD(int64_t, _font_get_hinting);
    METHOD(Variant, _font_set_subpixel_positioning);
    METHOD(int64_t, _font_get_subpixel_positioning);
    METHOD(Variant, _font_set_embolden);
    METHOD(double, _font_get_embolden);
    METHOD(Variant, _font_set_spacing);
    METHOD(int64_t, _font_get_spacing);
    METHOD(Variant, _font_set_baseline_offset);
    METHOD(double, _font_get_baseline_offset);
    METHOD(Variant, _font_set_transform);
    METHOD(Transform2D, _font_get_transform);
    METHOD(Variant, _font_set_variation_coordinates);
    METHOD(Dictionary, _font_get_variation_coordinates);
    METHOD(Variant, _font_set_oversampling);
    METHOD(double, _font_get_oversampling);
    METHOD(Array, _font_get_size_cache_list);
    METHOD(Variant, _font_clear_size_cache);
    METHOD(Variant, _font_remove_size_cache);
    METHOD(Variant, _font_set_ascent);
    METHOD(double, _font_get_ascent);
    METHOD(Variant, _font_set_descent);
    METHOD(double, _font_get_descent);
    METHOD(Variant, _font_set_underline_position);
    METHOD(double, _font_get_underline_position);
    METHOD(Variant, _font_set_underline_thickness);
    METHOD(double, _font_get_underline_thickness);
    METHOD(Variant, _font_set_scale);
    METHOD(double, _font_get_scale);
    METHOD(int64_t, _font_get_texture_count);
    METHOD(Variant, _font_clear_textures);
    METHOD(Variant, _font_remove_texture);
    METHOD(Variant, _font_set_texture_image);
    METHOD(Object, _font_get_texture_image);
    METHOD(Variant, _font_set_texture_offsets);
    METHOD(PackedArray<int32_t>, _font_get_texture_offsets);
    METHOD(PackedArray<int32_t>, _font_get_glyph_list);
    METHOD(Variant, _font_clear_glyphs);
    METHOD(Variant, _font_remove_glyph);
    METHOD(Vector2, _font_get_glyph_advance);
    METHOD(Variant, _font_set_glyph_advance);
    METHOD(Vector2, _font_get_glyph_offset);
    METHOD(Variant, _font_set_glyph_offset);
    METHOD(Vector2, _font_get_glyph_size);
    METHOD(Variant, _font_set_glyph_size);
    METHOD(Rect2, _font_get_glyph_uv_rect);
    METHOD(Variant, _font_set_glyph_uv_rect);
    METHOD(int64_t, _font_get_glyph_texture_idx);
    METHOD(Variant, _font_set_glyph_texture_idx);
    METHOD(::RID, _font_get_glyph_texture_rid);
    METHOD(Vector2, _font_get_glyph_texture_size);
    METHOD(Dictionary, _font_get_glyph_contours);
    METHOD(Array, _font_get_kerning_list);
    METHOD(Variant, _font_clear_kerning_map);
    METHOD(Variant, _font_remove_kerning);
    METHOD(Variant, _font_set_kerning);
    METHOD(Vector2, _font_get_kerning);
    METHOD(int64_t, _font_get_glyph_index);
    METHOD(int64_t, _font_get_char_from_glyph_index);
    METHOD(bool, _font_has_char);
    METHOD(String, _font_get_supported_chars);
    METHOD(Variant, _font_render_range);
    METHOD(Variant, _font_render_glyph);
    METHOD(Variant, _font_draw_glyph);
    METHOD(Variant, _font_draw_glyph_outline);
    METHOD(bool, _font_is_language_supported);
    METHOD(Variant, _font_set_language_support_override);
    METHOD(bool, _font_get_language_support_override);
    METHOD(Variant, _font_remove_language_support_override);
    METHOD(PackedArray<std::string>, _font_get_language_support_overrides);
    METHOD(bool, _font_is_script_supported);
    METHOD(Variant, _font_set_script_support_override);
    METHOD(bool, _font_get_script_support_override);
    METHOD(Variant, _font_remove_script_support_override);
    METHOD(PackedArray<std::string>, _font_get_script_support_overrides);
    METHOD(Variant, _font_set_opentype_feature_overrides);
    METHOD(Dictionary, _font_get_opentype_feature_overrides);
    METHOD(Dictionary, _font_supported_feature_list);
    METHOD(Dictionary, _font_supported_variation_list);
    METHOD(double, _font_get_global_oversampling);
    METHOD(Variant, _font_set_global_oversampling);
    METHOD(Vector2, _get_hex_code_box_size);
    METHOD(Variant, _draw_hex_code_box);
    METHOD(::RID, _create_shaped_text);
    METHOD(Variant, _shaped_text_clear);
    METHOD(Variant, _shaped_text_set_direction);
    METHOD(int64_t, _shaped_text_get_direction);
    METHOD(int64_t, _shaped_text_get_inferred_direction);
    METHOD(Variant, _shaped_text_set_bidi_override);
    METHOD(Variant, _shaped_text_set_custom_punctuation);
    METHOD(String, _shaped_text_get_custom_punctuation);
    METHOD(Variant, _shaped_text_set_custom_ellipsis);
    METHOD(int64_t, _shaped_text_get_custom_ellipsis);
    METHOD(Variant, _shaped_text_set_orientation);
    METHOD(int64_t, _shaped_text_get_orientation);
    METHOD(Variant, _shaped_text_set_preserve_invalid);
    METHOD(bool, _shaped_text_get_preserve_invalid);
    METHOD(Variant, _shaped_text_set_preserve_control);
    METHOD(bool, _shaped_text_get_preserve_control);
    METHOD(Variant, _shaped_text_set_spacing);
    METHOD(int64_t, _shaped_text_get_spacing);
    METHOD(bool, _shaped_text_add_string);
    METHOD(bool, _shaped_text_add_object);
    METHOD(bool, _shaped_text_resize_object);
    METHOD(int64_t, _shaped_get_span_count);
    METHOD(Variant, _shaped_get_span_meta);
    METHOD(Variant, _shaped_set_span_update_font);
    METHOD(::RID, _shaped_text_substr);
    METHOD(::RID, _shaped_text_get_parent);
    METHOD(double, _shaped_text_fit_to_width);
    METHOD(double, _shaped_text_tab_align);
    METHOD(bool, _shaped_text_shape);
    METHOD(bool, _shaped_text_update_breaks);
    METHOD(bool, _shaped_text_update_justification_ops);
    METHOD(bool, _shaped_text_is_ready);
    METHOD(int64_t, _shaped_text_get_glyphs);
    METHOD(int64_t, _shaped_text_sort_logical);
    METHOD(int64_t, _shaped_text_get_glyph_count);
    METHOD(Vector2i, _shaped_text_get_range);
    METHOD(PackedArray<int32_t>, _shaped_text_get_line_breaks_adv);
    METHOD(PackedArray<int32_t>, _shaped_text_get_line_breaks);
    METHOD(PackedArray<int32_t>, _shaped_text_get_word_breaks);
    METHOD(int64_t, _shaped_text_get_trim_pos);
    METHOD(int64_t, _shaped_text_get_ellipsis_pos);
    METHOD(int64_t, _shaped_text_get_ellipsis_glyph_count);
    METHOD(int64_t, _shaped_text_get_ellipsis_glyphs);
    METHOD(Variant, _shaped_text_overrun_trim_to_width);
    METHOD(Array, _shaped_text_get_objects);
    METHOD(Rect2, _shaped_text_get_object_rect);
    METHOD(Vector2i, _shaped_text_get_object_range);
    METHOD(int64_t, _shaped_text_get_object_glyph);
    METHOD(Vector2, _shaped_text_get_size);
    METHOD(double, _shaped_text_get_ascent);
    METHOD(double, _shaped_text_get_descent);
    METHOD(double, _shaped_text_get_width);
    METHOD(double, _shaped_text_get_underline_position);
    METHOD(double, _shaped_text_get_underline_thickness);
    METHOD(int64_t, _shaped_text_get_dominant_direction_in_range);
    METHOD(Variant, _shaped_text_get_carets);
    METHOD(PackedArray<Vector2>, _shaped_text_get_selection);
    METHOD(int64_t, _shaped_text_hit_test_grapheme);
    METHOD(int64_t, _shaped_text_hit_test_position);
    METHOD(Variant, _shaped_text_draw);
    METHOD(Variant, _shaped_text_draw_outline);
    METHOD(Vector2, _shaped_text_get_grapheme_bounds);
    METHOD(int64_t, _shaped_text_next_grapheme_pos);
    METHOD(int64_t, _shaped_text_prev_grapheme_pos);
    METHOD(PackedArray<int32_t>, _shaped_text_get_character_breaks);
    METHOD(int64_t, _shaped_text_next_character_pos);
    METHOD(int64_t, _shaped_text_prev_character_pos);
    METHOD(int64_t, _shaped_text_closest_character_pos);
    METHOD(String, _format_number);
    METHOD(String, _parse_number);
    METHOD(String, _percent_sign);
    METHOD(String, _strip_diacritics);
    METHOD(bool, _is_valid_identifier);
    METHOD(bool, _is_valid_letter);
    METHOD(PackedArray<int32_t>, _string_get_word_breaks);
    METHOD(PackedArray<int32_t>, _string_get_character_breaks);
    METHOD(int64_t, _is_confusable);
    METHOD(bool, _spoof_check);
    METHOD(String, _string_to_upper);
    METHOD(String, _string_to_lower);
    METHOD(String, _string_to_title);
    METHOD(Array, _parse_structured_text);
    METHOD(Variant, _cleanup);
};
struct TextServerManager : public Object {
    using Object::Object;
    METHOD(Variant, add_interface);
    METHOD(int64_t, get_interface_count);
    METHOD(Variant, remove_interface);
    METHOD(Object, get_interface);
    METHOD(Array, get_interfaces);
    METHOD(Object, find_interface);
    METHOD(void, set_primary_interface);
    METHOD(Object, get_primary_interface);
    static TextServerManager get_singleton() { return TextServerManager(Object("TextServerManager").address()); }
};
struct Texture : public Resource {
    using Resource::Resource;
};
struct Texture2D : public Texture {
    using Texture::Texture;
    METHOD(int64_t, _get_width);
    METHOD(int64_t, _get_height);
    METHOD(bool, _is_pixel_opaque);
    METHOD(bool, _has_alpha);
    METHOD(Variant, _draw);
    METHOD(Variant, _draw_rect);
    METHOD(Variant, _draw_rect_region);
    METHOD(int64_t, get_width);
    METHOD(int64_t, get_height);
    METHOD(Vector2, get_size);
    METHOD(bool, has_alpha);
    METHOD(Variant, draw);
    METHOD(Variant, draw_rect);
    METHOD(Variant, draw_rect_region);
    METHOD(Object, get_image);
    METHOD(Object, create_placeholder);
};
struct Texture2DRD : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(texture_rd_rid, ::RID);
    METHOD(void, set_texture_rd_rid);
    METHOD(::RID, get_texture_rd_rid);
};
struct Texture3D : public Texture {
    using Texture::Texture;
    METHOD(int64_t, _get_format);
    METHOD(int64_t, _get_width);
    METHOD(int64_t, _get_height);
    METHOD(int64_t, _get_depth);
    METHOD(bool, _has_mipmaps);
    METHOD(Array, _get_data);
    METHOD(int64_t, get_format);
    METHOD(int64_t, get_width);
    METHOD(int64_t, get_height);
    METHOD(int64_t, get_depth);
    METHOD(bool, has_mipmaps);
    METHOD(Array, get_data);
    METHOD(Object, create_placeholder);
};
struct Texture3DRD : public Texture3D {
    using Texture3D::Texture3D;
    PROPERTY(texture_rd_rid, ::RID);
    METHOD(void, set_texture_rd_rid);
    METHOD(::RID, get_texture_rd_rid);
};
struct TextureLayered : public Texture {
    using Texture::Texture;
    METHOD(int64_t, _get_format);
    METHOD(int64_t, _get_layered_type);
    METHOD(int64_t, _get_width);
    METHOD(int64_t, _get_height);
    METHOD(int64_t, _get_layers);
    METHOD(bool, _has_mipmaps);
    METHOD(Object, _get_layer_data);
    METHOD(int64_t, get_format);
    METHOD(int64_t, get_layered_type);
    METHOD(int64_t, get_width);
    METHOD(int64_t, get_height);
    METHOD(int64_t, get_layers);
    METHOD(bool, has_mipmaps);
    METHOD(Object, get_layer_data);
    static constexpr int64_t LAYERED_TYPE_2D_ARRAY = 0;
    static constexpr int64_t LAYERED_TYPE_CUBEMAP = 1;
    static constexpr int64_t LAYERED_TYPE_CUBEMAP_ARRAY = 2;
};
struct TextureLayeredRD : public TextureLayered {
    using TextureLayered::TextureLayered;
    PROPERTY(texture_rd_rid, ::RID);
    METHOD(void, set_texture_rd_rid);
    METHOD(::RID, get_texture_rd_rid);
};
struct TextureProgressBar : public Range {
    using Range::Range;
    PROPERTY(fill_mode, int64_t);
    PROPERTY(radial_initial_angle, double);
    PROPERTY(radial_fill_degrees, double);
    PROPERTY(radial_center_offset, Vector2);
    PROPERTY(nine_patch_stretch, bool);
    PROPERTY(stretch_margin_left, int64_t);
    PROPERTY(stretch_margin_top, int64_t);
    PROPERTY(stretch_margin_right, int64_t);
    PROPERTY(stretch_margin_bottom, int64_t);
    PROPERTY(texture_under, Object);
    PROPERTY(texture_over, Object);
    PROPERTY(texture_progress, Object);
    PROPERTY(texture_progress_offset, Vector2);
    PROPERTY(tint_under, Color);
    PROPERTY(tint_over, Color);
    PROPERTY(tint_progress, Color);
    METHOD(void, set_under_texture);
    METHOD(Object, get_under_texture);
    METHOD(void, set_progress_texture);
    METHOD(Object, get_progress_texture);
    METHOD(void, set_over_texture);
    METHOD(Object, get_over_texture);
    METHOD(void, set_fill_mode);
    METHOD(int64_t, get_fill_mode);
    METHOD(void, set_tint_under);
    METHOD(Color, get_tint_under);
    METHOD(void, set_tint_progress);
    METHOD(Color, get_tint_progress);
    METHOD(void, set_tint_over);
    METHOD(Color, get_tint_over);
    METHOD(void, set_texture_progress_offset);
    METHOD(Vector2, get_texture_progress_offset);
    METHOD(void, set_radial_initial_angle);
    METHOD(double, get_radial_initial_angle);
    METHOD(void, set_radial_center_offset);
    METHOD(Vector2, get_radial_center_offset);
    METHOD(void, set_fill_degrees);
    METHOD(double, get_fill_degrees);
    METHOD(void, set_stretch_margin);
    METHOD(int64_t, get_stretch_margin);
    METHOD(void, set_nine_patch_stretch);
    METHOD(bool, get_nine_patch_stretch);
    static constexpr int64_t FILL_LEFT_TO_RIGHT = 0;
    static constexpr int64_t FILL_RIGHT_TO_LEFT = 1;
    static constexpr int64_t FILL_TOP_TO_BOTTOM = 2;
    static constexpr int64_t FILL_BOTTOM_TO_TOP = 3;
    static constexpr int64_t FILL_CLOCKWISE = 4;
    static constexpr int64_t FILL_COUNTER_CLOCKWISE = 5;
    static constexpr int64_t FILL_BILINEAR_LEFT_AND_RIGHT = 6;
    static constexpr int64_t FILL_BILINEAR_TOP_AND_BOTTOM = 7;
    static constexpr int64_t FILL_CLOCKWISE_AND_COUNTER_CLOCKWISE = 8;
};
struct TextureRect : public Control {
    using Control::Control;
    PROPERTY(texture, Object);
    PROPERTY(expand_mode, int64_t);
    PROPERTY(stretch_mode, int64_t);
    PROPERTY(flip_h, bool);
    PROPERTY(flip_v, bool);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_expand_mode);
    METHOD(int64_t, get_expand_mode);
    METHOD(void, set_flip_h);
    METHOD(bool, is_flipped_h);
    METHOD(void, set_flip_v);
    METHOD(bool, is_flipped_v);
    METHOD(void, set_stretch_mode);
    METHOD(int64_t, get_stretch_mode);
    static constexpr int64_t EXPAND_KEEP_SIZE = 0;
    static constexpr int64_t EXPAND_IGNORE_SIZE = 1;
    static constexpr int64_t EXPAND_FIT_WIDTH = 2;
    static constexpr int64_t EXPAND_FIT_WIDTH_PROPORTIONAL = 3;
    static constexpr int64_t EXPAND_FIT_HEIGHT = 4;
    static constexpr int64_t EXPAND_FIT_HEIGHT_PROPORTIONAL = 5;
    static constexpr int64_t STRETCH_SCALE = 0;
    static constexpr int64_t STRETCH_TILE = 1;
    static constexpr int64_t STRETCH_KEEP = 2;
    static constexpr int64_t STRETCH_KEEP_CENTERED = 3;
    static constexpr int64_t STRETCH_KEEP_ASPECT = 4;
    static constexpr int64_t STRETCH_KEEP_ASPECT_CENTERED = 5;
    static constexpr int64_t STRETCH_KEEP_ASPECT_COVERED = 6;
};
struct Theme : public Resource {
    using Resource::Resource;
    PROPERTY(default_base_scale, double);
    PROPERTY(default_font, Object);
    PROPERTY(default_font_size, int64_t);
    METHOD(void, set_icon);
    METHOD(Object, get_icon);
    METHOD(bool, has_icon);
    METHOD(Variant, rename_icon);
    METHOD(Variant, clear_icon);
    METHOD(PackedArray<std::string>, get_icon_list);
    METHOD(PackedArray<std::string>, get_icon_type_list);
    METHOD(void, set_stylebox);
    METHOD(Object, get_stylebox);
    METHOD(bool, has_stylebox);
    METHOD(Variant, rename_stylebox);
    METHOD(Variant, clear_stylebox);
    METHOD(PackedArray<std::string>, get_stylebox_list);
    METHOD(PackedArray<std::string>, get_stylebox_type_list);
    METHOD(void, set_font);
    METHOD(Object, get_font);
    METHOD(bool, has_font);
    METHOD(Variant, rename_font);
    METHOD(Variant, clear_font);
    METHOD(PackedArray<std::string>, get_font_list);
    METHOD(PackedArray<std::string>, get_font_type_list);
    METHOD(void, set_font_size);
    METHOD(int64_t, get_font_size);
    METHOD(bool, has_font_size);
    METHOD(Variant, rename_font_size);
    METHOD(Variant, clear_font_size);
    METHOD(PackedArray<std::string>, get_font_size_list);
    METHOD(PackedArray<std::string>, get_font_size_type_list);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(bool, has_color);
    METHOD(Variant, rename_color);
    METHOD(Variant, clear_color);
    METHOD(PackedArray<std::string>, get_color_list);
    METHOD(PackedArray<std::string>, get_color_type_list);
    METHOD(void, set_constant);
    METHOD(int64_t, get_constant);
    METHOD(bool, has_constant);
    METHOD(Variant, rename_constant);
    METHOD(Variant, clear_constant);
    METHOD(PackedArray<std::string>, get_constant_list);
    METHOD(PackedArray<std::string>, get_constant_type_list);
    METHOD(void, set_default_base_scale);
    METHOD(double, get_default_base_scale);
    METHOD(bool, has_default_base_scale);
    METHOD(void, set_default_font);
    METHOD(Object, get_default_font);
    METHOD(bool, has_default_font);
    METHOD(void, set_default_font_size);
    METHOD(int64_t, get_default_font_size);
    METHOD(bool, has_default_font_size);
    METHOD(void, set_theme_item);
    METHOD(Variant, get_theme_item);
    METHOD(bool, has_theme_item);
    METHOD(Variant, rename_theme_item);
    METHOD(Variant, clear_theme_item);
    METHOD(PackedArray<std::string>, get_theme_item_list);
    METHOD(PackedArray<std::string>, get_theme_item_type_list);
    METHOD(void, set_type_variation);
    METHOD(bool, is_type_variation);
    METHOD(Variant, clear_type_variation);
    METHOD(String, get_type_variation_base);
    METHOD(PackedArray<std::string>, get_type_variation_list);
    METHOD(Variant, add_type);
    METHOD(Variant, remove_type);
    METHOD(PackedArray<std::string>, get_type_list);
    METHOD(Variant, merge_with);
    METHOD(Variant, clear);
    static constexpr int64_t DATA_TYPE_COLOR = 0;
    static constexpr int64_t DATA_TYPE_CONSTANT = 1;
    static constexpr int64_t DATA_TYPE_FONT = 2;
    static constexpr int64_t DATA_TYPE_FONT_SIZE = 3;
    static constexpr int64_t DATA_TYPE_ICON = 4;
    static constexpr int64_t DATA_TYPE_STYLEBOX = 5;
    static constexpr int64_t DATA_TYPE_MAX = 6;
};
struct ThemeContext : public Object {
    using Object::Object;
};
struct ThemeDB : public Object {
    using Object::Object;
    PROPERTY(fallback_base_scale, double);
    PROPERTY(fallback_font, Object);
    PROPERTY(fallback_font_size, int64_t);
    PROPERTY(fallback_icon, Object);
    PROPERTY(fallback_stylebox, Object);
    METHOD(Object, get_default_theme);
    METHOD(Object, get_project_theme);
    METHOD(void, set_fallback_base_scale);
    METHOD(double, get_fallback_base_scale);
    METHOD(void, set_fallback_font);
    METHOD(Object, get_fallback_font);
    METHOD(void, set_fallback_font_size);
    METHOD(int64_t, get_fallback_font_size);
    METHOD(void, set_fallback_icon);
    METHOD(Object, get_fallback_icon);
    METHOD(void, set_fallback_stylebox);
    METHOD(Object, get_fallback_stylebox);
    static ThemeDB get_singleton() { return ThemeDB(Object("ThemeDB").address()); }
};
struct Thread : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, start);
    METHOD(String, get_id);
    METHOD(bool, is_started);
    METHOD(bool, is_alive);
    METHOD(Variant, wait_to_finish);
    METHOD(void, set_thread_safety_checks_enabled);
    static constexpr int64_t PRIORITY_LOW = 0;
    static constexpr int64_t PRIORITY_NORMAL = 1;
    static constexpr int64_t PRIORITY_HIGH = 2;
};
struct TileAtlasView : public Control {
    using Control::Control;
};
struct TileData : public Object {
    using Object::Object;
    PROPERTY(flip_h, bool);
    PROPERTY(flip_v, bool);
    PROPERTY(transpose, bool);
    PROPERTY(texture_origin, Vector2i);
    PROPERTY(modulate, Color);
    PROPERTY(material, Object);
    PROPERTY(z_index, int64_t);
    PROPERTY(y_sort_origin, int64_t);
    PROPERTY(terrain_set, int64_t);
    PROPERTY(terrain, int64_t);
    PROPERTY(probability, double);
    METHOD(void, set_flip_h);
    METHOD(bool, get_flip_h);
    METHOD(void, set_flip_v);
    METHOD(bool, get_flip_v);
    METHOD(void, set_transpose);
    METHOD(bool, get_transpose);
    METHOD(void, set_material);
    METHOD(Object, get_material);
    METHOD(void, set_texture_origin);
    METHOD(Vector2i, get_texture_origin);
    METHOD(void, set_modulate);
    METHOD(Color, get_modulate);
    METHOD(void, set_z_index);
    METHOD(int64_t, get_z_index);
    METHOD(void, set_y_sort_origin);
    METHOD(int64_t, get_y_sort_origin);
    METHOD(void, set_occluder);
    METHOD(Object, get_occluder);
    METHOD(void, set_constant_linear_velocity);
    METHOD(Vector2, get_constant_linear_velocity);
    METHOD(void, set_constant_angular_velocity);
    METHOD(double, get_constant_angular_velocity);
    METHOD(void, set_collision_polygons_count);
    METHOD(int64_t, get_collision_polygons_count);
    METHOD(Variant, add_collision_polygon);
    METHOD(Variant, remove_collision_polygon);
    METHOD(void, set_collision_polygon_points);
    METHOD(PackedArray<Vector2>, get_collision_polygon_points);
    METHOD(void, set_collision_polygon_one_way);
    METHOD(bool, is_collision_polygon_one_way);
    METHOD(void, set_collision_polygon_one_way_margin);
    METHOD(double, get_collision_polygon_one_way_margin);
    METHOD(void, set_terrain_set);
    METHOD(int64_t, get_terrain_set);
    METHOD(void, set_terrain);
    METHOD(int64_t, get_terrain);
    METHOD(void, set_terrain_peering_bit);
    METHOD(int64_t, get_terrain_peering_bit);
    METHOD(bool, is_valid_terrain_peering_bit);
    METHOD(void, set_navigation_polygon);
    METHOD(Object, get_navigation_polygon);
    METHOD(void, set_probability);
    METHOD(double, get_probability);
    METHOD(void, set_custom_data);
    METHOD(Variant, get_custom_data);
    METHOD(void, set_custom_data_by_layer_id);
    METHOD(Variant, get_custom_data_by_layer_id);
};
struct TileMap : public Node2D {
    using Node2D::Node2D;
    PROPERTY(tile_set, Object);
    PROPERTY(rendering_quadrant_size, int64_t);
    PROPERTY(collision_animatable, bool);
    PROPERTY(collision_visibility_mode, int64_t);
    PROPERTY(navigation_visibility_mode, int64_t);
    METHOD(bool, _use_tile_data_runtime_update);
    METHOD(Variant, _tile_data_runtime_update);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(Variant, force_update);
    METHOD(void, set_tileset);
    METHOD(Object, get_tileset);
    METHOD(void, set_rendering_quadrant_size);
    METHOD(int64_t, get_rendering_quadrant_size);
    METHOD(int64_t, get_layers_count);
    METHOD(Variant, add_layer);
    METHOD(Variant, move_layer);
    METHOD(Variant, remove_layer);
    METHOD(void, set_layer_name);
    METHOD(String, get_layer_name);
    METHOD(void, set_layer_enabled);
    METHOD(bool, is_layer_enabled);
    METHOD(void, set_layer_modulate);
    METHOD(Color, get_layer_modulate);
    METHOD(void, set_layer_y_sort_enabled);
    METHOD(bool, is_layer_y_sort_enabled);
    METHOD(void, set_layer_y_sort_origin);
    METHOD(int64_t, get_layer_y_sort_origin);
    METHOD(void, set_layer_z_index);
    METHOD(int64_t, get_layer_z_index);
    METHOD(void, set_layer_navigation_enabled);
    METHOD(bool, is_layer_navigation_enabled);
    METHOD(void, set_layer_navigation_map);
    METHOD(::RID, get_layer_navigation_map);
    METHOD(void, set_collision_animatable);
    METHOD(bool, is_collision_animatable);
    METHOD(void, set_collision_visibility_mode);
    METHOD(int64_t, get_collision_visibility_mode);
    METHOD(void, set_navigation_visibility_mode);
    METHOD(int64_t, get_navigation_visibility_mode);
    METHOD(void, set_cell);
    METHOD(Variant, erase_cell);
    METHOD(int64_t, get_cell_source_id);
    METHOD(Vector2i, get_cell_atlas_coords);
    METHOD(int64_t, get_cell_alternative_tile);
    METHOD(Object, get_cell_tile_data);
    METHOD(Vector2i, get_coords_for_body_rid);
    METHOD(int64_t, get_layer_for_body_rid);
    METHOD(Object, get_pattern);
    METHOD(Vector2i, map_pattern);
    METHOD(void, set_pattern);
    METHOD(void, set_cells_terrain_connect);
    METHOD(void, set_cells_terrain_path);
    METHOD(Variant, fix_invalid_tiles);
    METHOD(Variant, clear_layer);
    METHOD(Variant, clear);
    METHOD(Variant, update_internals);
    METHOD(Variant, notify_runtime_tile_data_update);
    METHOD(Array, get_surrounding_cells);
    METHOD(Array, get_used_cells);
    METHOD(Array, get_used_cells_by_id);
    METHOD(Rect2i, get_used_rect);
    METHOD(Vector2, map_to_local);
    METHOD(Vector2i, local_to_map);
    METHOD(Vector2i, get_neighbor_cell);
    static constexpr int64_t VISIBILITY_MODE_DEFAULT = 0;
    static constexpr int64_t VISIBILITY_MODE_FORCE_HIDE = 2;
    static constexpr int64_t VISIBILITY_MODE_FORCE_SHOW = 1;
};
struct TileMapLayer : public Node2D {
    using Node2D::Node2D;
    PROPERTY(tile_map_data, PackedArray<uint8_t>);
    PROPERTY(enabled, bool);
    PROPERTY(tile_set, Object);
    PROPERTY(y_sort_origin, int64_t);
    PROPERTY(x_draw_order_reversed, bool);
    PROPERTY(rendering_quadrant_size, int64_t);
    PROPERTY(collision_enabled, bool);
    PROPERTY(use_kinematic_bodies, bool);
    PROPERTY(collision_visibility_mode, int64_t);
    PROPERTY(navigation_enabled, bool);
    PROPERTY(navigation_visibility_mode, int64_t);
    METHOD(bool, _use_tile_data_runtime_update);
    METHOD(Variant, _tile_data_runtime_update);
    METHOD(void, set_cell);
    METHOD(Variant, erase_cell);
    METHOD(Variant, fix_invalid_tiles);
    METHOD(Variant, clear);
    METHOD(int64_t, get_cell_source_id);
    METHOD(Vector2i, get_cell_atlas_coords);
    METHOD(int64_t, get_cell_alternative_tile);
    METHOD(Object, get_cell_tile_data);
    METHOD(Array, get_used_cells);
    METHOD(Array, get_used_cells_by_id);
    METHOD(Rect2i, get_used_rect);
    METHOD(Object, get_pattern);
    METHOD(void, set_pattern);
    METHOD(void, set_cells_terrain_connect);
    METHOD(void, set_cells_terrain_path);
    METHOD(bool, has_body_rid);
    METHOD(Vector2i, get_coords_for_body_rid);
    METHOD(Variant, update_internals);
    METHOD(Variant, notify_runtime_tile_data_update);
    METHOD(Vector2i, map_pattern);
    METHOD(Array, get_surrounding_cells);
    METHOD(Vector2i, get_neighbor_cell);
    METHOD(Vector2, map_to_local);
    METHOD(Vector2i, local_to_map);
    METHOD(void, set_tile_map_data_from_array);
    METHOD(PackedArray<uint8_t>, get_tile_map_data_as_array);
    METHOD(void, set_enabled);
    METHOD(bool, is_enabled);
    METHOD(void, set_tile_set);
    METHOD(Object, get_tile_set);
    METHOD(void, set_y_sort_origin);
    METHOD(int64_t, get_y_sort_origin);
    METHOD(void, set_x_draw_order_reversed);
    METHOD(bool, is_x_draw_order_reversed);
    METHOD(void, set_rendering_quadrant_size);
    METHOD(int64_t, get_rendering_quadrant_size);
    METHOD(void, set_collision_enabled);
    METHOD(bool, is_collision_enabled);
    METHOD(void, set_use_kinematic_bodies);
    METHOD(bool, is_using_kinematic_bodies);
    METHOD(void, set_collision_visibility_mode);
    METHOD(int64_t, get_collision_visibility_mode);
    METHOD(void, set_navigation_enabled);
    METHOD(bool, is_navigation_enabled);
    METHOD(void, set_navigation_map);
    METHOD(::RID, get_navigation_map);
    METHOD(void, set_navigation_visibility_mode);
    METHOD(int64_t, get_navigation_visibility_mode);
    static constexpr int64_t DEBUG_VISIBILITY_MODE_DEFAULT = 0;
    static constexpr int64_t DEBUG_VISIBILITY_MODE_FORCE_HIDE = 2;
    static constexpr int64_t DEBUG_VISIBILITY_MODE_FORCE_SHOW = 1;
};
struct TileMapPattern : public Resource {
    using Resource::Resource;
    METHOD(void, set_cell);
    METHOD(bool, has_cell);
    METHOD(Variant, remove_cell);
    METHOD(int64_t, get_cell_source_id);
    METHOD(Vector2i, get_cell_atlas_coords);
    METHOD(int64_t, get_cell_alternative_tile);
    METHOD(Array, get_used_cells);
    METHOD(Vector2i, get_size);
    METHOD(void, set_size);
    METHOD(bool, is_empty);
};
struct TileSet : public Resource {
    using Resource::Resource;
    PROPERTY(tile_shape, int64_t);
    PROPERTY(tile_layout, int64_t);
    PROPERTY(tile_offset_axis, int64_t);
    PROPERTY(tile_size, Vector2i);
    PROPERTY(uv_clipping, bool);
    METHOD(int64_t, get_next_source_id);
    METHOD(int64_t, add_source);
    METHOD(Variant, remove_source);
    METHOD(void, set_source_id);
    METHOD(int64_t, get_source_count);
    METHOD(int64_t, get_source_id);
    METHOD(bool, has_source);
    METHOD(Object, get_source);
    METHOD(void, set_tile_shape);
    METHOD(int64_t, get_tile_shape);
    METHOD(void, set_tile_layout);
    METHOD(int64_t, get_tile_layout);
    METHOD(void, set_tile_offset_axis);
    METHOD(int64_t, get_tile_offset_axis);
    METHOD(void, set_tile_size);
    METHOD(Vector2i, get_tile_size);
    METHOD(void, set_uv_clipping);
    METHOD(bool, is_uv_clipping);
    METHOD(int64_t, get_occlusion_layers_count);
    METHOD(Variant, add_occlusion_layer);
    METHOD(Variant, move_occlusion_layer);
    METHOD(Variant, remove_occlusion_layer);
    METHOD(void, set_occlusion_layer_light_mask);
    METHOD(int64_t, get_occlusion_layer_light_mask);
    METHOD(void, set_occlusion_layer_sdf_collision);
    METHOD(bool, get_occlusion_layer_sdf_collision);
    METHOD(int64_t, get_physics_layers_count);
    METHOD(Variant, add_physics_layer);
    METHOD(Variant, move_physics_layer);
    METHOD(Variant, remove_physics_layer);
    METHOD(void, set_physics_layer_collision_layer);
    METHOD(int64_t, get_physics_layer_collision_layer);
    METHOD(void, set_physics_layer_collision_mask);
    METHOD(int64_t, get_physics_layer_collision_mask);
    METHOD(void, set_physics_layer_physics_material);
    METHOD(Object, get_physics_layer_physics_material);
    METHOD(int64_t, get_terrain_sets_count);
    METHOD(Variant, add_terrain_set);
    METHOD(Variant, move_terrain_set);
    METHOD(Variant, remove_terrain_set);
    METHOD(void, set_terrain_set_mode);
    METHOD(int64_t, get_terrain_set_mode);
    METHOD(int64_t, get_terrains_count);
    METHOD(Variant, add_terrain);
    METHOD(Variant, move_terrain);
    METHOD(Variant, remove_terrain);
    METHOD(void, set_terrain_name);
    METHOD(String, get_terrain_name);
    METHOD(void, set_terrain_color);
    METHOD(Color, get_terrain_color);
    METHOD(int64_t, get_navigation_layers_count);
    METHOD(Variant, add_navigation_layer);
    METHOD(Variant, move_navigation_layer);
    METHOD(Variant, remove_navigation_layer);
    METHOD(void, set_navigation_layer_layers);
    METHOD(int64_t, get_navigation_layer_layers);
    METHOD(void, set_navigation_layer_layer_value);
    METHOD(bool, get_navigation_layer_layer_value);
    METHOD(int64_t, get_custom_data_layers_count);
    METHOD(Variant, add_custom_data_layer);
    METHOD(Variant, move_custom_data_layer);
    METHOD(Variant, remove_custom_data_layer);
    METHOD(int64_t, get_custom_data_layer_by_name);
    METHOD(void, set_custom_data_layer_name);
    METHOD(String, get_custom_data_layer_name);
    METHOD(void, set_custom_data_layer_type);
    METHOD(int64_t, get_custom_data_layer_type);
    METHOD(void, set_source_level_tile_proxy);
    METHOD(int64_t, get_source_level_tile_proxy);
    METHOD(bool, has_source_level_tile_proxy);
    METHOD(Variant, remove_source_level_tile_proxy);
    METHOD(void, set_coords_level_tile_proxy);
    METHOD(Array, get_coords_level_tile_proxy);
    METHOD(bool, has_coords_level_tile_proxy);
    METHOD(Variant, remove_coords_level_tile_proxy);
    METHOD(void, set_alternative_level_tile_proxy);
    METHOD(Array, get_alternative_level_tile_proxy);
    METHOD(bool, has_alternative_level_tile_proxy);
    METHOD(Variant, remove_alternative_level_tile_proxy);
    METHOD(Array, map_tile_proxy);
    METHOD(Variant, cleanup_invalid_tile_proxies);
    METHOD(Variant, clear_tile_proxies);
    METHOD(int64_t, add_pattern);
    METHOD(Object, get_pattern);
    METHOD(Variant, remove_pattern);
    METHOD(int64_t, get_patterns_count);
    static constexpr int64_t TILE_SHAPE_SQUARE = 0;
    static constexpr int64_t TILE_SHAPE_ISOMETRIC = 1;
    static constexpr int64_t TILE_SHAPE_HALF_OFFSET_SQUARE = 2;
    static constexpr int64_t TILE_SHAPE_HEXAGON = 3;
    static constexpr int64_t TILE_LAYOUT_STACKED = 0;
    static constexpr int64_t TILE_LAYOUT_STACKED_OFFSET = 1;
    static constexpr int64_t TILE_LAYOUT_STAIRS_RIGHT = 2;
    static constexpr int64_t TILE_LAYOUT_STAIRS_DOWN = 3;
    static constexpr int64_t TILE_LAYOUT_DIAMOND_RIGHT = 4;
    static constexpr int64_t TILE_LAYOUT_DIAMOND_DOWN = 5;
    static constexpr int64_t TILE_OFFSET_AXIS_HORIZONTAL = 0;
    static constexpr int64_t TILE_OFFSET_AXIS_VERTICAL = 1;
    static constexpr int64_t CELL_NEIGHBOR_RIGHT_SIDE = 0;
    static constexpr int64_t CELL_NEIGHBOR_RIGHT_CORNER = 1;
    static constexpr int64_t CELL_NEIGHBOR_BOTTOM_RIGHT_SIDE = 2;
    static constexpr int64_t CELL_NEIGHBOR_BOTTOM_RIGHT_CORNER = 3;
    static constexpr int64_t CELL_NEIGHBOR_BOTTOM_SIDE = 4;
    static constexpr int64_t CELL_NEIGHBOR_BOTTOM_CORNER = 5;
    static constexpr int64_t CELL_NEIGHBOR_BOTTOM_LEFT_SIDE = 6;
    static constexpr int64_t CELL_NEIGHBOR_BOTTOM_LEFT_CORNER = 7;
    static constexpr int64_t CELL_NEIGHBOR_LEFT_SIDE = 8;
    static constexpr int64_t CELL_NEIGHBOR_LEFT_CORNER = 9;
    static constexpr int64_t CELL_NEIGHBOR_TOP_LEFT_SIDE = 10;
    static constexpr int64_t CELL_NEIGHBOR_TOP_LEFT_CORNER = 11;
    static constexpr int64_t CELL_NEIGHBOR_TOP_SIDE = 12;
    static constexpr int64_t CELL_NEIGHBOR_TOP_CORNER = 13;
    static constexpr int64_t CELL_NEIGHBOR_TOP_RIGHT_SIDE = 14;
    static constexpr int64_t CELL_NEIGHBOR_TOP_RIGHT_CORNER = 15;
    static constexpr int64_t TERRAIN_MODE_MATCH_CORNERS_AND_SIDES = 0;
    static constexpr int64_t TERRAIN_MODE_MATCH_CORNERS = 1;
    static constexpr int64_t TERRAIN_MODE_MATCH_SIDES = 2;
};
struct TileSetAtlasSourceProxyObject : public Object {
    using Object::Object;
};
struct TileSetScenesCollectionProxyObject : public Object {
    using Object::Object;
    PROPERTY(id, int64_t);
    METHOD(void, set_id);
    METHOD(int64_t, get_id);
};
struct TileSetSource : public Resource {
    using Resource::Resource;
    METHOD(int64_t, get_tiles_count);
    METHOD(Vector2i, get_tile_id);
    METHOD(bool, has_tile);
    METHOD(int64_t, get_alternative_tiles_count);
    METHOD(int64_t, get_alternative_tile_id);
    METHOD(bool, has_alternative_tile);
};
struct Time : public Object {
    using Object::Object;
    METHOD(Dictionary, get_datetime_dict_from_unix_time);
    METHOD(Dictionary, get_date_dict_from_unix_time);
    METHOD(Dictionary, get_time_dict_from_unix_time);
    METHOD(String, get_datetime_string_from_unix_time);
    METHOD(String, get_date_string_from_unix_time);
    METHOD(String, get_time_string_from_unix_time);
    METHOD(Dictionary, get_datetime_dict_from_datetime_string);
    METHOD(String, get_datetime_string_from_datetime_dict);
    METHOD(int64_t, get_unix_time_from_datetime_dict);
    METHOD(int64_t, get_unix_time_from_datetime_string);
    METHOD(String, get_offset_string_from_offset_minutes);
    METHOD(Dictionary, get_datetime_dict_from_system);
    METHOD(Dictionary, get_date_dict_from_system);
    METHOD(Dictionary, get_time_dict_from_system);
    METHOD(String, get_datetime_string_from_system);
    METHOD(String, get_date_string_from_system);
    METHOD(String, get_time_string_from_system);
    METHOD(Dictionary, get_time_zone_from_system);
    METHOD(double, get_unix_time_from_system);
    METHOD(int64_t, get_ticks_msec);
    METHOD(int64_t, get_ticks_usec);
    static constexpr int64_t MONTH_JANUARY = 1;
    static constexpr int64_t MONTH_FEBRUARY = 2;
    static constexpr int64_t MONTH_MARCH = 3;
    static constexpr int64_t MONTH_APRIL = 4;
    static constexpr int64_t MONTH_MAY = 5;
    static constexpr int64_t MONTH_JUNE = 6;
    static constexpr int64_t MONTH_JULY = 7;
    static constexpr int64_t MONTH_AUGUST = 8;
    static constexpr int64_t MONTH_SEPTEMBER = 9;
    static constexpr int64_t MONTH_OCTOBER = 10;
    static constexpr int64_t MONTH_NOVEMBER = 11;
    static constexpr int64_t MONTH_DECEMBER = 12;
    static constexpr int64_t WEEKDAY_SUNDAY = 0;
    static constexpr int64_t WEEKDAY_MONDAY = 1;
    static constexpr int64_t WEEKDAY_TUESDAY = 2;
    static constexpr int64_t WEEKDAY_WEDNESDAY = 3;
    static constexpr int64_t WEEKDAY_THURSDAY = 4;
    static constexpr int64_t WEEKDAY_FRIDAY = 5;
    static constexpr int64_t WEEKDAY_SATURDAY = 6;
    static Time get_singleton() { return Time(Object("Time").address()); }
};
struct Timer : public Node {
    using Node::Node;
    PROPERTY(process_callback, int64_t);
    PROPERTY(wait_time, double);
    PROPERTY(one_shot, bool);
    PROPERTY(autostart, bool);
    PROPERTY(paused, bool);
    PROPERTY(time_left, double);
    METHOD(void, set_wait_time);
    METHOD(double, get_wait_time);
    METHOD(void, set_one_shot);
    METHOD(bool, is_one_shot);
    METHOD(void, set_autostart);
    METHOD(bool, has_autostart);
    METHOD(Variant, start);
    METHOD(Variant, stop);
    METHOD(void, set_paused);
    METHOD(bool, is_paused);
    METHOD(bool, is_stopped);
    METHOD(double, get_time_left);
    METHOD(void, set_timer_process_callback);
    METHOD(int64_t, get_timer_process_callback);
    static constexpr int64_t TIMER_PROCESS_PHYSICS = 0;
    static constexpr int64_t TIMER_PROCESS_IDLE = 1;
};
struct TouchScreenButton : public Node2D {
    using Node2D::Node2D;
    PROPERTY(texture_normal, Object);
    PROPERTY(texture_pressed, Object);
    PROPERTY(bitmask, Object);
    PROPERTY(shape, Object);
    PROPERTY(shape_centered, bool);
    PROPERTY(shape_visible, bool);
    PROPERTY(passby_press, bool);
    PROPERTY(action, String);
    PROPERTY(visibility_mode, int64_t);
    METHOD(void, set_texture_normal);
    METHOD(Object, get_texture_normal);
    METHOD(void, set_texture_pressed);
    METHOD(Object, get_texture_pressed);
    METHOD(void, set_bitmask);
    METHOD(Object, get_bitmask);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(void, set_shape_centered);
    METHOD(bool, is_shape_centered);
    METHOD(void, set_shape_visible);
    METHOD(bool, is_shape_visible);
    METHOD(void, set_action);
    METHOD(String, get_action);
    METHOD(void, set_visibility_mode);
    METHOD(int64_t, get_visibility_mode);
    METHOD(void, set_passby_press);
    METHOD(bool, is_passby_press_enabled);
    METHOD(bool, is_pressed);
    static constexpr int64_t VISIBILITY_ALWAYS = 0;
    static constexpr int64_t VISIBILITY_TOUCHSCREEN_ONLY = 1;
};
struct Translation : public Resource {
    using Resource::Resource;
    PROPERTY(messages, Dictionary);
    PROPERTY(locale, String);
    METHOD(String, _get_plural_message);
    METHOD(String, _get_message);
    METHOD(void, set_locale);
    METHOD(String, get_locale);
    METHOD(Variant, add_message);
    METHOD(Variant, add_plural_message);
    METHOD(String, get_message);
    METHOD(String, get_plural_message);
    METHOD(Variant, erase_message);
    METHOD(PackedArray<std::string>, get_message_list);
    METHOD(PackedArray<std::string>, get_translated_message_list);
    METHOD(int64_t, get_message_count);
    METHOD(Variant, _set_messages);
    METHOD(Dictionary, _get_messages);
};
struct TranslationServer : public Object {
    using Object::Object;
    PROPERTY(pseudolocalization_enabled, bool);
    METHOD(void, set_locale);
    METHOD(String, get_locale);
    METHOD(String, get_tool_locale);
    METHOD(int64_t, compare_locales);
    METHOD(String, standardize_locale);
    METHOD(PackedArray<std::string>, get_all_languages);
    METHOD(String, get_language_name);
    METHOD(PackedArray<std::string>, get_all_scripts);
    METHOD(String, get_script_name);
    METHOD(PackedArray<std::string>, get_all_countries);
    METHOD(String, get_country_name);
    METHOD(String, get_locale_name);
    METHOD(String, translate);
    METHOD(String, translate_plural);
    METHOD(Variant, add_translation);
    METHOD(Variant, remove_translation);
    METHOD(Object, get_translation_object);
    METHOD(Variant, clear);
    METHOD(PackedArray<std::string>, get_loaded_locales);
    METHOD(bool, is_pseudolocalization_enabled);
    METHOD(void, set_pseudolocalization_enabled);
    METHOD(Variant, reload_pseudolocalization);
    METHOD(String, pseudolocalize);
    static TranslationServer get_singleton() { return TranslationServer(Object("TranslationServer").address()); }
};
struct Tree : public Control {
    using Control::Control;
    PROPERTY(columns, int64_t);
    PROPERTY(column_titles_visible, bool);
    PROPERTY(allow_reselect, bool);
    PROPERTY(allow_rmb_select, bool);
    PROPERTY(allow_search, bool);
    PROPERTY(hide_folding, bool);
    PROPERTY(enable_recursive_folding, bool);
    PROPERTY(hide_root, bool);
    PROPERTY(drop_mode_flags, int64_t);
    PROPERTY(select_mode, int64_t);
    PROPERTY(scroll_horizontal_enabled, bool);
    PROPERTY(scroll_vertical_enabled, bool);
    METHOD(Variant, clear);
    METHOD(Object, create_item);
    METHOD(Object, get_root);
    METHOD(void, set_column_custom_minimum_width);
    METHOD(void, set_column_expand);
    METHOD(void, set_column_expand_ratio);
    METHOD(void, set_column_clip_content);
    METHOD(bool, is_column_expanding);
    METHOD(bool, is_column_clipping_content);
    METHOD(int64_t, get_column_expand_ratio);
    METHOD(int64_t, get_column_width);
    METHOD(void, set_hide_root);
    METHOD(bool, is_root_hidden);
    METHOD(Object, get_next_selected);
    METHOD(Object, get_selected);
    METHOD(void, set_selected);
    METHOD(int64_t, get_selected_column);
    METHOD(int64_t, get_pressed_button);
    METHOD(void, set_select_mode);
    METHOD(int64_t, get_select_mode);
    METHOD(Variant, deselect_all);
    METHOD(void, set_columns);
    METHOD(int64_t, get_columns);
    METHOD(Object, get_edited);
    METHOD(int64_t, get_edited_column);
    METHOD(bool, edit_selected);
    METHOD(Rect2, get_custom_popup_rect);
    METHOD(Rect2, get_item_area_rect);
    METHOD(Object, get_item_at_position);
    METHOD(int64_t, get_column_at_position);
    METHOD(int64_t, get_drop_section_at_position);
    METHOD(int64_t, get_button_id_at_position);
    METHOD(Variant, ensure_cursor_is_visible);
    METHOD(void, set_column_titles_visible);
    METHOD(bool, are_column_titles_visible);
    METHOD(void, set_column_title);
    METHOD(String, get_column_title);
    METHOD(void, set_column_title_alignment);
    METHOD(int64_t, get_column_title_alignment);
    METHOD(void, set_column_title_direction);
    METHOD(int64_t, get_column_title_direction);
    METHOD(void, set_column_title_language);
    METHOD(String, get_column_title_language);
    METHOD(Vector2, get_scroll);
    METHOD(Variant, scroll_to_item);
    METHOD(void, set_h_scroll_enabled);
    METHOD(bool, is_h_scroll_enabled);
    METHOD(void, set_v_scroll_enabled);
    METHOD(bool, is_v_scroll_enabled);
    METHOD(void, set_hide_folding);
    METHOD(bool, is_folding_hidden);
    METHOD(void, set_enable_recursive_folding);
    METHOD(bool, is_recursive_folding_enabled);
    METHOD(void, set_drop_mode_flags);
    METHOD(int64_t, get_drop_mode_flags);
    METHOD(void, set_allow_rmb_select);
    METHOD(bool, get_allow_rmb_select);
    METHOD(void, set_allow_reselect);
    METHOD(bool, get_allow_reselect);
    METHOD(void, set_allow_search);
    METHOD(bool, get_allow_search);
    static constexpr int64_t SELECT_SINGLE = 0;
    static constexpr int64_t SELECT_ROW = 1;
    static constexpr int64_t SELECT_MULTI = 2;
    static constexpr int64_t DROP_MODE_DISABLED = 0;
    static constexpr int64_t DROP_MODE_ON_ITEM = 1;
    static constexpr int64_t DROP_MODE_INBETWEEN = 2;
};
struct TreeItem : public Object {
    using Object::Object;
    PROPERTY(collapsed, bool);
    PROPERTY(visible, bool);
    PROPERTY(disable_folding, bool);
    PROPERTY(custom_minimum_height, int64_t);
    METHOD(void, set_cell_mode);
    METHOD(int64_t, get_cell_mode);
    METHOD(void, set_edit_multiline);
    METHOD(bool, is_edit_multiline);
    METHOD(void, set_checked);
    METHOD(void, set_indeterminate);
    METHOD(bool, is_checked);
    METHOD(bool, is_indeterminate);
    METHOD(Variant, propagate_check);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_autowrap_mode);
    METHOD(int64_t, get_autowrap_mode);
    METHOD(void, set_text_overrun_behavior);
    METHOD(int64_t, get_text_overrun_behavior);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_suffix);
    METHOD(String, get_suffix);
    METHOD(void, set_icon);
    METHOD(Object, get_icon);
    METHOD(void, set_icon_region);
    METHOD(Rect2, get_icon_region);
    METHOD(void, set_icon_max_width);
    METHOD(int64_t, get_icon_max_width);
    METHOD(void, set_icon_modulate);
    METHOD(Color, get_icon_modulate);
    METHOD(void, set_range);
    METHOD(double, get_range);
    METHOD(void, set_range_config);
    METHOD(Dictionary, get_range_config);
    METHOD(void, set_metadata);
    METHOD(Variant, get_metadata);
    METHOD(void, set_custom_draw);
    METHOD(void, set_custom_draw_callback);
    METHOD(Callable, get_custom_draw_callback);
    METHOD(void, set_collapsed);
    METHOD(bool, is_collapsed);
    METHOD(void, set_collapsed_recursive);
    METHOD(bool, is_any_collapsed);
    METHOD(void, set_visible);
    METHOD(bool, is_visible);
    METHOD(bool, is_visible_in_tree);
    METHOD(Variant, uncollapse_tree);
    METHOD(void, set_custom_minimum_height);
    METHOD(int64_t, get_custom_minimum_height);
    METHOD(void, set_selectable);
    METHOD(bool, is_selectable);
    METHOD(bool, is_selected);
    METHOD(Variant, select);
    METHOD(Variant, deselect);
    METHOD(void, set_editable);
    METHOD(bool, is_editable);
    METHOD(void, set_custom_color);
    METHOD(Color, get_custom_color);
    METHOD(Variant, clear_custom_color);
    METHOD(void, set_custom_font);
    METHOD(Object, get_custom_font);
    METHOD(void, set_custom_font_size);
    METHOD(int64_t, get_custom_font_size);
    METHOD(void, set_custom_bg_color);
    METHOD(Variant, clear_custom_bg_color);
    METHOD(Color, get_custom_bg_color);
    METHOD(void, set_custom_as_button);
    METHOD(bool, is_custom_set_as_button);
    METHOD(Variant, add_button);
    METHOD(int64_t, get_button_count);
    METHOD(String, get_button_tooltip_text);
    METHOD(int64_t, get_button_id);
    METHOD(int64_t, get_button_by_id);
    METHOD(Color, get_button_color);
    METHOD(Object, get_button);
    METHOD(void, set_button_tooltip_text);
    METHOD(void, set_button);
    METHOD(Variant, erase_button);
    METHOD(void, set_button_disabled);
    METHOD(void, set_button_color);
    METHOD(bool, is_button_disabled);
    METHOD(void, set_tooltip_text);
    METHOD(String, get_tooltip_text);
    METHOD(void, set_text_alignment);
    METHOD(int64_t, get_text_alignment);
    METHOD(void, set_expand_right);
    METHOD(bool, get_expand_right);
    METHOD(void, set_disable_folding);
    METHOD(bool, is_folding_disabled);
    METHOD(Object, create_child);
    METHOD(Variant, add_child);
    METHOD(Variant, remove_child);
    METHOD(Object, get_tree);
    METHOD(Object, get_next);
    METHOD(Object, get_prev);
    METHOD(Object, get_parent);
    METHOD(Object, get_first_child);
    METHOD(Object, get_next_in_tree);
    METHOD(Object, get_prev_in_tree);
    METHOD(Object, get_next_visible);
    METHOD(Object, get_prev_visible);
    METHOD(Object, get_child);
    METHOD(int64_t, get_child_count);
    METHOD(Array, get_children);
    METHOD(int64_t, get_index);
    METHOD(Variant, move_before);
    METHOD(Variant, move_after);
    METHOD(Variant, call_recursive);
    static constexpr int64_t CELL_MODE_STRING = 0;
    static constexpr int64_t CELL_MODE_CHECK = 1;
    static constexpr int64_t CELL_MODE_RANGE = 2;
    static constexpr int64_t CELL_MODE_ICON = 3;
    static constexpr int64_t CELL_MODE_CUSTOM = 4;
};
struct TriangleMesh : public RefCounted {
    using RefCounted::RefCounted;
};
struct Tween : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Object, tween_property);
    METHOD(Object, tween_interval);
    METHOD(Object, tween_callback);
    METHOD(Object, tween_method);
    METHOD(bool, custom_step);
    METHOD(Variant, stop);
    METHOD(Variant, pause);
    METHOD(Variant, play);
    METHOD(Variant, kill);
    METHOD(double, get_total_elapsed_time);
    METHOD(bool, is_running);
    METHOD(bool, is_valid);
    METHOD(Object, bind_node);
    METHOD(Object, set_process_mode);
    METHOD(Object, set_pause_mode);
    METHOD(Object, set_parallel);
    METHOD(Object, set_loops);
    METHOD(int64_t, get_loops_left);
    METHOD(Object, set_speed_scale);
    METHOD(Object, set_trans);
    METHOD(Object, set_ease);
    METHOD(Object, parallel);
    METHOD(Object, chain);
    METHOD(Variant, interpolate_value);
    static constexpr int64_t TWEEN_PROCESS_PHYSICS = 0;
    static constexpr int64_t TWEEN_PROCESS_IDLE = 1;
    static constexpr int64_t TWEEN_PAUSE_BOUND = 0;
    static constexpr int64_t TWEEN_PAUSE_STOP = 1;
    static constexpr int64_t TWEEN_PAUSE_PROCESS = 2;
    static constexpr int64_t TRANS_LINEAR = 0;
    static constexpr int64_t TRANS_SINE = 1;
    static constexpr int64_t TRANS_QUINT = 2;
    static constexpr int64_t TRANS_QUART = 3;
    static constexpr int64_t TRANS_QUAD = 4;
    static constexpr int64_t TRANS_EXPO = 5;
    static constexpr int64_t TRANS_ELASTIC = 6;
    static constexpr int64_t TRANS_CUBIC = 7;
    static constexpr int64_t TRANS_CIRC = 8;
    static constexpr int64_t TRANS_BOUNCE = 9;
    static constexpr int64_t TRANS_BACK = 10;
    static constexpr int64_t TRANS_SPRING = 11;
    static constexpr int64_t EASE_IN = 0;
    static constexpr int64_t EASE_OUT = 1;
    static constexpr int64_t EASE_IN_OUT = 2;
    static constexpr int64_t EASE_OUT_IN = 3;
};
struct Tweener : public RefCounted {
    using RefCounted::RefCounted;
};
struct UDPServer : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(max_pending_connections, int64_t);
    METHOD(int64_t, listen);
    METHOD(int64_t, poll);
    METHOD(bool, is_connection_available);
    METHOD(int64_t, get_local_port);
    METHOD(bool, is_listening);
    METHOD(Object, take_connection);
    METHOD(Variant, stop);
    METHOD(void, set_max_pending_connections);
    METHOD(int64_t, get_max_pending_connections);
};
struct UPNP : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(discover_multicast_if, String);
    PROPERTY(discover_local_port, int64_t);
    PROPERTY(discover_ipv6, bool);
    METHOD(int64_t, get_device_count);
    METHOD(Object, get_device);
    METHOD(Variant, add_device);
    METHOD(void, set_device);
    METHOD(Variant, remove_device);
    METHOD(Variant, clear_devices);
    METHOD(Object, get_gateway);
    METHOD(int64_t, discover);
    METHOD(String, query_external_address);
    METHOD(int64_t, add_port_mapping);
    METHOD(int64_t, delete_port_mapping);
    METHOD(void, set_discover_multicast_if);
    METHOD(String, get_discover_multicast_if);
    METHOD(void, set_discover_local_port);
    METHOD(int64_t, get_discover_local_port);
    METHOD(void, set_discover_ipv6);
    METHOD(bool, is_discover_ipv6);
    static constexpr int64_t UPNP_RESULT_SUCCESS = 0;
    static constexpr int64_t UPNP_RESULT_NOT_AUTHORIZED = 1;
    static constexpr int64_t UPNP_RESULT_PORT_MAPPING_NOT_FOUND = 2;
    static constexpr int64_t UPNP_RESULT_INCONSISTENT_PARAMETERS = 3;
    static constexpr int64_t UPNP_RESULT_NO_SUCH_ENTRY_IN_ARRAY = 4;
    static constexpr int64_t UPNP_RESULT_ACTION_FAILED = 5;
    static constexpr int64_t UPNP_RESULT_SRC_IP_WILDCARD_NOT_PERMITTED = 6;
    static constexpr int64_t UPNP_RESULT_EXT_PORT_WILDCARD_NOT_PERMITTED = 7;
    static constexpr int64_t UPNP_RESULT_INT_PORT_WILDCARD_NOT_PERMITTED = 8;
    static constexpr int64_t UPNP_RESULT_REMOTE_HOST_MUST_BE_WILDCARD = 9;
    static constexpr int64_t UPNP_RESULT_EXT_PORT_MUST_BE_WILDCARD = 10;
    static constexpr int64_t UPNP_RESULT_NO_PORT_MAPS_AVAILABLE = 11;
    static constexpr int64_t UPNP_RESULT_CONFLICT_WITH_OTHER_MECHANISM = 12;
    static constexpr int64_t UPNP_RESULT_CONFLICT_WITH_OTHER_MAPPING = 13;
    static constexpr int64_t UPNP_RESULT_SAME_PORT_VALUES_REQUIRED = 14;
    static constexpr int64_t UPNP_RESULT_ONLY_PERMANENT_LEASE_SUPPORTED = 15;
    static constexpr int64_t UPNP_RESULT_INVALID_GATEWAY = 16;
    static constexpr int64_t UPNP_RESULT_INVALID_PORT = 17;
    static constexpr int64_t UPNP_RESULT_INVALID_PROTOCOL = 18;
    static constexpr int64_t UPNP_RESULT_INVALID_DURATION = 19;
    static constexpr int64_t UPNP_RESULT_INVALID_ARGS = 20;
    static constexpr int64_t UPNP_RESULT_INVALID_RESPONSE = 21;
    static constexpr int64_t UPNP_RESULT_INVALID_PARAM = 22;
    static constexpr int64_t UPNP_RESULT_HTTP_ERROR = 23;
    static constexpr int64_t UPNP_RESULT_SOCKET_ERROR = 24;
    static constexpr int64_t UPNP_RESULT_MEM_ALLOC_ERROR = 25;
    static constexpr int64_t UPNP_RESULT_NO_GATEWAY = 26;
    static constexpr int64_t UPNP_RESULT_NO_DEVICES = 27;
    static constexpr int64_t UPNP_RESULT_UNKNOWN_ERROR = 28;
};
struct UPNPDevice : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(description_url, String);
    PROPERTY(service_type, String);
    PROPERTY(igd_control_url, String);
    PROPERTY(igd_service_type, String);
    PROPERTY(igd_our_addr, String);
    PROPERTY(igd_status, int64_t);
    METHOD(bool, is_valid_gateway);
    METHOD(String, query_external_address);
    METHOD(int64_t, add_port_mapping);
    METHOD(int64_t, delete_port_mapping);
    METHOD(void, set_description_url);
    METHOD(String, get_description_url);
    METHOD(void, set_service_type);
    METHOD(String, get_service_type);
    METHOD(void, set_igd_control_url);
    METHOD(String, get_igd_control_url);
    METHOD(void, set_igd_service_type);
    METHOD(String, get_igd_service_type);
    METHOD(void, set_igd_our_addr);
    METHOD(String, get_igd_our_addr);
    METHOD(void, set_igd_status);
    METHOD(int64_t, get_igd_status);
    static constexpr int64_t IGD_STATUS_OK = 0;
    static constexpr int64_t IGD_STATUS_HTTP_ERROR = 1;
    static constexpr int64_t IGD_STATUS_HTTP_EMPTY = 2;
    static constexpr int64_t IGD_STATUS_NO_URLS = 3;
    static constexpr int64_t IGD_STATUS_NO_IGD = 4;
    static constexpr int64_t IGD_STATUS_DISCONNECTED = 5;
    static constexpr int64_t IGD_STATUS_UNKNOWN_DEVICE = 6;
    static constexpr int64_t IGD_STATUS_INVALID_CONTROL = 7;
    static constexpr int64_t IGD_STATUS_MALLOC_ERROR = 8;
    static constexpr int64_t IGD_STATUS_UNKNOWN_ERROR = 9;
};
struct UndoRedo : public Object {
    using Object::Object;
    PROPERTY(max_steps, int64_t);
    METHOD(Variant, create_action);
    METHOD(Variant, commit_action);
    METHOD(bool, is_committing_action);
    METHOD(Variant, add_do_method);
    METHOD(Variant, add_undo_method);
    METHOD(Variant, add_do_property);
    METHOD(Variant, add_undo_property);
    METHOD(Variant, add_do_reference);
    METHOD(Variant, add_undo_reference);
    METHOD(Variant, start_force_keep_in_merge_ends);
    METHOD(Variant, end_force_keep_in_merge_ends);
    METHOD(int64_t, get_history_count);
    METHOD(int64_t, get_current_action);
    METHOD(String, get_action_name);
    METHOD(Variant, clear_history);
    METHOD(String, get_current_action_name);
    METHOD(bool, has_undo);
    METHOD(bool, has_redo);
    METHOD(int64_t, get_version);
    METHOD(void, set_max_steps);
    METHOD(int64_t, get_max_steps);
    METHOD(bool, redo);
    METHOD(bool, undo);
    static constexpr int64_t MERGE_DISABLE = 0;
    static constexpr int64_t MERGE_ENDS = 1;
    static constexpr int64_t MERGE_ALL = 2;
};
struct UniformSetCacheRD : public Object {
    using Object::Object;
    METHOD(::RID, get_cache);
};
struct VScrollBar : public ScrollBar {
    using ScrollBar::ScrollBar;
};
struct VSeparator : public Separator {
    using Separator::Separator;
};
struct VSlider : public Slider {
    using Slider::Slider;
};
struct VehicleBody3D : public RigidBody3D {
    using RigidBody3D::RigidBody3D;
    PROPERTY(engine_force, double);
    PROPERTY(brake, double);
    PROPERTY(steering, double);
    METHOD(void, set_engine_force);
    METHOD(double, get_engine_force);
    METHOD(void, set_brake);
    METHOD(double, get_brake);
    METHOD(void, set_steering);
    METHOD(double, get_steering);
};
struct VehicleWheel3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(engine_force, double);
    PROPERTY(brake, double);
    PROPERTY(steering, double);
    PROPERTY(use_as_traction, bool);
    PROPERTY(use_as_steering, bool);
    PROPERTY(wheel_roll_influence, double);
    PROPERTY(wheel_radius, double);
    PROPERTY(wheel_rest_length, double);
    PROPERTY(wheel_friction_slip, double);
    PROPERTY(suspension_travel, double);
    PROPERTY(suspension_stiffness, double);
    PROPERTY(suspension_max_force, double);
    PROPERTY(damping_compression, double);
    PROPERTY(damping_relaxation, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_suspension_rest_length);
    METHOD(double, get_suspension_rest_length);
    METHOD(void, set_suspension_travel);
    METHOD(double, get_suspension_travel);
    METHOD(void, set_suspension_stiffness);
    METHOD(double, get_suspension_stiffness);
    METHOD(void, set_suspension_max_force);
    METHOD(double, get_suspension_max_force);
    METHOD(void, set_damping_compression);
    METHOD(double, get_damping_compression);
    METHOD(void, set_damping_relaxation);
    METHOD(double, get_damping_relaxation);
    METHOD(void, set_use_as_traction);
    METHOD(bool, is_used_as_traction);
    METHOD(void, set_use_as_steering);
    METHOD(bool, is_used_as_steering);
    METHOD(void, set_friction_slip);
    METHOD(double, get_friction_slip);
    METHOD(bool, is_in_contact);
    METHOD(Object, get_contact_body);
    METHOD(void, set_roll_influence);
    METHOD(double, get_roll_influence);
    METHOD(double, get_skidinfo);
    METHOD(double, get_rpm);
    METHOD(void, set_engine_force);
    METHOD(double, get_engine_force);
    METHOD(void, set_brake);
    METHOD(double, get_brake);
    METHOD(void, set_steering);
    METHOD(double, get_steering);
};
struct VideoStream : public Resource {
    using Resource::Resource;
    PROPERTY(file, String);
    METHOD(Object, _instantiate_playback);
    METHOD(void, set_file);
    METHOD(String, get_file);
};
struct VideoStreamPlayback : public Resource {
    using Resource::Resource;
    METHOD(Variant, _stop);
    METHOD(Variant, _play);
    METHOD(bool, _is_playing);
    METHOD(Variant, _set_paused);
    METHOD(bool, _is_paused);
    METHOD(double, _get_length);
    METHOD(double, _get_playback_position);
    METHOD(Variant, _seek);
    METHOD(Variant, _set_audio_track);
    METHOD(Object, _get_texture);
    METHOD(Variant, _update);
    METHOD(int64_t, _get_channels);
    METHOD(int64_t, _get_mix_rate);
    METHOD(int64_t, mix_audio);
};
struct VideoStreamPlayer : public Control {
    using Control::Control;
    PROPERTY(audio_track, int64_t);
    PROPERTY(stream, Object);
    PROPERTY(volume_db, double);
    PROPERTY(volume, double);
    PROPERTY(autoplay, bool);
    PROPERTY(paused, bool);
    PROPERTY(expand, bool);
    PROPERTY(loop, bool);
    PROPERTY(buffering_msec, int64_t);
    PROPERTY(stream_position, double);
    PROPERTY(bus, String);
    METHOD(void, set_stream);
    METHOD(Object, get_stream);
    METHOD(Variant, play);
    METHOD(Variant, stop);
    METHOD(bool, is_playing);
    METHOD(void, set_paused);
    METHOD(bool, is_paused);
    METHOD(void, set_loop);
    METHOD(bool, has_loop);
    METHOD(void, set_volume);
    METHOD(double, get_volume);
    METHOD(void, set_volume_db);
    METHOD(double, get_volume_db);
    METHOD(void, set_audio_track);
    METHOD(int64_t, get_audio_track);
    METHOD(String, get_stream_name);
    METHOD(double, get_stream_length);
    METHOD(void, set_stream_position);
    METHOD(double, get_stream_position);
    METHOD(void, set_autoplay);
    METHOD(bool, has_autoplay);
    METHOD(void, set_expand);
    METHOD(bool, has_expand);
    METHOD(void, set_buffering_msec);
    METHOD(int64_t, get_buffering_msec);
    METHOD(void, set_bus);
    METHOD(String, get_bus);
    METHOD(Object, get_video_texture);
};
struct VideoStreamTheora : public VideoStream {
    using VideoStream::VideoStream;
};
struct ViewPanner : public RefCounted {
    using RefCounted::RefCounted;
};
struct Viewport : public Node {
    using Node::Node;
    PROPERTY(disable_3d, bool);
    PROPERTY(use_xr, bool);
    PROPERTY(own_world_3d, bool);
    PROPERTY(world_3d, Object);
    PROPERTY(world_2d, Object);
    PROPERTY(transparent_bg, bool);
    PROPERTY(handle_input_locally, bool);
    PROPERTY(snap_2d_transforms_to_pixel, bool);
    PROPERTY(snap_2d_vertices_to_pixel, bool);
    PROPERTY(msaa_2d, int64_t);
    PROPERTY(msaa_3d, int64_t);
    PROPERTY(screen_space_aa, int64_t);
    PROPERTY(use_taa, bool);
    PROPERTY(use_debanding, bool);
    PROPERTY(use_occlusion_culling, bool);
    PROPERTY(mesh_lod_threshold, double);
    PROPERTY(debug_draw, int64_t);
    PROPERTY(use_hdr_2d, bool);
    PROPERTY(scaling_3d_mode, int64_t);
    PROPERTY(scaling_3d_scale, double);
    PROPERTY(texture_mipmap_bias, double);
    PROPERTY(fsr_sharpness, double);
    PROPERTY(vrs_mode, int64_t);
    PROPERTY(vrs_update_mode, int64_t);
    PROPERTY(vrs_texture, Object);
    PROPERTY(canvas_item_default_texture_filter, int64_t);
    PROPERTY(canvas_item_default_texture_repeat, int64_t);
    PROPERTY(audio_listener_enable_2d, bool);
    PROPERTY(audio_listener_enable_3d, bool);
    PROPERTY(physics_object_picking, bool);
    PROPERTY(physics_object_picking_sort, bool);
    PROPERTY(physics_object_picking_first_only, bool);
    PROPERTY(gui_disable_input, bool);
    PROPERTY(gui_snap_controls_to_pixels, bool);
    PROPERTY(gui_embed_subwindows, bool);
    PROPERTY(sdf_oversize, int64_t);
    PROPERTY(sdf_scale, int64_t);
    PROPERTY(positional_shadow_atlas_size, int64_t);
    PROPERTY(positional_shadow_atlas_16_bits, bool);
    PROPERTY(positional_shadow_atlas_quad_0, int64_t);
    PROPERTY(positional_shadow_atlas_quad_1, int64_t);
    PROPERTY(positional_shadow_atlas_quad_2, int64_t);
    PROPERTY(positional_shadow_atlas_quad_3, int64_t);
    PROPERTY(canvas_transform, Transform2D);
    PROPERTY(global_canvas_transform, Transform2D);
    PROPERTY(canvas_cull_mask, int64_t);
    METHOD(void, set_world_2d);
    METHOD(Object, get_world_2d);
    METHOD(Object, find_world_2d);
    METHOD(void, set_canvas_transform);
    METHOD(Transform2D, get_canvas_transform);
    METHOD(void, set_global_canvas_transform);
    METHOD(Transform2D, get_global_canvas_transform);
    METHOD(Transform2D, get_final_transform);
    METHOD(Transform2D, get_screen_transform);
    METHOD(Rect2, get_visible_rect);
    METHOD(void, set_transparent_background);
    METHOD(bool, has_transparent_background);
    METHOD(void, set_use_hdr_2d);
    METHOD(bool, is_using_hdr_2d);
    METHOD(void, set_msaa_2d);
    METHOD(int64_t, get_msaa_2d);
    METHOD(void, set_msaa_3d);
    METHOD(int64_t, get_msaa_3d);
    METHOD(void, set_screen_space_aa);
    METHOD(int64_t, get_screen_space_aa);
    METHOD(void, set_use_taa);
    METHOD(bool, is_using_taa);
    METHOD(void, set_use_debanding);
    METHOD(bool, is_using_debanding);
    METHOD(void, set_use_occlusion_culling);
    METHOD(bool, is_using_occlusion_culling);
    METHOD(void, set_debug_draw);
    METHOD(int64_t, get_debug_draw);
    METHOD(int64_t, get_render_info);
    METHOD(Object, get_texture);
    METHOD(void, set_physics_object_picking);
    METHOD(bool, get_physics_object_picking);
    METHOD(void, set_physics_object_picking_sort);
    METHOD(bool, get_physics_object_picking_sort);
    METHOD(void, set_physics_object_picking_first_only);
    METHOD(bool, get_physics_object_picking_first_only);
    METHOD(::RID, get_viewport_rid);
    METHOD(Variant, push_text_input);
    METHOD(Variant, push_input);
    METHOD(Variant, push_unhandled_input);
    METHOD(Vector2, get_mouse_position);
    METHOD(Variant, warp_mouse);
    METHOD(Variant, update_mouse_cursor_state);
    METHOD(Variant, gui_get_drag_data);
    METHOD(bool, gui_is_dragging);
    METHOD(bool, gui_is_drag_successful);
    METHOD(Variant, gui_release_focus);
    METHOD(Object, gui_get_focus_owner);
    METHOD(Object, gui_get_hovered_control);
    METHOD(void, set_disable_input);
    METHOD(bool, is_input_disabled);
    METHOD(Variant, _gui_remove_focus_for_window);
    METHOD(void, set_positional_shadow_atlas_size);
    METHOD(int64_t, get_positional_shadow_atlas_size);
    METHOD(void, set_positional_shadow_atlas_16_bits);
    METHOD(bool, get_positional_shadow_atlas_16_bits);
    METHOD(void, set_snap_controls_to_pixels);
    METHOD(bool, is_snap_controls_to_pixels_enabled);
    METHOD(void, set_snap_2d_transforms_to_pixel);
    METHOD(bool, is_snap_2d_transforms_to_pixel_enabled);
    METHOD(void, set_snap_2d_vertices_to_pixel);
    METHOD(bool, is_snap_2d_vertices_to_pixel_enabled);
    METHOD(void, set_positional_shadow_atlas_quadrant_subdiv);
    METHOD(int64_t, get_positional_shadow_atlas_quadrant_subdiv);
    METHOD(void, set_input_as_handled);
    METHOD(bool, is_input_handled);
    METHOD(void, set_handle_input_locally);
    METHOD(bool, is_handling_input_locally);
    METHOD(void, set_default_canvas_item_texture_filter);
    METHOD(int64_t, get_default_canvas_item_texture_filter);
    METHOD(void, set_embedding_subwindows);
    METHOD(bool, is_embedding_subwindows);
    METHOD(Array, get_embedded_subwindows);
    METHOD(void, set_canvas_cull_mask);
    METHOD(int64_t, get_canvas_cull_mask);
    METHOD(void, set_canvas_cull_mask_bit);
    METHOD(bool, get_canvas_cull_mask_bit);
    METHOD(void, set_default_canvas_item_texture_repeat);
    METHOD(int64_t, get_default_canvas_item_texture_repeat);
    METHOD(void, set_sdf_oversize);
    METHOD(int64_t, get_sdf_oversize);
    METHOD(void, set_sdf_scale);
    METHOD(int64_t, get_sdf_scale);
    METHOD(void, set_mesh_lod_threshold);
    METHOD(double, get_mesh_lod_threshold);
    METHOD(Variant, _process_picking);
    METHOD(void, set_as_audio_listener_2d);
    METHOD(bool, is_audio_listener_2d);
    METHOD(Object, get_camera_2d);
    METHOD(void, set_world_3d);
    METHOD(Object, get_world_3d);
    METHOD(Object, find_world_3d);
    METHOD(void, set_use_own_world_3d);
    METHOD(bool, is_using_own_world_3d);
    METHOD(Object, get_camera_3d);
    METHOD(void, set_as_audio_listener_3d);
    METHOD(bool, is_audio_listener_3d);
    METHOD(void, set_disable_3d);
    METHOD(bool, is_3d_disabled);
    METHOD(void, set_use_xr);
    METHOD(bool, is_using_xr);
    METHOD(void, set_scaling_3d_mode);
    METHOD(int64_t, get_scaling_3d_mode);
    METHOD(void, set_scaling_3d_scale);
    METHOD(double, get_scaling_3d_scale);
    METHOD(void, set_fsr_sharpness);
    METHOD(double, get_fsr_sharpness);
    METHOD(void, set_texture_mipmap_bias);
    METHOD(double, get_texture_mipmap_bias);
    METHOD(void, set_vrs_mode);
    METHOD(int64_t, get_vrs_mode);
    METHOD(void, set_vrs_update_mode);
    METHOD(int64_t, get_vrs_update_mode);
    METHOD(void, set_vrs_texture);
    METHOD(Object, get_vrs_texture);
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_DISABLED = 0;
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_1 = 1;
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_4 = 2;
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_16 = 3;
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_64 = 4;
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_256 = 5;
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_1024 = 6;
    static constexpr int64_t SHADOW_ATLAS_QUADRANT_SUBDIV_MAX = 7;
    static constexpr int64_t SCALING_3D_MODE_BILINEAR = 0;
    static constexpr int64_t SCALING_3D_MODE_FSR = 1;
    static constexpr int64_t SCALING_3D_MODE_FSR2 = 2;
    static constexpr int64_t SCALING_3D_MODE_MAX = 3;
    static constexpr int64_t MSAA_DISABLED = 0;
    static constexpr int64_t MSAA_2X = 1;
    static constexpr int64_t MSAA_4X = 2;
    static constexpr int64_t MSAA_8X = 3;
    static constexpr int64_t MSAA_MAX = 4;
    static constexpr int64_t SCREEN_SPACE_AA_DISABLED = 0;
    static constexpr int64_t SCREEN_SPACE_AA_FXAA = 1;
    static constexpr int64_t SCREEN_SPACE_AA_MAX = 2;
    static constexpr int64_t RENDER_INFO_OBJECTS_IN_FRAME = 0;
    static constexpr int64_t RENDER_INFO_PRIMITIVES_IN_FRAME = 1;
    static constexpr int64_t RENDER_INFO_DRAW_CALLS_IN_FRAME = 2;
    static constexpr int64_t RENDER_INFO_MAX = 3;
    static constexpr int64_t RENDER_INFO_TYPE_VISIBLE = 0;
    static constexpr int64_t RENDER_INFO_TYPE_SHADOW = 1;
    static constexpr int64_t RENDER_INFO_TYPE_CANVAS = 2;
    static constexpr int64_t RENDER_INFO_TYPE_MAX = 3;
    static constexpr int64_t DEBUG_DRAW_DISABLED = 0;
    static constexpr int64_t DEBUG_DRAW_UNSHADED = 1;
    static constexpr int64_t DEBUG_DRAW_LIGHTING = 2;
    static constexpr int64_t DEBUG_DRAW_OVERDRAW = 3;
    static constexpr int64_t DEBUG_DRAW_WIREFRAME = 4;
    static constexpr int64_t DEBUG_DRAW_NORMAL_BUFFER = 5;
    static constexpr int64_t DEBUG_DRAW_VOXEL_GI_ALBEDO = 6;
    static constexpr int64_t DEBUG_DRAW_VOXEL_GI_LIGHTING = 7;
    static constexpr int64_t DEBUG_DRAW_VOXEL_GI_EMISSION = 8;
    static constexpr int64_t DEBUG_DRAW_SHADOW_ATLAS = 9;
    static constexpr int64_t DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS = 10;
    static constexpr int64_t DEBUG_DRAW_SCENE_LUMINANCE = 11;
    static constexpr int64_t DEBUG_DRAW_SSAO = 12;
    static constexpr int64_t DEBUG_DRAW_SSIL = 13;
    static constexpr int64_t DEBUG_DRAW_PSSM_SPLITS = 14;
    static constexpr int64_t DEBUG_DRAW_DECAL_ATLAS = 15;
    static constexpr int64_t DEBUG_DRAW_SDFGI = 16;
    static constexpr int64_t DEBUG_DRAW_SDFGI_PROBES = 17;
    static constexpr int64_t DEBUG_DRAW_GI_BUFFER = 18;
    static constexpr int64_t DEBUG_DRAW_DISABLE_LOD = 19;
    static constexpr int64_t DEBUG_DRAW_CLUSTER_OMNI_LIGHTS = 20;
    static constexpr int64_t DEBUG_DRAW_CLUSTER_SPOT_LIGHTS = 21;
    static constexpr int64_t DEBUG_DRAW_CLUSTER_DECALS = 22;
    static constexpr int64_t DEBUG_DRAW_CLUSTER_REFLECTION_PROBES = 23;
    static constexpr int64_t DEBUG_DRAW_OCCLUDERS = 24;
    static constexpr int64_t DEBUG_DRAW_MOTION_VECTORS = 25;
    static constexpr int64_t DEBUG_DRAW_INTERNAL_BUFFER = 26;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST = 0;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR = 1;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 2;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 3;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_MAX = 4;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_DISABLED = 0;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_ENABLED = 1;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MIRROR = 2;
    static constexpr int64_t DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MAX = 3;
    static constexpr int64_t SDF_OVERSIZE_100_PERCENT = 0;
    static constexpr int64_t SDF_OVERSIZE_120_PERCENT = 1;
    static constexpr int64_t SDF_OVERSIZE_150_PERCENT = 2;
    static constexpr int64_t SDF_OVERSIZE_200_PERCENT = 3;
    static constexpr int64_t SDF_OVERSIZE_MAX = 4;
    static constexpr int64_t SDF_SCALE_100_PERCENT = 0;
    static constexpr int64_t SDF_SCALE_50_PERCENT = 1;
    static constexpr int64_t SDF_SCALE_25_PERCENT = 2;
    static constexpr int64_t SDF_SCALE_MAX = 3;
    static constexpr int64_t VRS_DISABLED = 0;
    static constexpr int64_t VRS_TEXTURE = 1;
    static constexpr int64_t VRS_XR = 2;
    static constexpr int64_t VRS_MAX = 3;
    static constexpr int64_t VRS_UPDATE_DISABLED = 0;
    static constexpr int64_t VRS_UPDATE_ONCE = 1;
    static constexpr int64_t VRS_UPDATE_ALWAYS = 2;
    static constexpr int64_t VRS_UPDATE_MAX = 3;
};
struct ViewportNavigationControl : public Control {
    using Control::Control;
};
struct ViewportRotationControl : public Control {
    using Control::Control;
};
struct ViewportTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(viewport_path, String);
    METHOD(void, set_viewport_path_in_scene);
    METHOD(String, get_viewport_path_in_scene);
};
struct VisibleOnScreenNotifier2D : public Node2D {
    using Node2D::Node2D;
    PROPERTY(rect, Rect2);
    METHOD(void, set_rect);
    METHOD(Rect2, get_rect);
    METHOD(bool, is_on_screen);
};
struct VisualInstance3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(layers, int64_t);
    PROPERTY(sorting_offset, double);
    PROPERTY(sorting_use_aabb_center, bool);
    METHOD(Variant, _get_aabb);
    METHOD(void, set_base);
    METHOD(::RID, get_base);
    METHOD(::RID, get_instance);
    METHOD(void, set_layer_mask);
    METHOD(int64_t, get_layer_mask);
    METHOD(void, set_layer_mask_value);
    METHOD(bool, get_layer_mask_value);
    METHOD(void, set_sorting_offset);
    METHOD(double, get_sorting_offset);
    METHOD(void, set_sorting_use_aabb_center);
    METHOD(bool, is_sorting_use_aabb_center);
    METHOD(Variant, get_aabb);
};
struct VisualShader : public Shader {
    using Shader::Shader;
    PROPERTY(graph_offset, Vector2);
    METHOD(void, set_mode);
    METHOD(Variant, add_node);
    METHOD(Object, get_node);
    METHOD(void, set_node_position);
    METHOD(Vector2, get_node_position);
    METHOD(PackedArray<int32_t>, get_node_list);
    METHOD(int64_t, get_valid_node_id);
    METHOD(Variant, remove_node);
    METHOD(Variant, replace_node);
    METHOD(bool, is_node_connection);
    METHOD(bool, can_connect_nodes);
    METHOD(int64_t, connect_nodes);
    METHOD(Variant, disconnect_nodes);
    METHOD(Variant, connect_nodes_forced);
    METHOD(Array, get_node_connections);
    METHOD(void, set_graph_offset);
    METHOD(Vector2, get_graph_offset);
    METHOD(Variant, attach_node_to_frame);
    METHOD(Variant, detach_node_from_frame);
    METHOD(Variant, add_varying);
    METHOD(Variant, remove_varying);
    METHOD(bool, has_varying);
    METHOD(Variant, _update_shader);
    static constexpr int64_t TYPE_VERTEX = 0;
    static constexpr int64_t TYPE_FRAGMENT = 1;
    static constexpr int64_t TYPE_LIGHT = 2;
    static constexpr int64_t TYPE_START = 3;
    static constexpr int64_t TYPE_PROCESS = 4;
    static constexpr int64_t TYPE_COLLIDE = 5;
    static constexpr int64_t TYPE_START_CUSTOM = 6;
    static constexpr int64_t TYPE_PROCESS_CUSTOM = 7;
    static constexpr int64_t TYPE_SKY = 8;
    static constexpr int64_t TYPE_FOG = 9;
    static constexpr int64_t TYPE_MAX = 10;
    static constexpr int64_t VARYING_MODE_VERTEX_TO_FRAG_LIGHT = 0;
    static constexpr int64_t VARYING_MODE_FRAG_TO_LIGHT = 1;
    static constexpr int64_t VARYING_MODE_MAX = 2;
    static constexpr int64_t VARYING_TYPE_FLOAT = 0;
    static constexpr int64_t VARYING_TYPE_INT = 1;
    static constexpr int64_t VARYING_TYPE_UINT = 2;
    static constexpr int64_t VARYING_TYPE_VECTOR_2D = 3;
    static constexpr int64_t VARYING_TYPE_VECTOR_3D = 4;
    static constexpr int64_t VARYING_TYPE_VECTOR_4D = 5;
    static constexpr int64_t VARYING_TYPE_BOOLEAN = 6;
    static constexpr int64_t VARYING_TYPE_TRANSFORM = 7;
    static constexpr int64_t VARYING_TYPE_MAX = 8;
    static constexpr int64_t NODE_ID_INVALID = -1;
    static constexpr int64_t NODE_ID_OUTPUT = 0;
};
struct VisualShaderNode : public Resource {
    using Resource::Resource;
    PROPERTY(output_port_for_preview, int64_t);
    PROPERTY(default_input_values, Array);
    PROPERTY(expanded_output_ports, Array);
    PROPERTY(linked_parent_graph_frame, int64_t);
    METHOD(int64_t, get_default_input_port);
    METHOD(void, set_output_port_for_preview);
    METHOD(int64_t, get_output_port_for_preview);
    METHOD(Variant, _set_output_port_expanded);
    METHOD(bool, _is_output_port_expanded);
    METHOD(Variant, _set_output_ports_expanded);
    METHOD(Array, _get_output_ports_expanded);
    METHOD(void, set_input_port_default_value);
    METHOD(Variant, get_input_port_default_value);
    METHOD(Variant, remove_input_port_default_value);
    METHOD(Variant, clear_default_input_values);
    METHOD(void, set_default_input_values);
    METHOD(Array, get_default_input_values);
    METHOD(void, set_frame);
    METHOD(int64_t, get_frame);
    static constexpr int64_t PORT_TYPE_SCALAR = 0;
    static constexpr int64_t PORT_TYPE_SCALAR_INT = 1;
    static constexpr int64_t PORT_TYPE_SCALAR_UINT = 2;
    static constexpr int64_t PORT_TYPE_VECTOR_2D = 3;
    static constexpr int64_t PORT_TYPE_VECTOR_3D = 4;
    static constexpr int64_t PORT_TYPE_VECTOR_4D = 5;
    static constexpr int64_t PORT_TYPE_BOOLEAN = 6;
    static constexpr int64_t PORT_TYPE_TRANSFORM = 7;
    static constexpr int64_t PORT_TYPE_SAMPLER = 8;
    static constexpr int64_t PORT_TYPE_MAX = 9;
};
struct VisualShaderNodeBillboard : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(billboard_type, int64_t);
    PROPERTY(keep_scale, bool);
    METHOD(void, set_billboard_type);
    METHOD(int64_t, get_billboard_type);
    METHOD(void, set_keep_scale_enabled);
    METHOD(bool, is_keep_scale_enabled);
    static constexpr int64_t BILLBOARD_TYPE_DISABLED = 0;
    static constexpr int64_t BILLBOARD_TYPE_ENABLED = 1;
    static constexpr int64_t BILLBOARD_TYPE_FIXED_Y = 2;
    static constexpr int64_t BILLBOARD_TYPE_PARTICLES = 3;
    static constexpr int64_t BILLBOARD_TYPE_MAX = 4;
};
struct VisualShaderNodeClamp : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_FLOAT = 0;
    static constexpr int64_t OP_TYPE_INT = 1;
    static constexpr int64_t OP_TYPE_UINT = 2;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 3;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 4;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 5;
    static constexpr int64_t OP_TYPE_MAX = 6;
};
struct VisualShaderNodeColorFunc : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_GRAYSCALE = 0;
    static constexpr int64_t FUNC_HSV2RGB = 1;
    static constexpr int64_t FUNC_RGB2HSV = 2;
    static constexpr int64_t FUNC_SEPIA = 3;
    static constexpr int64_t FUNC_MAX = 4;
};
struct VisualShaderNodeColorOp : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(Operator, int64_t);
    METHOD(void, set_operator);
    METHOD(int64_t, get_operator);
    static constexpr int64_t OP_SCREEN = 0;
    static constexpr int64_t OP_DIFFERENCE = 1;
    static constexpr int64_t OP_DARKEN = 2;
    static constexpr int64_t OP_LIGHTEN = 3;
    static constexpr int64_t OP_OVERLAY = 4;
    static constexpr int64_t OP_DODGE = 5;
    static constexpr int64_t OP_BURN = 6;
    static constexpr int64_t OP_SOFT_LIGHT = 7;
    static constexpr int64_t OP_HARD_LIGHT = 8;
    static constexpr int64_t OP_MAX = 9;
};
struct VisualShaderNodeCompare : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(type, int64_t);
    PROPERTY(function, int64_t);
    PROPERTY(condition, int64_t);
    METHOD(void, set_comparison_type);
    METHOD(int64_t, get_comparison_type);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    METHOD(void, set_condition);
    METHOD(int64_t, get_condition);
    static constexpr int64_t CTYPE_SCALAR = 0;
    static constexpr int64_t CTYPE_SCALAR_INT = 1;
    static constexpr int64_t CTYPE_SCALAR_UINT = 2;
    static constexpr int64_t CTYPE_VECTOR_2D = 3;
    static constexpr int64_t CTYPE_VECTOR_3D = 4;
    static constexpr int64_t CTYPE_VECTOR_4D = 5;
    static constexpr int64_t CTYPE_BOOLEAN = 6;
    static constexpr int64_t CTYPE_TRANSFORM = 7;
    static constexpr int64_t CTYPE_MAX = 8;
    static constexpr int64_t FUNC_EQUAL = 0;
    static constexpr int64_t FUNC_NOT_EQUAL = 1;
    static constexpr int64_t FUNC_GREATER_THAN = 2;
    static constexpr int64_t FUNC_GREATER_THAN_EQUAL = 3;
    static constexpr int64_t FUNC_LESS_THAN = 4;
    static constexpr int64_t FUNC_LESS_THAN_EQUAL = 5;
    static constexpr int64_t FUNC_MAX = 6;
    static constexpr int64_t COND_ALL = 0;
    static constexpr int64_t COND_ANY = 1;
    static constexpr int64_t COND_MAX = 2;
};
struct VisualShaderNodeConstant : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeCubemap : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(source, int64_t);
    PROPERTY(cube_map, Object);
    PROPERTY(texture_type, int64_t);
    METHOD(void, set_source);
    METHOD(int64_t, get_source);
    METHOD(void, set_cube_map);
    METHOD(Object, get_cube_map);
    METHOD(void, set_texture_type);
    METHOD(int64_t, get_texture_type);
    static constexpr int64_t SOURCE_TEXTURE = 0;
    static constexpr int64_t SOURCE_PORT = 1;
    static constexpr int64_t SOURCE_MAX = 2;
    static constexpr int64_t TYPE_DATA = 0;
    static constexpr int64_t TYPE_COLOR = 1;
    static constexpr int64_t TYPE_NORMAL_MAP = 2;
    static constexpr int64_t TYPE_MAX = 3;
};
struct VisualShaderNodeCustom : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(initialized, bool);
    PROPERTY(properties, String);
    METHOD(String, _get_name);
    METHOD(String, _get_description);
    METHOD(String, _get_category);
    METHOD(int64_t, _get_return_icon_type);
    METHOD(int64_t, _get_input_port_count);
    METHOD(int64_t, _get_input_port_type);
    METHOD(String, _get_input_port_name);
    METHOD(Variant, _get_input_port_default_value);
    METHOD(int64_t, _get_default_input_port);
    METHOD(int64_t, _get_output_port_count);
    METHOD(int64_t, _get_output_port_type);
    METHOD(String, _get_output_port_name);
    METHOD(int64_t, _get_property_count);
    METHOD(String, _get_property_name);
    METHOD(int64_t, _get_property_default_index);
    METHOD(PackedArray<std::string>, _get_property_options);
    METHOD(String, _get_code);
    METHOD(String, _get_func_code);
    METHOD(String, _get_global_code);
    METHOD(bool, _is_highend);
    METHOD(bool, _is_available);
    METHOD(Variant, _set_initialized);
    METHOD(bool, _is_initialized);
    METHOD(Variant, _set_input_port_default_value);
    METHOD(Variant, _set_option_index);
    METHOD(Variant, _set_properties);
    METHOD(String, _get_properties);
    METHOD(int64_t, get_option_index);
};
struct VisualShaderNodeDerivativeFunc : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    PROPERTY(function, int64_t);
    PROPERTY(precision, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    METHOD(void, set_precision);
    METHOD(int64_t, get_precision);
    static constexpr int64_t OP_TYPE_SCALAR = 0;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 1;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 2;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 3;
    static constexpr int64_t OP_TYPE_MAX = 4;
    static constexpr int64_t FUNC_SUM = 0;
    static constexpr int64_t FUNC_X = 1;
    static constexpr int64_t FUNC_Y = 2;
    static constexpr int64_t FUNC_MAX = 3;
    static constexpr int64_t PRECISION_NONE = 0;
    static constexpr int64_t PRECISION_COARSE = 1;
    static constexpr int64_t PRECISION_FINE = 2;
    static constexpr int64_t PRECISION_MAX = 3;
};
struct VisualShaderNodeDeterminant : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeDistanceFade : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeDotProduct : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeFloatConstant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, double);
    METHOD(void, set_constant);
    METHOD(double, get_constant);
};
struct VisualShaderNodeFloatFunc : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_SIN = 0;
    static constexpr int64_t FUNC_COS = 1;
    static constexpr int64_t FUNC_TAN = 2;
    static constexpr int64_t FUNC_ASIN = 3;
    static constexpr int64_t FUNC_ACOS = 4;
    static constexpr int64_t FUNC_ATAN = 5;
    static constexpr int64_t FUNC_SINH = 6;
    static constexpr int64_t FUNC_COSH = 7;
    static constexpr int64_t FUNC_TANH = 8;
    static constexpr int64_t FUNC_LOG = 9;
    static constexpr int64_t FUNC_EXP = 10;
    static constexpr int64_t FUNC_SQRT = 11;
    static constexpr int64_t FUNC_ABS = 12;
    static constexpr int64_t FUNC_SIGN = 13;
    static constexpr int64_t FUNC_FLOOR = 14;
    static constexpr int64_t FUNC_ROUND = 15;
    static constexpr int64_t FUNC_CEIL = 16;
    static constexpr int64_t FUNC_FRACT = 17;
    static constexpr int64_t FUNC_SATURATE = 18;
    static constexpr int64_t FUNC_NEGATE = 19;
    static constexpr int64_t FUNC_ACOSH = 20;
    static constexpr int64_t FUNC_ASINH = 21;
    static constexpr int64_t FUNC_ATANH = 22;
    static constexpr int64_t FUNC_DEGREES = 23;
    static constexpr int64_t FUNC_EXP2 = 24;
    static constexpr int64_t FUNC_INVERSE_SQRT = 25;
    static constexpr int64_t FUNC_LOG2 = 26;
    static constexpr int64_t FUNC_RADIANS = 27;
    static constexpr int64_t FUNC_RECIPROCAL = 28;
    static constexpr int64_t FUNC_ROUNDEVEN = 29;
    static constexpr int64_t FUNC_TRUNC = 30;
    static constexpr int64_t FUNC_ONEMINUS = 31;
    static constexpr int64_t FUNC_MAX = 32;
};
struct VisualShaderNodeFloatOp : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(Operator, int64_t);
    METHOD(void, set_operator);
    METHOD(int64_t, get_operator);
    static constexpr int64_t OP_ADD = 0;
    static constexpr int64_t OP_SUB = 1;
    static constexpr int64_t OP_MUL = 2;
    static constexpr int64_t OP_DIV = 3;
    static constexpr int64_t OP_MOD = 4;
    static constexpr int64_t OP_POW = 5;
    static constexpr int64_t OP_MAX = 6;
    static constexpr int64_t OP_MIN = 7;
    static constexpr int64_t OP_ATAN2 = 8;
    static constexpr int64_t OP_STEP = 9;
    static constexpr int64_t OP_ENUM_SIZE = 10;
};
struct VisualShaderNodeFresnel : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeIf : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeInput : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(input_name, String);
    METHOD(void, set_input_name);
    METHOD(String, get_input_name);
    METHOD(String, get_input_real_name);
};
struct VisualShaderNodeIntConstant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, int64_t);
    METHOD(void, set_constant);
    METHOD(int64_t, get_constant);
};
struct VisualShaderNodeIntFunc : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_ABS = 0;
    static constexpr int64_t FUNC_NEGATE = 1;
    static constexpr int64_t FUNC_SIGN = 2;
    static constexpr int64_t FUNC_BITWISE_NOT = 3;
    static constexpr int64_t FUNC_MAX = 4;
};
struct VisualShaderNodeIntOp : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(Operator, int64_t);
    METHOD(void, set_operator);
    METHOD(int64_t, get_operator);
    static constexpr int64_t OP_ADD = 0;
    static constexpr int64_t OP_SUB = 1;
    static constexpr int64_t OP_MUL = 2;
    static constexpr int64_t OP_DIV = 3;
    static constexpr int64_t OP_MOD = 4;
    static constexpr int64_t OP_MAX = 5;
    static constexpr int64_t OP_MIN = 6;
    static constexpr int64_t OP_BITWISE_AND = 7;
    static constexpr int64_t OP_BITWISE_OR = 8;
    static constexpr int64_t OP_BITWISE_XOR = 9;
    static constexpr int64_t OP_BITWISE_LEFT_SHIFT = 10;
    static constexpr int64_t OP_BITWISE_RIGHT_SHIFT = 11;
    static constexpr int64_t OP_ENUM_SIZE = 12;
};
struct VisualShaderNodeIs : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_IS_INF = 0;
    static constexpr int64_t FUNC_IS_NAN = 1;
    static constexpr int64_t FUNC_MAX = 2;
};
struct VisualShaderNodeLinearSceneDepth : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeMix : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_SCALAR = 0;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 1;
    static constexpr int64_t OP_TYPE_VECTOR_2D_SCALAR = 2;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 3;
    static constexpr int64_t OP_TYPE_VECTOR_3D_SCALAR = 4;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 5;
    static constexpr int64_t OP_TYPE_VECTOR_4D_SCALAR = 6;
    static constexpr int64_t OP_TYPE_MAX = 7;
};
struct VisualShaderNodeMultiplyAdd : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_SCALAR = 0;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 1;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 2;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 3;
    static constexpr int64_t OP_TYPE_MAX = 4;
};
struct VisualShaderNodeOuterProduct : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeOutput : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeParameter : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(parameter_name, String);
    PROPERTY(qualifier, int64_t);
    METHOD(void, set_parameter_name);
    METHOD(String, get_parameter_name);
    METHOD(void, set_qualifier);
    METHOD(int64_t, get_qualifier);
    static constexpr int64_t QUAL_NONE = 0;
    static constexpr int64_t QUAL_GLOBAL = 1;
    static constexpr int64_t QUAL_INSTANCE = 2;
    static constexpr int64_t QUAL_MAX = 3;
};
struct VisualShaderNodeParameterRef : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(parameter_name, String);
    PROPERTY(param_type, int64_t);
    METHOD(void, set_parameter_name);
    METHOD(String, get_parameter_name);
    METHOD(Variant, _set_parameter_type);
    METHOD(int64_t, _get_parameter_type);
};
struct VisualShaderNodeParticleAccelerator : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(mode, int64_t);
    METHOD(void, set_mode);
    METHOD(int64_t, get_mode);
    static constexpr int64_t MODE_LINEAR = 0;
    static constexpr int64_t MODE_RADIAL = 1;
    static constexpr int64_t MODE_TANGENTIAL = 2;
    static constexpr int64_t MODE_MAX = 3;
};
struct VisualShaderNodeParticleConeVelocity : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeParticleEmit : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(flags, int64_t);
    METHOD(void, set_flags);
    METHOD(int64_t, get_flags);
    static constexpr int64_t EMIT_FLAG_POSITION = 1;
    static constexpr int64_t EMIT_FLAG_ROT_SCALE = 2;
    static constexpr int64_t EMIT_FLAG_VELOCITY = 4;
    static constexpr int64_t EMIT_FLAG_COLOR = 8;
    static constexpr int64_t EMIT_FLAG_CUSTOM = 16;
};
struct VisualShaderNodeParticleEmitter : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(mode_2d, bool);
    METHOD(void, set_mode_2d);
    METHOD(bool, is_mode_2d);
};
struct VisualShaderNodeParticleMeshEmitter : public VisualShaderNodeParticleEmitter {
    using VisualShaderNodeParticleEmitter::VisualShaderNodeParticleEmitter;
    PROPERTY(mesh, Object);
    PROPERTY(use_all_surfaces, bool);
    PROPERTY(surface_index, int64_t);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(void, set_use_all_surfaces);
    METHOD(bool, is_use_all_surfaces);
    METHOD(void, set_surface_index);
    METHOD(int64_t, get_surface_index);
};
struct VisualShaderNodeParticleMultiplyByAxisAngle : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(degrees_mode, bool);
    METHOD(void, set_degrees_mode);
    METHOD(bool, is_degrees_mode);
};
struct VisualShaderNodeParticleOutput : public VisualShaderNodeOutput {
    using VisualShaderNodeOutput::VisualShaderNodeOutput;
};
struct VisualShaderNodeParticleRandomness : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_SCALAR = 0;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 1;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 2;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 3;
    static constexpr int64_t OP_TYPE_MAX = 4;
};
struct VisualShaderNodeParticleRingEmitter : public VisualShaderNodeParticleEmitter {
    using VisualShaderNodeParticleEmitter::VisualShaderNodeParticleEmitter;
};
struct VisualShaderNodeParticleSphereEmitter : public VisualShaderNodeParticleEmitter {
    using VisualShaderNodeParticleEmitter::VisualShaderNodeParticleEmitter;
};
struct VisualShaderNodeProximityFade : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeRandomRange : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeRemap : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeReroute : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(port_type, int64_t);
    METHOD(Variant, _set_port_type);
    METHOD(int64_t, get_port_type);
};
struct VisualShaderNodeResizableBase : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(size, Vector2);
    METHOD(void, set_size);
    METHOD(Vector2, get_size);
};
struct VisualShaderNodeRotationByAxis : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeSDFRaymarch : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeSDFToScreenUV : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeSample3D : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(source, int64_t);
    METHOD(void, set_source);
    METHOD(int64_t, get_source);
    static constexpr int64_t SOURCE_TEXTURE = 0;
    static constexpr int64_t SOURCE_PORT = 1;
    static constexpr int64_t SOURCE_MAX = 2;
};
struct VisualShaderNodeScreenNormalWorldSpace : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeScreenUVToSDF : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeSmoothStep : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_SCALAR = 0;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 1;
    static constexpr int64_t OP_TYPE_VECTOR_2D_SCALAR = 2;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 3;
    static constexpr int64_t OP_TYPE_VECTOR_3D_SCALAR = 4;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 5;
    static constexpr int64_t OP_TYPE_VECTOR_4D_SCALAR = 6;
    static constexpr int64_t OP_TYPE_MAX = 7;
};
struct VisualShaderNodeStep : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_SCALAR = 0;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 1;
    static constexpr int64_t OP_TYPE_VECTOR_2D_SCALAR = 2;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 3;
    static constexpr int64_t OP_TYPE_VECTOR_3D_SCALAR = 4;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 5;
    static constexpr int64_t OP_TYPE_VECTOR_4D_SCALAR = 6;
    static constexpr int64_t OP_TYPE_MAX = 7;
};
struct VisualShaderNodeSwitch : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_FLOAT = 0;
    static constexpr int64_t OP_TYPE_INT = 1;
    static constexpr int64_t OP_TYPE_UINT = 2;
    static constexpr int64_t OP_TYPE_VECTOR_2D = 3;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 4;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 5;
    static constexpr int64_t OP_TYPE_BOOLEAN = 6;
    static constexpr int64_t OP_TYPE_TRANSFORM = 7;
    static constexpr int64_t OP_TYPE_MAX = 8;
};
struct VisualShaderNodeTexture : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(source, int64_t);
    PROPERTY(texture, Object);
    PROPERTY(texture_type, int64_t);
    METHOD(void, set_source);
    METHOD(int64_t, get_source);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_texture_type);
    METHOD(int64_t, get_texture_type);
    static constexpr int64_t SOURCE_TEXTURE = 0;
    static constexpr int64_t SOURCE_SCREEN = 1;
    static constexpr int64_t SOURCE_2D_TEXTURE = 2;
    static constexpr int64_t SOURCE_2D_NORMAL = 3;
    static constexpr int64_t SOURCE_DEPTH = 4;
    static constexpr int64_t SOURCE_PORT = 5;
    static constexpr int64_t SOURCE_3D_NORMAL = 6;
    static constexpr int64_t SOURCE_ROUGHNESS = 7;
    static constexpr int64_t SOURCE_MAX = 8;
    static constexpr int64_t TYPE_DATA = 0;
    static constexpr int64_t TYPE_COLOR = 1;
    static constexpr int64_t TYPE_NORMAL_MAP = 2;
    static constexpr int64_t TYPE_MAX = 3;
};
struct VisualShaderNodeTexture2DArray : public VisualShaderNodeSample3D {
    using VisualShaderNodeSample3D::VisualShaderNodeSample3D;
    PROPERTY(texture_array, Object);
    METHOD(void, set_texture_array);
    METHOD(Object, get_texture_array);
};
struct VisualShaderNodeTexture3D : public VisualShaderNodeSample3D {
    using VisualShaderNodeSample3D::VisualShaderNodeSample3D;
    PROPERTY(texture, Object);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
};
struct VisualShaderNodeTextureParameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(texture_type, int64_t);
    PROPERTY(color_default, int64_t);
    PROPERTY(texture_filter, int64_t);
    PROPERTY(texture_repeat, int64_t);
    PROPERTY(texture_source, int64_t);
    METHOD(void, set_texture_type);
    METHOD(int64_t, get_texture_type);
    METHOD(void, set_color_default);
    METHOD(int64_t, get_color_default);
    METHOD(void, set_texture_filter);
    METHOD(int64_t, get_texture_filter);
    METHOD(void, set_texture_repeat);
    METHOD(int64_t, get_texture_repeat);
    METHOD(void, set_texture_source);
    METHOD(int64_t, get_texture_source);
    static constexpr int64_t TYPE_DATA = 0;
    static constexpr int64_t TYPE_COLOR = 1;
    static constexpr int64_t TYPE_NORMAL_MAP = 2;
    static constexpr int64_t TYPE_ANISOTROPY = 3;
    static constexpr int64_t TYPE_MAX = 4;
    static constexpr int64_t COLOR_DEFAULT_WHITE = 0;
    static constexpr int64_t COLOR_DEFAULT_BLACK = 1;
    static constexpr int64_t COLOR_DEFAULT_TRANSPARENT = 2;
    static constexpr int64_t COLOR_DEFAULT_MAX = 3;
    static constexpr int64_t FILTER_DEFAULT = 0;
    static constexpr int64_t FILTER_NEAREST = 1;
    static constexpr int64_t FILTER_LINEAR = 2;
    static constexpr int64_t FILTER_NEAREST_MIPMAP = 3;
    static constexpr int64_t FILTER_LINEAR_MIPMAP = 4;
    static constexpr int64_t FILTER_NEAREST_MIPMAP_ANISOTROPIC = 5;
    static constexpr int64_t FILTER_LINEAR_MIPMAP_ANISOTROPIC = 6;
    static constexpr int64_t FILTER_MAX = 7;
    static constexpr int64_t REPEAT_DEFAULT = 0;
    static constexpr int64_t REPEAT_ENABLED = 1;
    static constexpr int64_t REPEAT_DISABLED = 2;
    static constexpr int64_t REPEAT_MAX = 3;
    static constexpr int64_t SOURCE_NONE = 0;
    static constexpr int64_t SOURCE_SCREEN = 1;
    static constexpr int64_t SOURCE_DEPTH = 2;
    static constexpr int64_t SOURCE_NORMAL_ROUGHNESS = 3;
    static constexpr int64_t SOURCE_MAX = 4;
};
struct VisualShaderNodeTextureParameterTriplanar : public VisualShaderNodeTextureParameter {
    using VisualShaderNodeTextureParameter::VisualShaderNodeTextureParameter;
};
struct VisualShaderNodeTextureSDF : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeTextureSDFNormal : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeTransformCompose : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeTransformConstant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, Transform3D);
    METHOD(void, set_constant);
    METHOD(Transform3D, get_constant);
};
struct VisualShaderNodeTransformDecompose : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeTransformFunc : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_INVERSE = 0;
    static constexpr int64_t FUNC_TRANSPOSE = 1;
    static constexpr int64_t FUNC_MAX = 2;
};
struct VisualShaderNodeTransformOp : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(Operator, int64_t);
    METHOD(void, set_operator);
    METHOD(int64_t, get_operator);
    static constexpr int64_t OP_AxB = 0;
    static constexpr int64_t OP_BxA = 1;
    static constexpr int64_t OP_AxB_COMP = 2;
    static constexpr int64_t OP_BxA_COMP = 3;
    static constexpr int64_t OP_ADD = 4;
    static constexpr int64_t OP_A_MINUS_B = 5;
    static constexpr int64_t OP_B_MINUS_A = 6;
    static constexpr int64_t OP_A_DIV_B = 7;
    static constexpr int64_t OP_B_DIV_A = 8;
    static constexpr int64_t OP_MAX = 9;
};
struct VisualShaderNodeTransformParameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, Transform3D);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(Transform3D, get_default_value);
};
struct VisualShaderNodeTransformVecMult : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(Operator, int64_t);
    METHOD(void, set_operator);
    METHOD(int64_t, get_operator);
    static constexpr int64_t OP_AxB = 0;
    static constexpr int64_t OP_BxA = 1;
    static constexpr int64_t OP_3x3_AxB = 2;
    static constexpr int64_t OP_3x3_BxA = 3;
    static constexpr int64_t OP_MAX = 4;
};
struct VisualShaderNodeUIntConstant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, int64_t);
    METHOD(void, set_constant);
    METHOD(int64_t, get_constant);
};
struct VisualShaderNodeUIntFunc : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_NEGATE = 0;
    static constexpr int64_t FUNC_BITWISE_NOT = 1;
    static constexpr int64_t FUNC_MAX = 2;
};
struct VisualShaderNodeUIntOp : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(Operator, int64_t);
    METHOD(void, set_operator);
    METHOD(int64_t, get_operator);
    static constexpr int64_t OP_ADD = 0;
    static constexpr int64_t OP_SUB = 1;
    static constexpr int64_t OP_MUL = 2;
    static constexpr int64_t OP_DIV = 3;
    static constexpr int64_t OP_MOD = 4;
    static constexpr int64_t OP_MAX = 5;
    static constexpr int64_t OP_MIN = 6;
    static constexpr int64_t OP_BITWISE_AND = 7;
    static constexpr int64_t OP_BITWISE_OR = 8;
    static constexpr int64_t OP_BITWISE_XOR = 9;
    static constexpr int64_t OP_BITWISE_LEFT_SHIFT = 10;
    static constexpr int64_t OP_BITWISE_RIGHT_SHIFT = 11;
    static constexpr int64_t OP_ENUM_SIZE = 12;
};
struct VisualShaderNodeUIntParameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, int64_t);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(int64_t, get_default_value);
};
struct VisualShaderNodeUVFunc : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_PANNING = 0;
    static constexpr int64_t FUNC_SCALING = 1;
    static constexpr int64_t FUNC_MAX = 2;
};
struct VisualShaderNodeUVPolarCoord : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VisualShaderNodeVarying : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(varying_name, String);
    PROPERTY(varying_type, int64_t);
    METHOD(void, set_varying_name);
    METHOD(String, get_varying_name);
    METHOD(void, set_varying_type);
    METHOD(int64_t, get_varying_type);
};
struct VisualShaderNodeVaryingGetter : public VisualShaderNodeVarying {
    using VisualShaderNodeVarying::VisualShaderNodeVarying;
};
struct VisualShaderNodeVaryingSetter : public VisualShaderNodeVarying {
    using VisualShaderNodeVarying::VisualShaderNodeVarying;
};
struct VisualShaderNodeVec2Constant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, Vector2);
    METHOD(void, set_constant);
    METHOD(Vector2, get_constant);
};
struct VisualShaderNodeVec2Parameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, Vector2);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(Vector2, get_default_value);
};
struct VisualShaderNodeVec3Constant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, Vector3);
    METHOD(void, set_constant);
    METHOD(Vector3, get_constant);
};
struct VisualShaderNodeVec3Parameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, Vector3);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(Vector3, get_default_value);
};
struct VisualShaderNodeVec4Constant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, Quaternion);
    METHOD(void, set_constant);
    METHOD(Quaternion, get_constant);
};
struct VisualShaderNodeVec4Parameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, Vector4);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(Vector4, get_default_value);
};
struct VisualShaderNodeVectorBase : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
    PROPERTY(op_type, int64_t);
    METHOD(void, set_op_type);
    METHOD(int64_t, get_op_type);
    static constexpr int64_t OP_TYPE_VECTOR_2D = 0;
    static constexpr int64_t OP_TYPE_VECTOR_3D = 1;
    static constexpr int64_t OP_TYPE_VECTOR_4D = 2;
    static constexpr int64_t OP_TYPE_MAX = 3;
};
struct VisualShaderNodeVectorCompose : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
};
struct VisualShaderNodeVectorDecompose : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
};
struct VisualShaderNodeVectorDistance : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
};
struct VisualShaderNodeVectorFunc : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
    PROPERTY(function, int64_t);
    METHOD(void, set_function);
    METHOD(int64_t, get_function);
    static constexpr int64_t FUNC_NORMALIZE = 0;
    static constexpr int64_t FUNC_SATURATE = 1;
    static constexpr int64_t FUNC_NEGATE = 2;
    static constexpr int64_t FUNC_RECIPROCAL = 3;
    static constexpr int64_t FUNC_ABS = 4;
    static constexpr int64_t FUNC_ACOS = 5;
    static constexpr int64_t FUNC_ACOSH = 6;
    static constexpr int64_t FUNC_ASIN = 7;
    static constexpr int64_t FUNC_ASINH = 8;
    static constexpr int64_t FUNC_ATAN = 9;
    static constexpr int64_t FUNC_ATANH = 10;
    static constexpr int64_t FUNC_CEIL = 11;
    static constexpr int64_t FUNC_COS = 12;
    static constexpr int64_t FUNC_COSH = 13;
    static constexpr int64_t FUNC_DEGREES = 14;
    static constexpr int64_t FUNC_EXP = 15;
    static constexpr int64_t FUNC_EXP2 = 16;
    static constexpr int64_t FUNC_FLOOR = 17;
    static constexpr int64_t FUNC_FRACT = 18;
    static constexpr int64_t FUNC_INVERSE_SQRT = 19;
    static constexpr int64_t FUNC_LOG = 20;
    static constexpr int64_t FUNC_LOG2 = 21;
    static constexpr int64_t FUNC_RADIANS = 22;
    static constexpr int64_t FUNC_ROUND = 23;
    static constexpr int64_t FUNC_ROUNDEVEN = 24;
    static constexpr int64_t FUNC_SIGN = 25;
    static constexpr int64_t FUNC_SIN = 26;
    static constexpr int64_t FUNC_SINH = 27;
    static constexpr int64_t FUNC_SQRT = 28;
    static constexpr int64_t FUNC_TAN = 29;
    static constexpr int64_t FUNC_TANH = 30;
    static constexpr int64_t FUNC_TRUNC = 31;
    static constexpr int64_t FUNC_ONEMINUS = 32;
    static constexpr int64_t FUNC_MAX = 33;
};
struct VisualShaderNodeVectorLen : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
};
struct VisualShaderNodeVectorOp : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
    PROPERTY(Operator, int64_t);
    METHOD(void, set_operator);
    METHOD(int64_t, get_operator);
    static constexpr int64_t OP_ADD = 0;
    static constexpr int64_t OP_SUB = 1;
    static constexpr int64_t OP_MUL = 2;
    static constexpr int64_t OP_DIV = 3;
    static constexpr int64_t OP_MOD = 4;
    static constexpr int64_t OP_POW = 5;
    static constexpr int64_t OP_MAX = 6;
    static constexpr int64_t OP_MIN = 7;
    static constexpr int64_t OP_CROSS = 8;
    static constexpr int64_t OP_ATAN2 = 9;
    static constexpr int64_t OP_REFLECT = 10;
    static constexpr int64_t OP_STEP = 11;
    static constexpr int64_t OP_ENUM_SIZE = 12;
};
struct VisualShaderNodeVectorRefract : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
};
struct VisualShaderNodeWorldPositionFromDepth : public VisualShaderNode {
    using VisualShaderNode::VisualShaderNode;
};
struct VoxelGI : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(subdiv, int64_t);
    PROPERTY(size, Vector3);
    PROPERTY(camera_attributes, Object);
    PROPERTY(data, Object);
    METHOD(void, set_probe_data);
    METHOD(Object, get_probe_data);
    METHOD(void, set_subdiv);
    METHOD(int64_t, get_subdiv);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_camera_attributes);
    METHOD(Object, get_camera_attributes);
    METHOD(Variant, bake);
    METHOD(Variant, debug_bake);
    static constexpr int64_t SUBDIV_64 = 0;
    static constexpr int64_t SUBDIV_128 = 1;
    static constexpr int64_t SUBDIV_256 = 2;
    static constexpr int64_t SUBDIV_512 = 3;
    static constexpr int64_t SUBDIV_MAX = 4;
};
struct VoxelGIData : public Resource {
    using Resource::Resource;
    PROPERTY(_data, Dictionary);
    PROPERTY(dynamic_range, double);
    PROPERTY(energy, double);
    PROPERTY(bias, double);
    PROPERTY(normal_bias, double);
    PROPERTY(propagation, double);
    PROPERTY(use_two_bounces, bool);
    PROPERTY(interior, bool);
    METHOD(Variant, allocate);
    METHOD(Variant, get_bounds);
    METHOD(Vector3, get_octree_size);
    METHOD(Transform3D, get_to_cell_xform);
    METHOD(PackedArray<uint8_t>, get_octree_cells);
    METHOD(PackedArray<uint8_t>, get_data_cells);
    METHOD(PackedArray<int32_t>, get_level_counts);
    METHOD(void, set_dynamic_range);
    METHOD(double, get_dynamic_range);
    METHOD(void, set_energy);
    METHOD(double, get_energy);
    METHOD(void, set_bias);
    METHOD(double, get_bias);
    METHOD(void, set_normal_bias);
    METHOD(double, get_normal_bias);
    METHOD(void, set_propagation);
    METHOD(double, get_propagation);
    METHOD(void, set_interior);
    METHOD(bool, is_interior);
    METHOD(void, set_use_two_bounces);
    METHOD(bool, is_using_two_bounces);
    METHOD(Variant, _set_data);
    METHOD(Dictionary, _get_data);
};
struct WeakRef : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, get_ref);
};
struct Window : public Viewport {
    using Viewport::Viewport;
    PROPERTY(mode, int64_t);
    PROPERTY(title, String);
    PROPERTY(initial_position, int64_t);
    PROPERTY(position, Vector2i);
    PROPERTY(size, Vector2i);
    PROPERTY(current_screen, int64_t);
    PROPERTY(mouse_passthrough_polygon, PackedArray<Vector2>);
    PROPERTY(visible, bool);
    PROPERTY(wrap_controls, bool);
    PROPERTY(transient, bool);
    PROPERTY(transient_to_focused, bool);
    PROPERTY(exclusive, bool);
    PROPERTY(unresizable, bool);
    PROPERTY(borderless, bool);
    PROPERTY(always_on_top, bool);
    PROPERTY(transparent, bool);
    PROPERTY(unfocusable, bool);
    PROPERTY(popup_window, bool);
    PROPERTY(extend_to_title, bool);
    PROPERTY(mouse_passthrough, bool);
    PROPERTY(force_native, bool);
    PROPERTY(min_size, Vector2i);
    PROPERTY(max_size, Vector2i);
    PROPERTY(keep_title_visible, bool);
    PROPERTY(content_scale_size, Vector2i);
    PROPERTY(content_scale_mode, int64_t);
    PROPERTY(content_scale_aspect, int64_t);
    PROPERTY(content_scale_stretch, int64_t);
    PROPERTY(content_scale_factor, double);
    PROPERTY(auto_translate, bool);
    PROPERTY(theme, Object);
    PROPERTY(theme_type_variation, String);
    METHOD(Vector2, _get_contents_minimum_size);
    METHOD(void, set_title);
    METHOD(String, get_title);
    METHOD(int64_t, get_window_id);
    METHOD(void, set_initial_position);
    METHOD(int64_t, get_initial_position);
    METHOD(void, set_current_screen);
    METHOD(int64_t, get_current_screen);
    METHOD(void, set_position);
    METHOD(Vector2i, get_position);
    METHOD(Variant, move_to_center);
    METHOD(void, set_size);
    METHOD(Vector2i, get_size);
    METHOD(Variant, reset_size);
    METHOD(Vector2i, get_position_with_decorations);
    METHOD(Vector2i, get_size_with_decorations);
    METHOD(void, set_max_size);
    METHOD(Vector2i, get_max_size);
    METHOD(void, set_min_size);
    METHOD(Vector2i, get_min_size);
    METHOD(void, set_mode);
    METHOD(int64_t, get_mode);
    METHOD(void, set_flag);
    METHOD(bool, get_flag);
    METHOD(bool, is_maximize_allowed);
    METHOD(Variant, request_attention);
    METHOD(Variant, move_to_foreground);
    METHOD(void, set_visible);
    METHOD(bool, is_visible);
    METHOD(Variant, hide);
    METHOD(Variant, show);
    METHOD(void, set_transient);
    METHOD(bool, is_transient);
    METHOD(void, set_transient_to_focused);
    METHOD(bool, is_transient_to_focused);
    METHOD(void, set_exclusive);
    METHOD(bool, is_exclusive);
    METHOD(void, set_unparent_when_invisible);
    METHOD(bool, can_draw);
    METHOD(bool, has_focus);
    METHOD(Variant, grab_focus);
    METHOD(void, set_ime_active);
    METHOD(void, set_ime_position);
    METHOD(bool, is_embedded);
    METHOD(Vector2, get_contents_minimum_size);
    METHOD(void, set_force_native);
    METHOD(bool, get_force_native);
    METHOD(void, set_content_scale_size);
    METHOD(Vector2i, get_content_scale_size);
    METHOD(void, set_content_scale_mode);
    METHOD(int64_t, get_content_scale_mode);
    METHOD(void, set_content_scale_aspect);
    METHOD(int64_t, get_content_scale_aspect);
    METHOD(void, set_content_scale_stretch);
    METHOD(int64_t, get_content_scale_stretch);
    METHOD(void, set_keep_title_visible);
    METHOD(bool, get_keep_title_visible);
    METHOD(void, set_content_scale_factor);
    METHOD(double, get_content_scale_factor);
    METHOD(void, set_use_font_oversampling);
    METHOD(bool, is_using_font_oversampling);
    METHOD(void, set_mouse_passthrough_polygon);
    METHOD(PackedArray<Vector2>, get_mouse_passthrough_polygon);
    METHOD(void, set_wrap_controls);
    METHOD(bool, is_wrapping_controls);
    METHOD(Variant, child_controls_changed);
    METHOD(void, set_theme);
    METHOD(Object, get_theme);
    METHOD(void, set_theme_type_variation);
    METHOD(String, get_theme_type_variation);
    METHOD(Variant, begin_bulk_theme_override);
    METHOD(Variant, end_bulk_theme_override);
    METHOD(Variant, add_theme_icon_override);
    METHOD(Variant, add_theme_stylebox_override);
    METHOD(Variant, add_theme_font_override);
    METHOD(Variant, add_theme_font_size_override);
    METHOD(Variant, add_theme_color_override);
    METHOD(Variant, add_theme_constant_override);
    METHOD(Variant, remove_theme_icon_override);
    METHOD(Variant, remove_theme_stylebox_override);
    METHOD(Variant, remove_theme_font_override);
    METHOD(Variant, remove_theme_font_size_override);
    METHOD(Variant, remove_theme_color_override);
    METHOD(Variant, remove_theme_constant_override);
    METHOD(Object, get_theme_icon);
    METHOD(Object, get_theme_stylebox);
    METHOD(Object, get_theme_font);
    METHOD(int64_t, get_theme_font_size);
    METHOD(Color, get_theme_color);
    METHOD(int64_t, get_theme_constant);
    METHOD(bool, has_theme_icon_override);
    METHOD(bool, has_theme_stylebox_override);
    METHOD(bool, has_theme_font_override);
    METHOD(bool, has_theme_font_size_override);
    METHOD(bool, has_theme_color_override);
    METHOD(bool, has_theme_constant_override);
    METHOD(bool, has_theme_icon);
    METHOD(bool, has_theme_stylebox);
    METHOD(bool, has_theme_font);
    METHOD(bool, has_theme_font_size);
    METHOD(bool, has_theme_color);
    METHOD(bool, has_theme_constant);
    METHOD(double, get_theme_default_base_scale);
    METHOD(Object, get_theme_default_font);
    METHOD(int64_t, get_theme_default_font_size);
    METHOD(void, set_layout_direction);
    METHOD(int64_t, get_layout_direction);
    METHOD(bool, is_layout_rtl);
    METHOD(void, set_auto_translate);
    METHOD(bool, is_auto_translating);
    METHOD(Variant, popup);
    METHOD(Variant, popup_on_parent);
    METHOD(Variant, popup_centered);
    METHOD(Variant, popup_centered_ratio);
    METHOD(Variant, popup_centered_clamped);
    METHOD(Variant, popup_exclusive);
    METHOD(Variant, popup_exclusive_on_parent);
    METHOD(Variant, popup_exclusive_centered);
    METHOD(Variant, popup_exclusive_centered_ratio);
    METHOD(Variant, popup_exclusive_centered_clamped);
    static constexpr int64_t NOTIFICATION_VISIBILITY_CHANGED = 30;
    static constexpr int64_t NOTIFICATION_THEME_CHANGED = 32;
    static constexpr int64_t MODE_WINDOWED = 0;
    static constexpr int64_t MODE_MINIMIZED = 1;
    static constexpr int64_t MODE_MAXIMIZED = 2;
    static constexpr int64_t MODE_FULLSCREEN = 3;
    static constexpr int64_t MODE_EXCLUSIVE_FULLSCREEN = 4;
    static constexpr int64_t FLAG_RESIZE_DISABLED = 0;
    static constexpr int64_t FLAG_BORDERLESS = 1;
    static constexpr int64_t FLAG_ALWAYS_ON_TOP = 2;
    static constexpr int64_t FLAG_TRANSPARENT = 3;
    static constexpr int64_t FLAG_NO_FOCUS = 4;
    static constexpr int64_t FLAG_POPUP = 5;
    static constexpr int64_t FLAG_EXTEND_TO_TITLE = 6;
    static constexpr int64_t FLAG_MOUSE_PASSTHROUGH = 7;
    static constexpr int64_t FLAG_MAX = 8;
    static constexpr int64_t CONTENT_SCALE_MODE_DISABLED = 0;
    static constexpr int64_t CONTENT_SCALE_MODE_CANVAS_ITEMS = 1;
    static constexpr int64_t CONTENT_SCALE_MODE_VIEWPORT = 2;
    static constexpr int64_t CONTENT_SCALE_ASPECT_IGNORE = 0;
    static constexpr int64_t CONTENT_SCALE_ASPECT_KEEP = 1;
    static constexpr int64_t CONTENT_SCALE_ASPECT_KEEP_WIDTH = 2;
    static constexpr int64_t CONTENT_SCALE_ASPECT_KEEP_HEIGHT = 3;
    static constexpr int64_t CONTENT_SCALE_ASPECT_EXPAND = 4;
    static constexpr int64_t CONTENT_SCALE_STRETCH_FRACTIONAL = 0;
    static constexpr int64_t CONTENT_SCALE_STRETCH_INTEGER = 1;
    static constexpr int64_t LAYOUT_DIRECTION_INHERITED = 0;
    static constexpr int64_t LAYOUT_DIRECTION_LOCALE = 1;
    static constexpr int64_t LAYOUT_DIRECTION_LTR = 2;
    static constexpr int64_t LAYOUT_DIRECTION_RTL = 3;
    static constexpr int64_t WINDOW_INITIAL_POSITION_ABSOLUTE = 0;
    static constexpr int64_t WINDOW_INITIAL_POSITION_CENTER_PRIMARY_SCREEN = 1;
    static constexpr int64_t WINDOW_INITIAL_POSITION_CENTER_MAIN_WINDOW_SCREEN = 2;
    static constexpr int64_t WINDOW_INITIAL_POSITION_CENTER_OTHER_SCREEN = 3;
    static constexpr int64_t WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_MOUSE_FOCUS = 4;
    static constexpr int64_t WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_KEYBOARD_FOCUS = 5;
};
struct WorkerThreadPool : public Object {
    using Object::Object;
    METHOD(int64_t, add_task);
    METHOD(bool, is_task_completed);
    METHOD(int64_t, wait_for_task_completion);
    METHOD(int64_t, add_group_task);
    METHOD(bool, is_group_task_completed);
    METHOD(int64_t, get_group_processed_element_count);
    METHOD(Variant, wait_for_group_task_completion);
    static WorkerThreadPool get_singleton() { return WorkerThreadPool(Object("WorkerThreadPool").address()); }
};
struct World2D : public Resource {
    using Resource::Resource;
    PROPERTY(canvas, ::RID);
    PROPERTY(space, ::RID);
    PROPERTY(navigation_map, ::RID);
    PROPERTY(direct_space_state, Object);
    METHOD(::RID, get_canvas);
    METHOD(::RID, get_space);
    METHOD(::RID, get_navigation_map);
    METHOD(Object, get_direct_space_state);
};
struct World3D : public Resource {
    using Resource::Resource;
    PROPERTY(environment, Object);
    PROPERTY(fallback_environment, Object);
    PROPERTY(camera_attributes, Object);
    PROPERTY(space, ::RID);
    PROPERTY(navigation_map, ::RID);
    PROPERTY(scenario, ::RID);
    PROPERTY(direct_space_state, Object);
    METHOD(::RID, get_space);
    METHOD(::RID, get_navigation_map);
    METHOD(::RID, get_scenario);
    METHOD(void, set_environment);
    METHOD(Object, get_environment);
    METHOD(void, set_fallback_environment);
    METHOD(Object, get_fallback_environment);
    METHOD(void, set_camera_attributes);
    METHOD(Object, get_camera_attributes);
    METHOD(Object, get_direct_space_state);
};
struct WorldBoundaryShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(normal, Vector2);
    PROPERTY(distance, double);
    METHOD(void, set_normal);
    METHOD(Vector2, get_normal);
    METHOD(void, set_distance);
    METHOD(double, get_distance);
};
struct WorldBoundaryShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(plane, Plane);
    METHOD(void, set_plane);
    METHOD(Plane, get_plane);
};
struct WorldEnvironment : public Node {
    using Node::Node;
    PROPERTY(environment, Object);
    PROPERTY(camera_attributes, Object);
    PROPERTY(compositor, Object);
    METHOD(void, set_environment);
    METHOD(Object, get_environment);
    METHOD(void, set_camera_attributes);
    METHOD(Object, get_camera_attributes);
    METHOD(void, set_compositor);
    METHOD(Object, get_compositor);
};
struct X509Certificate : public Resource {
    using Resource::Resource;
    METHOD(int64_t, save);
    METHOD(int64_t, load);
    METHOD(String, save_to_string);
    METHOD(int64_t, load_from_string);
};
struct XMLParser : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, read);
    METHOD(int64_t, get_node_type);
    METHOD(String, get_node_name);
    METHOD(String, get_node_data);
    METHOD(int64_t, get_node_offset);
    METHOD(int64_t, get_attribute_count);
    METHOD(String, get_attribute_name);
    METHOD(String, get_attribute_value);
    METHOD(bool, has_attribute);
    METHOD(String, get_named_attribute_value);
    METHOD(String, get_named_attribute_value_safe);
    METHOD(bool, is_empty);
    METHOD(int64_t, get_current_line);
    METHOD(Variant, skip_section);
    METHOD(int64_t, seek);
    METHOD(int64_t, open);
    METHOD(int64_t, open_buffer);
    static constexpr int64_t NODE_NONE = 0;
    static constexpr int64_t NODE_ELEMENT = 1;
    static constexpr int64_t NODE_ELEMENT_END = 2;
    static constexpr int64_t NODE_TEXT = 3;
    static constexpr int64_t NODE_COMMENT = 4;
    static constexpr int64_t NODE_CDATA = 5;
    static constexpr int64_t NODE_UNKNOWN = 6;
};
struct XRBodyModifier3D : public SkeletonModifier3D {
    using SkeletonModifier3D::SkeletonModifier3D;
    PROPERTY(body_tracker, String);
    PROPERTY(body_update, int64_t);
    PROPERTY(bone_update, int64_t);
    METHOD(void, set_body_tracker);
    METHOD(String, get_body_tracker);
    METHOD(void, set_body_update);
    METHOD(int64_t, get_body_update);
    METHOD(void, set_bone_update);
    METHOD(int64_t, get_bone_update);
    static constexpr int64_t BODY_UPDATE_UPPER_BODY = 1;
    static constexpr int64_t BODY_UPDATE_LOWER_BODY = 2;
    static constexpr int64_t BODY_UPDATE_HANDS = 4;
    static constexpr int64_t BONE_UPDATE_FULL = 0;
    static constexpr int64_t BONE_UPDATE_ROTATION_ONLY = 1;
    static constexpr int64_t BONE_UPDATE_MAX = 2;
};
struct XRCamera3D : public Camera3D {
    using Camera3D::Camera3D;
};
struct XRFaceModifier3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(face_tracker, String);
    PROPERTY(target, String);
    METHOD(void, set_face_tracker);
    METHOD(String, get_face_tracker);
    METHOD(void, set_target);
    METHOD(String, get_target);
};
struct XRHandModifier3D : public SkeletonModifier3D {
    using SkeletonModifier3D::SkeletonModifier3D;
    PROPERTY(hand_tracker, String);
    PROPERTY(bone_update, int64_t);
    METHOD(void, set_hand_tracker);
    METHOD(String, get_hand_tracker);
    METHOD(void, set_bone_update);
    METHOD(int64_t, get_bone_update);
    static constexpr int64_t BONE_UPDATE_FULL = 0;
    static constexpr int64_t BONE_UPDATE_ROTATION_ONLY = 1;
    static constexpr int64_t BONE_UPDATE_MAX = 2;
};
struct XRInterface : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(interface_is_primary, bool);
    PROPERTY(xr_play_area_mode, int64_t);
    PROPERTY(environment_blend_mode, int64_t);
    PROPERTY(ar_is_anchor_detection_enabled, bool);
    METHOD(String, get_name);
    METHOD(int64_t, get_capabilities);
    METHOD(bool, is_primary);
    METHOD(void, set_primary);
    METHOD(bool, is_initialized);
    METHOD(bool, initialize);
    METHOD(Variant, uninitialize);
    METHOD(Dictionary, get_system_info);
    METHOD(int64_t, get_tracking_status);
    METHOD(Vector2, get_render_target_size);
    METHOD(int64_t, get_view_count);
    METHOD(Variant, trigger_haptic_pulse);
    METHOD(bool, supports_play_area_mode);
    METHOD(int64_t, get_play_area_mode);
    METHOD(bool, set_play_area_mode);
    METHOD(PackedArray<Vector3>, get_play_area);
    METHOD(bool, get_anchor_detection_is_enabled);
    METHOD(void, set_anchor_detection_is_enabled);
    METHOD(int64_t, get_camera_feed_id);
    METHOD(bool, is_passthrough_supported);
    METHOD(bool, is_passthrough_enabled);
    METHOD(bool, start_passthrough);
    METHOD(Variant, stop_passthrough);
    METHOD(Transform3D, get_transform_for_view);
    METHOD(Variant, get_projection_for_view);
    METHOD(Array, get_supported_environment_blend_modes);
    METHOD(bool, set_environment_blend_mode);
    METHOD(int64_t, get_environment_blend_mode);
    static constexpr int64_t XR_NONE = 0;
    static constexpr int64_t XR_MONO = 1;
    static constexpr int64_t XR_STEREO = 2;
    static constexpr int64_t XR_QUAD = 4;
    static constexpr int64_t XR_VR = 8;
    static constexpr int64_t XR_AR = 16;
    static constexpr int64_t XR_EXTERNAL = 32;
    static constexpr int64_t XR_NORMAL_TRACKING = 0;
    static constexpr int64_t XR_EXCESSIVE_MOTION = 1;
    static constexpr int64_t XR_INSUFFICIENT_FEATURES = 2;
    static constexpr int64_t XR_UNKNOWN_TRACKING = 3;
    static constexpr int64_t XR_NOT_TRACKING = 4;
    static constexpr int64_t XR_PLAY_AREA_UNKNOWN = 0;
    static constexpr int64_t XR_PLAY_AREA_3DOF = 1;
    static constexpr int64_t XR_PLAY_AREA_SITTING = 2;
    static constexpr int64_t XR_PLAY_AREA_ROOMSCALE = 3;
    static constexpr int64_t XR_PLAY_AREA_STAGE = 4;
    static constexpr int64_t XR_ENV_BLEND_MODE_OPAQUE = 0;
    static constexpr int64_t XR_ENV_BLEND_MODE_ADDITIVE = 1;
    static constexpr int64_t XR_ENV_BLEND_MODE_ALPHA_BLEND = 2;
};
struct XRInterfaceExtension : public XRInterface {
    using XRInterface::XRInterface;
    METHOD(String, _get_name);
    METHOD(int64_t, _get_capabilities);
    METHOD(bool, _is_initialized);
    METHOD(bool, _initialize);
    METHOD(Variant, _uninitialize);
    METHOD(Dictionary, _get_system_info);
    METHOD(bool, _supports_play_area_mode);
    METHOD(int64_t, _get_play_area_mode);
    METHOD(bool, _set_play_area_mode);
    METHOD(PackedArray<Vector3>, _get_play_area);
    METHOD(Vector2, _get_render_target_size);
    METHOD(int64_t, _get_view_count);
    METHOD(Transform3D, _get_camera_transform);
    METHOD(Transform3D, _get_transform_for_view);
    METHOD(PackedArray<double>, _get_projection_for_view);
    METHOD(::RID, _get_vrs_texture);
    METHOD(Variant, _process);
    METHOD(Variant, _pre_render);
    METHOD(bool, _pre_draw_viewport);
    METHOD(Variant, _post_draw_viewport);
    METHOD(Variant, _end_frame);
    METHOD(PackedArray<std::string>, _get_suggested_tracker_names);
    METHOD(PackedArray<std::string>, _get_suggested_pose_names);
    METHOD(int64_t, _get_tracking_status);
    METHOD(Variant, _trigger_haptic_pulse);
    METHOD(bool, _get_anchor_detection_is_enabled);
    METHOD(Variant, _set_anchor_detection_is_enabled);
    METHOD(int64_t, _get_camera_feed_id);
    METHOD(::RID, _get_color_texture);
    METHOD(::RID, _get_depth_texture);
    METHOD(::RID, _get_velocity_texture);
    METHOD(::RID, get_color_texture);
    METHOD(::RID, get_depth_texture);
    METHOD(::RID, get_velocity_texture);
    METHOD(Variant, add_blit);
    METHOD(::RID, get_render_target_texture);
};
struct XRNode3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(tracker, String);
    PROPERTY(pose, String);
    PROPERTY(show_when_tracked, bool);
    METHOD(void, set_tracker);
    METHOD(String, get_tracker);
    METHOD(void, set_pose_name);
    METHOD(String, get_pose_name);
    METHOD(void, set_show_when_tracked);
    METHOD(bool, get_show_when_tracked);
    METHOD(bool, get_is_active);
    METHOD(bool, get_has_tracking_data);
    METHOD(Object, get_pose);
    METHOD(Variant, trigger_haptic_pulse);
};
struct XROrigin3D : public Node3D {
    using Node3D::Node3D;
    PROPERTY(world_scale, double);
    PROPERTY(current, bool);
    METHOD(void, set_world_scale);
    METHOD(double, get_world_scale);
    METHOD(void, set_current);
    METHOD(bool, is_current);
};
struct XRPose : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(has_tracking_data, bool);
    PROPERTY(name, String);
    PROPERTY(transform, String);
    PROPERTY(linear_velocity, String);
    PROPERTY(angular_velocity, String);
    PROPERTY(tracking_confidence, int64_t);
    METHOD(void, set_has_tracking_data);
    METHOD(bool, get_has_tracking_data);
    METHOD(void, set_name);
    METHOD(String, get_name);
    METHOD(void, set_transform);
    METHOD(Transform3D, get_transform);
    METHOD(Transform3D, get_adjusted_transform);
    METHOD(void, set_linear_velocity);
    METHOD(Vector3, get_linear_velocity);
    METHOD(void, set_angular_velocity);
    METHOD(Vector3, get_angular_velocity);
    METHOD(void, set_tracking_confidence);
    METHOD(int64_t, get_tracking_confidence);
    static constexpr int64_t XR_TRACKING_CONFIDENCE_NONE = 0;
    static constexpr int64_t XR_TRACKING_CONFIDENCE_LOW = 1;
    static constexpr int64_t XR_TRACKING_CONFIDENCE_HIGH = 2;
};
struct XRServer : public Object {
    using Object::Object;
    PROPERTY(world_scale, double);
    PROPERTY(world_origin, Vector3);
    PROPERTY(primary_interface, Object);
    METHOD(double, get_world_scale);
    METHOD(void, set_world_scale);
    METHOD(Transform3D, get_world_origin);
    METHOD(void, set_world_origin);
    METHOD(Transform3D, get_reference_frame);
    METHOD(Variant, clear_reference_frame);
    METHOD(Variant, center_on_hmd);
    METHOD(Transform3D, get_hmd_transform);
    METHOD(Variant, add_interface);
    METHOD(int64_t, get_interface_count);
    METHOD(Variant, remove_interface);
    METHOD(Object, get_interface);
    METHOD(Array, get_interfaces);
    METHOD(Object, find_interface);
    METHOD(Variant, add_tracker);
    METHOD(Variant, remove_tracker);
    METHOD(Dictionary, get_trackers);
    METHOD(Object, get_tracker);
    METHOD(Object, get_primary_interface);
    METHOD(void, set_primary_interface);
    static constexpr int64_t TRACKER_HEAD = 1;
    static constexpr int64_t TRACKER_CONTROLLER = 2;
    static constexpr int64_t TRACKER_BASESTATION = 4;
    static constexpr int64_t TRACKER_ANCHOR = 8;
    static constexpr int64_t TRACKER_HAND = 16;
    static constexpr int64_t TRACKER_BODY = 32;
    static constexpr int64_t TRACKER_FACE = 64;
    static constexpr int64_t TRACKER_ANY_KNOWN = 127;
    static constexpr int64_t TRACKER_UNKNOWN = 128;
    static constexpr int64_t TRACKER_ANY = 255;
    static constexpr int64_t RESET_FULL_ROTATION = 0;
    static constexpr int64_t RESET_BUT_KEEP_TILT = 1;
    static constexpr int64_t DONT_RESET_ROTATION = 2;
    static XRServer get_singleton() { return XRServer(Object("XRServer").address()); }
};
struct XRTracker : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(type, int64_t);
    PROPERTY(name, String);
    PROPERTY(description, String);
    METHOD(int64_t, get_tracker_type);
    METHOD(void, set_tracker_type);
    METHOD(String, get_tracker_name);
    METHOD(void, set_tracker_name);
    METHOD(String, get_tracker_desc);
    METHOD(void, set_tracker_desc);
};
struct XRVRS : public Object {
    using Object::Object;
    PROPERTY(vrs_min_radius, double);
    PROPERTY(vrs_strength, double);
    METHOD(double, get_vrs_min_radius);
    METHOD(void, set_vrs_min_radius);
    METHOD(double, get_vrs_strength);
    METHOD(void, set_vrs_strength);
    METHOD(::RID, make_vrs_texture);
};
struct ZIPPacker : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, open);
    METHOD(int64_t, start_file);
    METHOD(int64_t, write_file);
    METHOD(int64_t, close_file);
    METHOD(int64_t, close);
    static constexpr int64_t APPEND_CREATE = 0;
    static constexpr int64_t APPEND_CREATEAFTER = 1;
    static constexpr int64_t APPEND_ADDINZIP = 2;
};
struct ZIPReader : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, open);
    METHOD(int64_t, close);
    METHOD(PackedArray<std::string>, get_files);
    METHOD(PackedArray<uint8_t>, read_file);
    METHOD(bool, file_exists);
};
struct ZigScript : public ScriptExtension {
    using ScriptExtension::ScriptExtension;
};
struct ZigScriptLanguage : public ScriptLanguageExtension {
    using ScriptLanguageExtension::ScriptLanguageExtension;
};
struct AESContext : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, start);
    METHOD(PackedArray<uint8_t>, update);
    METHOD(PackedArray<uint8_t>, get_iv_state);
    METHOD(Variant, finish);
    static constexpr int64_t MODE_ECB_ENCRYPT = 0;
    static constexpr int64_t MODE_ECB_DECRYPT = 1;
    static constexpr int64_t MODE_CBC_ENCRYPT = 2;
    static constexpr int64_t MODE_CBC_DECRYPT = 3;
    static constexpr int64_t MODE_MAX = 4;
};
struct AStar2D : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(double, _estimate_cost);
    METHOD(double, _compute_cost);
    METHOD(int64_t, get_available_point_id);
    METHOD(Variant, add_point);
    METHOD(Vector2, get_point_position);
    METHOD(void, set_point_position);
    METHOD(double, get_point_weight_scale);
    METHOD(void, set_point_weight_scale);
    METHOD(Variant, remove_point);
    METHOD(bool, has_point);
    METHOD(PackedArray<int64_t>, get_point_connections);
    METHOD(PackedArray<int64_t>, get_point_ids);
    METHOD(void, set_point_disabled);
    METHOD(bool, is_point_disabled);
    METHOD(Variant, connect_points);
    METHOD(Variant, disconnect_points);
    METHOD(bool, are_points_connected);
    METHOD(int64_t, get_point_count);
    METHOD(int64_t, get_point_capacity);
    METHOD(Variant, reserve_space);
    METHOD(Variant, clear);
    METHOD(int64_t, get_closest_point);
    METHOD(Vector2, get_closest_position_in_segment);
    METHOD(PackedArray<Vector2>, get_point_path);
    METHOD(PackedArray<int64_t>, get_id_path);
};
struct AStar3D : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(double, _estimate_cost);
    METHOD(double, _compute_cost);
    METHOD(int64_t, get_available_point_id);
    METHOD(Variant, add_point);
    METHOD(Vector3, get_point_position);
    METHOD(void, set_point_position);
    METHOD(double, get_point_weight_scale);
    METHOD(void, set_point_weight_scale);
    METHOD(Variant, remove_point);
    METHOD(bool, has_point);
    METHOD(PackedArray<int64_t>, get_point_connections);
    METHOD(PackedArray<int64_t>, get_point_ids);
    METHOD(void, set_point_disabled);
    METHOD(bool, is_point_disabled);
    METHOD(Variant, connect_points);
    METHOD(Variant, disconnect_points);
    METHOD(bool, are_points_connected);
    METHOD(int64_t, get_point_count);
    METHOD(int64_t, get_point_capacity);
    METHOD(Variant, reserve_space);
    METHOD(Variant, clear);
    METHOD(int64_t, get_closest_point);
    METHOD(Vector3, get_closest_position_in_segment);
    METHOD(PackedArray<Vector3>, get_point_path);
    METHOD(PackedArray<int64_t>, get_id_path);
};
struct AStarGrid2D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(region, Rect2i);
    PROPERTY(size, Vector2i);
    PROPERTY(offset, Vector2);
    PROPERTY(cell_size, Vector2);
    PROPERTY(cell_shape, int64_t);
    PROPERTY(jumping_enabled, bool);
    PROPERTY(default_compute_heuristic, int64_t);
    PROPERTY(default_estimate_heuristic, int64_t);
    PROPERTY(diagonal_mode, int64_t);
    METHOD(double, _estimate_cost);
    METHOD(double, _compute_cost);
    METHOD(void, set_region);
    METHOD(Rect2i, get_region);
    METHOD(void, set_size);
    METHOD(Vector2i, get_size);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_cell_size);
    METHOD(Vector2, get_cell_size);
    METHOD(void, set_cell_shape);
    METHOD(int64_t, get_cell_shape);
    METHOD(bool, is_in_bounds);
    METHOD(bool, is_in_boundsv);
    METHOD(bool, is_dirty);
    METHOD(Variant, update);
    METHOD(void, set_jumping_enabled);
    METHOD(bool, is_jumping_enabled);
    METHOD(void, set_diagonal_mode);
    METHOD(int64_t, get_diagonal_mode);
    METHOD(void, set_default_compute_heuristic);
    METHOD(int64_t, get_default_compute_heuristic);
    METHOD(void, set_default_estimate_heuristic);
    METHOD(int64_t, get_default_estimate_heuristic);
    METHOD(void, set_point_solid);
    METHOD(bool, is_point_solid);
    METHOD(void, set_point_weight_scale);
    METHOD(double, get_point_weight_scale);
    METHOD(Variant, fill_solid_region);
    METHOD(Variant, fill_weight_scale_region);
    METHOD(Variant, clear);
    METHOD(Vector2, get_point_position);
    METHOD(PackedArray<Vector2>, get_point_path);
    METHOD(Array, get_id_path);
    static constexpr int64_t HEURISTIC_EUCLIDEAN = 0;
    static constexpr int64_t HEURISTIC_MANHATTAN = 1;
    static constexpr int64_t HEURISTIC_OCTILE = 2;
    static constexpr int64_t HEURISTIC_CHEBYSHEV = 3;
    static constexpr int64_t HEURISTIC_MAX = 4;
    static constexpr int64_t DIAGONAL_MODE_ALWAYS = 0;
    static constexpr int64_t DIAGONAL_MODE_NEVER = 1;
    static constexpr int64_t DIAGONAL_MODE_AT_LEAST_ONE_WALKABLE = 2;
    static constexpr int64_t DIAGONAL_MODE_ONLY_IF_NO_OBSTACLES = 3;
    static constexpr int64_t DIAGONAL_MODE_MAX = 4;
    static constexpr int64_t CELL_SHAPE_SQUARE = 0;
    static constexpr int64_t CELL_SHAPE_ISOMETRIC_RIGHT = 1;
    static constexpr int64_t CELL_SHAPE_ISOMETRIC_DOWN = 2;
    static constexpr int64_t CELL_SHAPE_MAX = 3;
};
struct AnimationTrackEditPlugin : public RefCounted {
    using RefCounted::RefCounted;
};
struct AudioEffectInstance : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, _process);
    METHOD(bool, _process_silence);
};
struct AudioSample : public RefCounted {
    using RefCounted::RefCounted;
};
struct AudioSamplePlayback : public RefCounted {
    using RefCounted::RefCounted;
};
struct AudioStreamPlayback : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, _start);
    METHOD(Variant, _stop);
    METHOD(bool, _is_playing);
    METHOD(int64_t, _get_loop_count);
    METHOD(double, _get_playback_position);
    METHOD(Variant, _seek);
    METHOD(int64_t, _mix);
    METHOD(Variant, _tag_used_streams);
    METHOD(Variant, _set_parameter);
    METHOD(Variant, _get_parameter);
    METHOD(void, set_sample_playback);
    METHOD(Object, get_sample_playback);
};
struct CameraFeed : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(feed_is_active, bool);
    PROPERTY(feed_transform, Transform2D);
    METHOD(int64_t, get_id);
    METHOD(bool, is_active);
    METHOD(void, set_active);
    METHOD(String, get_name);
    METHOD(Variant, _set_name);
    METHOD(int64_t, get_position);
    METHOD(Variant, _set_position);
    METHOD(Transform2D, get_transform);
    METHOD(void, set_transform);
    METHOD(Variant, _set_RGB_img);
    METHOD(Variant, _set_YCbCr_img);
    METHOD(int64_t, get_datatype);
    static constexpr int64_t FEED_NOIMAGE = 0;
    static constexpr int64_t FEED_RGB = 1;
    static constexpr int64_t FEED_YCBCR = 2;
    static constexpr int64_t FEED_YCBCR_SEP = 3;
    static constexpr int64_t FEED_UNSPECIFIED = 0;
    static constexpr int64_t FEED_FRONT = 1;
    static constexpr int64_t FEED_BACK = 2;
};
struct CharFXTransform : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(transform, Transform2D);
    PROPERTY(range, Vector2i);
    PROPERTY(elapsed_time, double);
    PROPERTY(visible, bool);
    PROPERTY(outline, bool);
    PROPERTY(offset, Vector2);
    PROPERTY(color, Color);
    PROPERTY(env, Dictionary);
    PROPERTY(glyph_index, int64_t);
    PROPERTY(glyph_count, int64_t);
    PROPERTY(glyph_flags, int64_t);
    PROPERTY(relative_index, int64_t);
    PROPERTY(font, ::RID);
    METHOD(Transform2D, get_transform);
    METHOD(void, set_transform);
    METHOD(Vector2i, get_range);
    METHOD(void, set_range);
    METHOD(double, get_elapsed_time);
    METHOD(void, set_elapsed_time);
    METHOD(bool, is_visible);
    METHOD(void, set_visibility);
    METHOD(bool, is_outline);
    METHOD(void, set_outline);
    METHOD(Vector2, get_offset);
    METHOD(void, set_offset);
    METHOD(Color, get_color);
    METHOD(void, set_color);
    METHOD(Dictionary, get_environment);
    METHOD(void, set_environment);
    METHOD(int64_t, get_glyph_index);
    METHOD(void, set_glyph_index);
    METHOD(int64_t, get_relative_index);
    METHOD(void, set_relative_index);
    METHOD(int64_t, get_glyph_count);
    METHOD(void, set_glyph_count);
    METHOD(int64_t, get_glyph_flags);
    METHOD(void, set_glyph_flags);
    METHOD(::RID, get_font);
    METHOD(void, set_font);
};
struct ConfigFile : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(void, set_value);
    METHOD(Variant, get_value);
    METHOD(bool, has_section);
    METHOD(bool, has_section_key);
    METHOD(PackedArray<std::string>, get_sections);
    METHOD(PackedArray<std::string>, get_section_keys);
    METHOD(Variant, erase_section);
    METHOD(Variant, erase_section_key);
    METHOD(int64_t, load);
    METHOD(int64_t, parse);
    METHOD(int64_t, save);
    METHOD(String, encode_to_text);
    METHOD(int64_t, load_encrypted);
    METHOD(int64_t, load_encrypted_pass);
    METHOD(int64_t, save_encrypted);
    METHOD(int64_t, save_encrypted_pass);
    METHOD(Variant, clear);
};
struct Crypto : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(PackedArray<uint8_t>, generate_random_bytes);
    METHOD(Object, generate_rsa);
    METHOD(Object, generate_self_signed_certificate);
    METHOD(PackedArray<uint8_t>, sign);
    METHOD(bool, verify);
    METHOD(PackedArray<uint8_t>, encrypt);
    METHOD(PackedArray<uint8_t>, decrypt);
    METHOD(PackedArray<uint8_t>, hmac_digest);
    METHOD(bool, constant_time_compare);
};
struct DTLSServer : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, setup);
    METHOD(Object, take_connection);
};
struct DirAccess : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(include_navigational, bool);
    PROPERTY(include_hidden, bool);
    METHOD(Object, open);
    METHOD(int64_t, get_open_error);
    METHOD(int64_t, list_dir_begin);
    METHOD(String, get_next);
    METHOD(bool, current_is_dir);
    METHOD(Variant, list_dir_end);
    METHOD(PackedArray<std::string>, get_files);
    METHOD(PackedArray<std::string>, get_files_at);
    METHOD(PackedArray<std::string>, get_directories);
    METHOD(PackedArray<std::string>, get_directories_at);
    METHOD(int64_t, get_drive_count);
    METHOD(String, get_drive_name);
    METHOD(int64_t, get_current_drive);
    METHOD(int64_t, change_dir);
    METHOD(String, get_current_dir);
    METHOD(int64_t, make_dir);
    METHOD(int64_t, make_dir_absolute);
    METHOD(int64_t, make_dir_recursive);
    METHOD(int64_t, make_dir_recursive_absolute);
    METHOD(bool, file_exists);
    METHOD(bool, dir_exists);
    METHOD(bool, dir_exists_absolute);
    METHOD(int64_t, get_space_left);
    METHOD(int64_t, copy);
    METHOD(int64_t, copy_absolute);
    METHOD(int64_t, rename);
    METHOD(int64_t, rename_absolute);
    METHOD(int64_t, remove);
    METHOD(int64_t, remove_absolute);
    METHOD(bool, is_link);
    METHOD(String, read_link);
    METHOD(int64_t, create_link);
    METHOD(void, set_include_navigational);
    METHOD(bool, get_include_navigational);
    METHOD(void, set_include_hidden);
    METHOD(bool, get_include_hidden);
    METHOD(bool, is_case_sensitive);
};
struct DynamicFontImportSettingsData : public RefCounted {
    using RefCounted::RefCounted;
};
struct ENetConnection : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, create_host_bound);
    METHOD(int64_t, create_host);
    METHOD(Variant, destroy);
    METHOD(Object, connect_to_host);
    METHOD(Array, service);
    METHOD(Variant, flush);
    METHOD(Variant, bandwidth_limit);
    METHOD(Variant, channel_limit);
    METHOD(Variant, broadcast);
    METHOD(Variant, compress);
    METHOD(int64_t, dtls_server_setup);
    METHOD(int64_t, dtls_client_setup);
    METHOD(Variant, refuse_new_connections);
    METHOD(double, pop_statistic);
    METHOD(int64_t, get_max_channels);
    METHOD(int64_t, get_local_port);
    METHOD(Array, get_peers);
    METHOD(Variant, socket_send);
    static constexpr int64_t COMPRESS_NONE = 0;
    static constexpr int64_t COMPRESS_RANGE_CODER = 1;
    static constexpr int64_t COMPRESS_FASTLZ = 2;
    static constexpr int64_t COMPRESS_ZLIB = 3;
    static constexpr int64_t COMPRESS_ZSTD = 4;
    static constexpr int64_t EVENT_ERROR = -1;
    static constexpr int64_t EVENT_NONE = 0;
    static constexpr int64_t EVENT_CONNECT = 1;
    static constexpr int64_t EVENT_DISCONNECT = 2;
    static constexpr int64_t EVENT_RECEIVE = 3;
    static constexpr int64_t HOST_TOTAL_SENT_DATA = 0;
    static constexpr int64_t HOST_TOTAL_SENT_PACKETS = 1;
    static constexpr int64_t HOST_TOTAL_RECEIVED_DATA = 2;
    static constexpr int64_t HOST_TOTAL_RECEIVED_PACKETS = 3;
};
struct EncodedObjectAsID : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(object_id, int64_t);
    METHOD(void, set_object_id);
    METHOD(int64_t, get_object_id);
};
struct EngineProfiler : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, _toggle);
    METHOD(Variant, _add_frame);
    METHOD(Variant, _tick);
};
struct Expression : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, parse);
    METHOD(Variant, execute);
    METHOD(bool, has_execute_failed);
    METHOD(String, get_error_text);
};
struct FileAccess : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(big_endian, bool);
    METHOD(Object, open);
    METHOD(Object, open_encrypted);
    METHOD(Object, open_encrypted_with_pass);
    METHOD(Object, open_compressed);
    METHOD(int64_t, get_open_error);
    METHOD(PackedArray<uint8_t>, get_file_as_bytes);
    METHOD(String, get_file_as_string);
    METHOD(int64_t, resize);
    METHOD(Variant, flush);
    METHOD(String, get_path);
    METHOD(String, get_path_absolute);
    METHOD(bool, is_open);
    METHOD(Variant, seek);
    METHOD(Variant, seek_end);
    METHOD(int64_t, get_position);
    METHOD(int64_t, get_length);
    METHOD(bool, eof_reached);
    METHOD(int64_t, get_8);
    METHOD(int64_t, get_16);
    METHOD(int64_t, get_32);
    METHOD(int64_t, get_64);
    METHOD(double, get_float);
    METHOD(double, get_double);
    METHOD(double, get_real);
    METHOD(PackedArray<uint8_t>, get_buffer);
    METHOD(String, get_line);
    METHOD(PackedArray<std::string>, get_csv_line);
    METHOD(String, get_as_text);
    METHOD(String, get_md5);
    METHOD(String, get_sha256);
    METHOD(bool, is_big_endian);
    METHOD(void, set_big_endian);
    METHOD(int64_t, get_error);
    METHOD(Variant, get_var);
    METHOD(Variant, store_8);
    METHOD(Variant, store_16);
    METHOD(Variant, store_32);
    METHOD(Variant, store_64);
    METHOD(Variant, store_float);
    METHOD(Variant, store_double);
    METHOD(Variant, store_real);
    METHOD(Variant, store_buffer);
    METHOD(Variant, store_line);
    METHOD(Variant, store_csv_line);
    METHOD(Variant, store_string);
    METHOD(Variant, store_var);
    METHOD(Variant, store_pascal_string);
    METHOD(String, get_pascal_string);
    METHOD(Variant, close);
    METHOD(bool, file_exists);
    METHOD(int64_t, get_modified_time);
    METHOD(int64_t, get_unix_permissions);
    METHOD(int64_t, set_unix_permissions);
    METHOD(bool, get_hidden_attribute);
    METHOD(int64_t, set_hidden_attribute);
    METHOD(int64_t, set_read_only_attribute);
    METHOD(bool, get_read_only_attribute);
    static constexpr int64_t READ = 1;
    static constexpr int64_t WRITE = 2;
    static constexpr int64_t READ_WRITE = 3;
    static constexpr int64_t WRITE_READ = 7;
    static constexpr int64_t COMPRESSION_FASTLZ = 0;
    static constexpr int64_t COMPRESSION_DEFLATE = 1;
    static constexpr int64_t COMPRESSION_ZSTD = 2;
    static constexpr int64_t COMPRESSION_GZIP = 3;
    static constexpr int64_t COMPRESSION_BROTLI = 4;
    static constexpr int64_t UNIX_READ_OWNER = 256;
    static constexpr int64_t UNIX_WRITE_OWNER = 128;
    static constexpr int64_t UNIX_EXECUTE_OWNER = 64;
    static constexpr int64_t UNIX_READ_GROUP = 32;
    static constexpr int64_t UNIX_WRITE_GROUP = 16;
    static constexpr int64_t UNIX_EXECUTE_GROUP = 8;
    static constexpr int64_t UNIX_READ_OTHER = 4;
    static constexpr int64_t UNIX_WRITE_OTHER = 2;
    static constexpr int64_t UNIX_EXECUTE_OTHER = 1;
    static constexpr int64_t UNIX_SET_USER_ID = 2048;
    static constexpr int64_t UNIX_SET_GROUP_ID = 1024;
    static constexpr int64_t UNIX_RESTRICTED_DELETE = 512;
};
struct GDScriptNativeClass : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, New);
};
struct GDScriptTextDocument : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, didOpen);
    METHOD(Variant, didClose);
    METHOD(Variant, didChange);
    METHOD(Variant, willSaveWaitUntil);
    METHOD(Variant, didSave);
    METHOD(Variant, nativeSymbol);
    METHOD(Array, documentSymbol);
    METHOD(Array, completion);
    METHOD(Dictionary, resolve);
    METHOD(Dictionary, rename);
    METHOD(Variant, prepareRename);
    METHOD(Array, references);
    METHOD(Array, foldingRange);
    METHOD(Array, codeLens);
    METHOD(Array, documentLink);
    METHOD(Array, colorPresentation);
    METHOD(Variant, hover);
    METHOD(Array, definition);
    METHOD(Variant, declaration);
    METHOD(Variant, signatureHelp);
    METHOD(Variant, show_native_symbol_in_editor);
};
struct GDScriptWorkspace : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, apply_new_signal);
    METHOD(Variant, didDeleteFiles);
    METHOD(int64_t, parse_script);
    METHOD(int64_t, parse_local_script);
    METHOD(String, get_file_path);
    METHOD(String, get_file_uri);
    METHOD(Variant, publish_diagnostics);
    METHOD(Dictionary, generate_script_api);
};
struct Gizmo3DHelper : public RefCounted {
    using RefCounted::RefCounted;
};
struct HMACContext : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, start);
    METHOD(int64_t, update);
    METHOD(PackedArray<uint8_t>, finish);
};
struct HTTPClient : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(blocking_mode_enabled, bool);
    PROPERTY(connection, Object);
    PROPERTY(read_chunk_size, int64_t);
    METHOD(int64_t, connect_to_host);
    METHOD(void, set_connection);
    METHOD(Object, get_connection);
    METHOD(int64_t, request_raw);
    METHOD(int64_t, request);
    METHOD(Variant, close);
    METHOD(bool, has_response);
    METHOD(bool, is_response_chunked);
    METHOD(int64_t, get_response_code);
    METHOD(PackedArray<std::string>, get_response_headers);
    METHOD(Dictionary, get_response_headers_as_dictionary);
    METHOD(int64_t, get_response_body_length);
    METHOD(PackedArray<uint8_t>, read_response_body_chunk);
    METHOD(void, set_read_chunk_size);
    METHOD(int64_t, get_read_chunk_size);
    METHOD(void, set_blocking_mode);
    METHOD(bool, is_blocking_mode_enabled);
    METHOD(int64_t, get_status);
    METHOD(int64_t, poll);
    METHOD(void, set_http_proxy);
    METHOD(void, set_https_proxy);
    METHOD(String, query_string_from_dict);
    static constexpr int64_t METHOD_GET = 0;
    static constexpr int64_t METHOD_HEAD = 1;
    static constexpr int64_t METHOD_POST = 2;
    static constexpr int64_t METHOD_PUT = 3;
    static constexpr int64_t METHOD_DELETE = 4;
    static constexpr int64_t METHOD_OPTIONS = 5;
    static constexpr int64_t METHOD_TRACE = 6;
    static constexpr int64_t METHOD_CONNECT = 7;
    static constexpr int64_t METHOD_PATCH = 8;
    static constexpr int64_t METHOD_MAX = 9;
    static constexpr int64_t STATUS_DISCONNECTED = 0;
    static constexpr int64_t STATUS_RESOLVING = 1;
    static constexpr int64_t STATUS_CANT_RESOLVE = 2;
    static constexpr int64_t STATUS_CONNECTING = 3;
    static constexpr int64_t STATUS_CANT_CONNECT = 4;
    static constexpr int64_t STATUS_CONNECTED = 5;
    static constexpr int64_t STATUS_REQUESTING = 6;
    static constexpr int64_t STATUS_BODY = 7;
    static constexpr int64_t STATUS_CONNECTION_ERROR = 8;
    static constexpr int64_t STATUS_TLS_HANDSHAKE_ERROR = 9;
    static constexpr int64_t RESPONSE_CONTINUE = 100;
    static constexpr int64_t RESPONSE_SWITCHING_PROTOCOLS = 101;
    static constexpr int64_t RESPONSE_PROCESSING = 102;
    static constexpr int64_t RESPONSE_OK = 200;
    static constexpr int64_t RESPONSE_CREATED = 201;
    static constexpr int64_t RESPONSE_ACCEPTED = 202;
    static constexpr int64_t RESPONSE_NON_AUTHORITATIVE_INFORMATION = 203;
    static constexpr int64_t RESPONSE_NO_CONTENT = 204;
    static constexpr int64_t RESPONSE_RESET_CONTENT = 205;
    static constexpr int64_t RESPONSE_PARTIAL_CONTENT = 206;
    static constexpr int64_t RESPONSE_MULTI_STATUS = 207;
    static constexpr int64_t RESPONSE_ALREADY_REPORTED = 208;
    static constexpr int64_t RESPONSE_IM_USED = 226;
    static constexpr int64_t RESPONSE_MULTIPLE_CHOICES = 300;
    static constexpr int64_t RESPONSE_MOVED_PERMANENTLY = 301;
    static constexpr int64_t RESPONSE_FOUND = 302;
    static constexpr int64_t RESPONSE_SEE_OTHER = 303;
    static constexpr int64_t RESPONSE_NOT_MODIFIED = 304;
    static constexpr int64_t RESPONSE_USE_PROXY = 305;
    static constexpr int64_t RESPONSE_SWITCH_PROXY = 306;
    static constexpr int64_t RESPONSE_TEMPORARY_REDIRECT = 307;
    static constexpr int64_t RESPONSE_PERMANENT_REDIRECT = 308;
    static constexpr int64_t RESPONSE_BAD_REQUEST = 400;
    static constexpr int64_t RESPONSE_UNAUTHORIZED = 401;
    static constexpr int64_t RESPONSE_PAYMENT_REQUIRED = 402;
    static constexpr int64_t RESPONSE_FORBIDDEN = 403;
    static constexpr int64_t RESPONSE_NOT_FOUND = 404;
    static constexpr int64_t RESPONSE_METHOD_NOT_ALLOWED = 405;
    static constexpr int64_t RESPONSE_NOT_ACCEPTABLE = 406;
    static constexpr int64_t RESPONSE_PROXY_AUTHENTICATION_REQUIRED = 407;
    static constexpr int64_t RESPONSE_REQUEST_TIMEOUT = 408;
    static constexpr int64_t RESPONSE_CONFLICT = 409;
    static constexpr int64_t RESPONSE_GONE = 410;
    static constexpr int64_t RESPONSE_LENGTH_REQUIRED = 411;
    static constexpr int64_t RESPONSE_PRECONDITION_FAILED = 412;
    static constexpr int64_t RESPONSE_REQUEST_ENTITY_TOO_LARGE = 413;
    static constexpr int64_t RESPONSE_REQUEST_URI_TOO_LONG = 414;
    static constexpr int64_t RESPONSE_UNSUPPORTED_MEDIA_TYPE = 415;
    static constexpr int64_t RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    static constexpr int64_t RESPONSE_EXPECTATION_FAILED = 417;
    static constexpr int64_t RESPONSE_IM_A_TEAPOT = 418;
    static constexpr int64_t RESPONSE_MISDIRECTED_REQUEST = 421;
    static constexpr int64_t RESPONSE_UNPROCESSABLE_ENTITY = 422;
    static constexpr int64_t RESPONSE_LOCKED = 423;
    static constexpr int64_t RESPONSE_FAILED_DEPENDENCY = 424;
    static constexpr int64_t RESPONSE_UPGRADE_REQUIRED = 426;
    static constexpr int64_t RESPONSE_PRECONDITION_REQUIRED = 428;
    static constexpr int64_t RESPONSE_TOO_MANY_REQUESTS = 429;
    static constexpr int64_t RESPONSE_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;
    static constexpr int64_t RESPONSE_UNAVAILABLE_FOR_LEGAL_REASONS = 451;
    static constexpr int64_t RESPONSE_INTERNAL_SERVER_ERROR = 500;
    static constexpr int64_t RESPONSE_NOT_IMPLEMENTED = 501;
    static constexpr int64_t RESPONSE_BAD_GATEWAY = 502;
    static constexpr int64_t RESPONSE_SERVICE_UNAVAILABLE = 503;
    static constexpr int64_t RESPONSE_GATEWAY_TIMEOUT = 504;
    static constexpr int64_t RESPONSE_HTTP_VERSION_NOT_SUPPORTED = 505;
    static constexpr int64_t RESPONSE_VARIANT_ALSO_NEGOTIATES = 506;
    static constexpr int64_t RESPONSE_INSUFFICIENT_STORAGE = 507;
    static constexpr int64_t RESPONSE_LOOP_DETECTED = 508;
    static constexpr int64_t RESPONSE_NOT_EXTENDED = 510;
    static constexpr int64_t RESPONSE_NETWORK_AUTH_REQUIRED = 511;
};
struct HashingContext : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, start);
    METHOD(int64_t, update);
    METHOD(PackedArray<uint8_t>, finish);
    static constexpr int64_t HASH_MD5 = 0;
    static constexpr int64_t HASH_SHA1 = 1;
    static constexpr int64_t HASH_SHA256 = 2;
};
struct JavaClass : public RefCounted {
    using RefCounted::RefCounted;
};
struct JavaScriptObject : public RefCounted {
    using RefCounted::RefCounted;
};
struct KinematicCollision2D : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Vector2, get_position);
    METHOD(Vector2, get_normal);
    METHOD(Vector2, get_travel);
    METHOD(Vector2, get_remainder);
    METHOD(double, get_angle);
    METHOD(double, get_depth);
    METHOD(Object, get_local_shape);
    METHOD(Object, get_collider);
    METHOD(int64_t, get_collider_id);
    METHOD(::RID, get_collider_rid);
    METHOD(Object, get_collider_shape);
    METHOD(int64_t, get_collider_shape_index);
    METHOD(Vector2, get_collider_velocity);
};
struct KinematicCollision3D : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Vector3, get_travel);
    METHOD(Vector3, get_remainder);
    METHOD(double, get_depth);
    METHOD(int64_t, get_collision_count);
    METHOD(Vector3, get_position);
    METHOD(Vector3, get_normal);
    METHOD(double, get_angle);
    METHOD(Object, get_local_shape);
    METHOD(Object, get_collider);
    METHOD(int64_t, get_collider_id);
    METHOD(::RID, get_collider_rid);
    METHOD(Object, get_collider_shape);
    METHOD(int64_t, get_collider_shape_index);
    METHOD(Vector3, get_collider_velocity);
};
struct Lightmapper : public RefCounted {
    using RefCounted::RefCounted;
};
struct MeshConvexDecompositionSettings : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(max_concavity, double);
    PROPERTY(symmetry_planes_clipping_bias, double);
    PROPERTY(revolution_axes_clipping_bias, double);
    PROPERTY(min_volume_per_convex_hull, double);
    PROPERTY(resolution, int64_t);
    PROPERTY(max_num_vertices_per_convex_hull, int64_t);
    PROPERTY(plane_downsampling, int64_t);
    PROPERTY(convex_hull_downsampling, int64_t);
    PROPERTY(normalize_mesh, bool);
    PROPERTY(mode, int64_t);
    PROPERTY(convex_hull_approximation, bool);
    PROPERTY(max_convex_hulls, int64_t);
    PROPERTY(project_hull_vertices, bool);
    METHOD(void, set_max_concavity);
    METHOD(double, get_max_concavity);
    METHOD(void, set_symmetry_planes_clipping_bias);
    METHOD(double, get_symmetry_planes_clipping_bias);
    METHOD(void, set_revolution_axes_clipping_bias);
    METHOD(double, get_revolution_axes_clipping_bias);
    METHOD(void, set_min_volume_per_convex_hull);
    METHOD(double, get_min_volume_per_convex_hull);
    METHOD(void, set_resolution);
    METHOD(int64_t, get_resolution);
    METHOD(void, set_max_num_vertices_per_convex_hull);
    METHOD(int64_t, get_max_num_vertices_per_convex_hull);
    METHOD(void, set_plane_downsampling);
    METHOD(int64_t, get_plane_downsampling);
    METHOD(void, set_convex_hull_downsampling);
    METHOD(int64_t, get_convex_hull_downsampling);
    METHOD(void, set_normalize_mesh);
    METHOD(bool, get_normalize_mesh);
    METHOD(void, set_mode);
    METHOD(int64_t, get_mode);
    METHOD(void, set_convex_hull_approximation);
    METHOD(bool, get_convex_hull_approximation);
    METHOD(void, set_max_convex_hulls);
    METHOD(int64_t, get_max_convex_hulls);
    METHOD(void, set_project_hull_vertices);
    METHOD(bool, get_project_hull_vertices);
    static constexpr int64_t CONVEX_DECOMPOSITION_MODE_VOXEL = 0;
    static constexpr int64_t CONVEX_DECOMPOSITION_MODE_TETRAHEDRON = 1;
};
struct MeshDataTool : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, clear);
    METHOD(int64_t, create_from_surface);
    METHOD(int64_t, commit_to_surface);
    METHOD(int64_t, get_format);
    METHOD(int64_t, get_vertex_count);
    METHOD(int64_t, get_edge_count);
    METHOD(int64_t, get_face_count);
    METHOD(void, set_vertex);
    METHOD(Vector3, get_vertex);
    METHOD(void, set_vertex_normal);
    METHOD(Vector3, get_vertex_normal);
    METHOD(void, set_vertex_tangent);
    METHOD(Plane, get_vertex_tangent);
    METHOD(void, set_vertex_uv);
    METHOD(Vector2, get_vertex_uv);
    METHOD(void, set_vertex_uv2);
    METHOD(Vector2, get_vertex_uv2);
    METHOD(void, set_vertex_color);
    METHOD(Color, get_vertex_color);
    METHOD(void, set_vertex_bones);
    METHOD(PackedArray<int32_t>, get_vertex_bones);
    METHOD(void, set_vertex_weights);
    METHOD(PackedArray<float>, get_vertex_weights);
    METHOD(void, set_vertex_meta);
    METHOD(Variant, get_vertex_meta);
    METHOD(PackedArray<int32_t>, get_vertex_edges);
    METHOD(PackedArray<int32_t>, get_vertex_faces);
    METHOD(int64_t, get_edge_vertex);
    METHOD(PackedArray<int32_t>, get_edge_faces);
    METHOD(void, set_edge_meta);
    METHOD(Variant, get_edge_meta);
    METHOD(int64_t, get_face_vertex);
    METHOD(int64_t, get_face_edge);
    METHOD(void, set_face_meta);
    METHOD(Variant, get_face_meta);
    METHOD(Vector3, get_face_normal);
    METHOD(void, set_material);
    METHOD(Object, get_material);
};
struct Mutex : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Variant, lock);
    METHOD(bool, try_lock);
    METHOD(Variant, unlock);
};
struct NavigationPathQueryParameters2D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(map, ::RID);
    PROPERTY(start_position, Vector2);
    PROPERTY(target_position, Vector2);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(pathfinding_algorithm, int64_t);
    PROPERTY(path_postprocessing, int64_t);
    PROPERTY(metadata_flags, int64_t);
    PROPERTY(simplify_path, bool);
    PROPERTY(simplify_epsilon, double);
    METHOD(void, set_pathfinding_algorithm);
    METHOD(int64_t, get_pathfinding_algorithm);
    METHOD(void, set_path_postprocessing);
    METHOD(int64_t, get_path_postprocessing);
    METHOD(void, set_map);
    METHOD(::RID, get_map);
    METHOD(void, set_start_position);
    METHOD(Vector2, get_start_position);
    METHOD(void, set_target_position);
    METHOD(Vector2, get_target_position);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_metadata_flags);
    METHOD(int64_t, get_metadata_flags);
    METHOD(void, set_simplify_path);
    METHOD(bool, get_simplify_path);
    METHOD(void, set_simplify_epsilon);
    METHOD(double, get_simplify_epsilon);
    static constexpr int64_t PATHFINDING_ALGORITHM_ASTAR = 0;
    static constexpr int64_t PATH_POSTPROCESSING_CORRIDORFUNNEL = 0;
    static constexpr int64_t PATH_POSTPROCESSING_EDGECENTERED = 1;
    static constexpr int64_t PATH_METADATA_INCLUDE_NONE = 0;
    static constexpr int64_t PATH_METADATA_INCLUDE_TYPES = 1;
    static constexpr int64_t PATH_METADATA_INCLUDE_RIDS = 2;
    static constexpr int64_t PATH_METADATA_INCLUDE_OWNERS = 4;
    static constexpr int64_t PATH_METADATA_INCLUDE_ALL = 7;
};
struct NavigationPathQueryParameters3D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(map, ::RID);
    PROPERTY(start_position, Vector3);
    PROPERTY(target_position, Vector3);
    PROPERTY(navigation_layers, int64_t);
    PROPERTY(pathfinding_algorithm, int64_t);
    PROPERTY(path_postprocessing, int64_t);
    PROPERTY(metadata_flags, int64_t);
    PROPERTY(simplify_path, bool);
    PROPERTY(simplify_epsilon, double);
    METHOD(void, set_pathfinding_algorithm);
    METHOD(int64_t, get_pathfinding_algorithm);
    METHOD(void, set_path_postprocessing);
    METHOD(int64_t, get_path_postprocessing);
    METHOD(void, set_map);
    METHOD(::RID, get_map);
    METHOD(void, set_start_position);
    METHOD(Vector3, get_start_position);
    METHOD(void, set_target_position);
    METHOD(Vector3, get_target_position);
    METHOD(void, set_navigation_layers);
    METHOD(int64_t, get_navigation_layers);
    METHOD(void, set_metadata_flags);
    METHOD(int64_t, get_metadata_flags);
    METHOD(void, set_simplify_path);
    METHOD(bool, get_simplify_path);
    METHOD(void, set_simplify_epsilon);
    METHOD(double, get_simplify_epsilon);
    static constexpr int64_t PATHFINDING_ALGORITHM_ASTAR = 0;
    static constexpr int64_t PATH_POSTPROCESSING_CORRIDORFUNNEL = 0;
    static constexpr int64_t PATH_POSTPROCESSING_EDGECENTERED = 1;
    static constexpr int64_t PATH_METADATA_INCLUDE_NONE = 0;
    static constexpr int64_t PATH_METADATA_INCLUDE_TYPES = 1;
    static constexpr int64_t PATH_METADATA_INCLUDE_RIDS = 2;
    static constexpr int64_t PATH_METADATA_INCLUDE_OWNERS = 4;
    static constexpr int64_t PATH_METADATA_INCLUDE_ALL = 7;
};
struct NavigationPathQueryResult2D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(path, PackedArray<Vector2>);
    PROPERTY(path_types, PackedArray<int32_t>);
    PROPERTY(path_rids, Array);
    PROPERTY(path_owner_ids, PackedArray<int64_t>);
    METHOD(void, set_path);
    METHOD(PackedArray<Vector2>, get_path);
    METHOD(void, set_path_types);
    METHOD(PackedArray<int32_t>, get_path_types);
    METHOD(void, set_path_rids);
    METHOD(Array, get_path_rids);
    METHOD(void, set_path_owner_ids);
    METHOD(PackedArray<int64_t>, get_path_owner_ids);
    METHOD(Variant, reset);
    static constexpr int64_t PATH_SEGMENT_TYPE_REGION = 0;
    static constexpr int64_t PATH_SEGMENT_TYPE_LINK = 1;
};
struct NavigationPathQueryResult3D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(path, PackedArray<Vector3>);
    PROPERTY(path_types, PackedArray<int32_t>);
    PROPERTY(path_rids, Array);
    PROPERTY(path_owner_ids, PackedArray<int64_t>);
    METHOD(void, set_path);
    METHOD(PackedArray<Vector3>, get_path);
    METHOD(void, set_path_types);
    METHOD(PackedArray<int32_t>, get_path_types);
    METHOD(void, set_path_rids);
    METHOD(Array, get_path_rids);
    METHOD(void, set_path_owner_ids);
    METHOD(PackedArray<int64_t>, get_path_owner_ids);
    METHOD(Variant, reset);
    static constexpr int64_t PATH_SEGMENT_TYPE_REGION = 0;
    static constexpr int64_t PATH_SEGMENT_TYPE_LINK = 1;
};
struct Node3DGizmo : public RefCounted {
    using RefCounted::RefCounted;
};
struct OpenXRAPIExtension : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, get_instance);
    METHOD(int64_t, get_system_id);
    METHOD(int64_t, get_session);
    METHOD(Transform3D, transform_from_pose);
    METHOD(bool, xr_result);
    METHOD(bool, openxr_is_enabled);
    METHOD(int64_t, get_instance_proc_addr);
    METHOD(String, get_error_string);
    METHOD(String, get_swapchain_format_name);
    METHOD(bool, is_initialized);
    METHOD(bool, is_running);
    METHOD(int64_t, get_play_space);
    METHOD(int64_t, get_predicted_display_time);
    METHOD(int64_t, get_next_frame_time);
    METHOD(bool, can_render);
    METHOD(int64_t, get_hand_tracker);
    METHOD(Variant, register_composition_layer_provider);
    METHOD(Variant, unregister_composition_layer_provider);
    METHOD(void, set_emulate_environment_blend_mode_alpha_blend);
    METHOD(int64_t, is_environment_blend_mode_alpha_supported);
    static constexpr int64_t OPENXR_ALPHA_BLEND_MODE_SUPPORT_NONE = 0;
    static constexpr int64_t OPENXR_ALPHA_BLEND_MODE_SUPPORT_REAL = 1;
    static constexpr int64_t OPENXR_ALPHA_BLEND_MODE_SUPPORT_EMULATING = 2;
};
struct PCKPacker : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, pck_start);
    METHOD(int64_t, add_file);
    METHOD(int64_t, flush);
};
struct PackedDataContainerRef : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(int64_t, size);
    METHOD(Variant, _iter_init);
    METHOD(Variant, _iter_get);
    METHOD(Variant, _iter_next);
};
struct PhysicsPointQueryParameters2D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(position, Vector2);
    PROPERTY(canvas_instance_id, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(exclude, Array);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(collide_with_areas, bool);
    METHOD(void, set_position);
    METHOD(Vector2, get_position);
    METHOD(void, set_canvas_instance_id);
    METHOD(int64_t, get_canvas_instance_id);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_exclude);
    METHOD(Array, get_exclude);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
};
struct PhysicsPointQueryParameters3D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(position, Vector3);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(exclude, Array);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(collide_with_areas, bool);
    METHOD(void, set_position);
    METHOD(Vector3, get_position);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_exclude);
    METHOD(Array, get_exclude);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
};
struct PhysicsRayQueryParameters2D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(from, Vector2);
    PROPERTY(to, Vector2);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(exclude, Array);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(collide_with_areas, bool);
    PROPERTY(hit_from_inside, bool);
    METHOD(Object, create);
    METHOD(void, set_from);
    METHOD(Vector2, get_from);
    METHOD(void, set_to);
    METHOD(Vector2, get_to);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_exclude);
    METHOD(Array, get_exclude);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
    METHOD(void, set_hit_from_inside);
    METHOD(bool, is_hit_from_inside_enabled);
};
struct PhysicsRayQueryParameters3D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(from, Vector3);
    PROPERTY(to, Vector3);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(exclude, Array);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(collide_with_areas, bool);
    PROPERTY(hit_from_inside, bool);
    PROPERTY(hit_back_faces, bool);
    METHOD(Object, create);
    METHOD(void, set_from);
    METHOD(Vector3, get_from);
    METHOD(void, set_to);
    METHOD(Vector3, get_to);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_exclude);
    METHOD(Array, get_exclude);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
    METHOD(void, set_hit_from_inside);
    METHOD(bool, is_hit_from_inside_enabled);
    METHOD(void, set_hit_back_faces);
    METHOD(bool, is_hit_back_faces_enabled);
};
struct PhysicsShapeQueryParameters2D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(collision_mask, int64_t);
    PROPERTY(exclude, Array);
    PROPERTY(margin, double);
    PROPERTY(motion, Vector2);
    PROPERTY(shape, Object);
    PROPERTY(shape_rid, ::RID);
    PROPERTY(transform, Transform2D);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(collide_with_areas, bool);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(void, set_shape_rid);
    METHOD(::RID, get_shape_rid);
    METHOD(void, set_transform);
    METHOD(Transform2D, get_transform);
    METHOD(void, set_motion);
    METHOD(Vector2, get_motion);
    METHOD(void, set_margin);
    METHOD(double, get_margin);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_exclude);
    METHOD(Array, get_exclude);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
};
struct PhysicsShapeQueryParameters3D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(collision_mask, int64_t);
    PROPERTY(exclude, Array);
    PROPERTY(margin, double);
    PROPERTY(motion, Vector3);
    PROPERTY(shape, Object);
    PROPERTY(shape_rid, ::RID);
    PROPERTY(transform, Transform3D);
    PROPERTY(collide_with_bodies, bool);
    PROPERTY(collide_with_areas, bool);
    METHOD(void, set_shape);
    METHOD(Object, get_shape);
    METHOD(void, set_shape_rid);
    METHOD(::RID, get_shape_rid);
    METHOD(void, set_transform);
    METHOD(Transform3D, get_transform);
    METHOD(void, set_motion);
    METHOD(Vector3, get_motion);
    METHOD(void, set_margin);
    METHOD(double, get_margin);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_exclude);
    METHOD(Array, get_exclude);
    METHOD(void, set_collide_with_bodies);
    METHOD(bool, is_collide_with_bodies_enabled);
    METHOD(void, set_collide_with_areas);
    METHOD(bool, is_collide_with_areas_enabled);
};
struct PhysicsTestMotionParameters2D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(from, Transform2D);
    PROPERTY(motion, Vector2);
    PROPERTY(margin, double);
    PROPERTY(collide_separation_ray, bool);
    PROPERTY(exclude_bodies, Array);
    PROPERTY(exclude_objects, Array);
    PROPERTY(recovery_as_collision, bool);
    METHOD(Transform2D, get_from);
    METHOD(void, set_from);
    METHOD(Vector2, get_motion);
    METHOD(void, set_motion);
    METHOD(double, get_margin);
    METHOD(void, set_margin);
    METHOD(bool, is_collide_separation_ray_enabled);
    METHOD(void, set_collide_separation_ray_enabled);
    METHOD(Array, get_exclude_bodies);
    METHOD(void, set_exclude_bodies);
    METHOD(Array, get_exclude_objects);
    METHOD(void, set_exclude_objects);
    METHOD(bool, is_recovery_as_collision_enabled);
    METHOD(void, set_recovery_as_collision_enabled);
};
struct PhysicsTestMotionParameters3D : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(from, Transform3D);
    PROPERTY(motion, Vector3);
    PROPERTY(margin, double);
    PROPERTY(max_collisions, int64_t);
    PROPERTY(collide_separation_ray, bool);
    PROPERTY(exclude_bodies, Array);
    PROPERTY(exclude_objects, Array);
    PROPERTY(recovery_as_collision, bool);
    METHOD(Transform3D, get_from);
    METHOD(void, set_from);
    METHOD(Vector3, get_motion);
    METHOD(void, set_motion);
    METHOD(double, get_margin);
    METHOD(void, set_margin);
    METHOD(int64_t, get_max_collisions);
    METHOD(void, set_max_collisions);
    METHOD(bool, is_collide_separation_ray_enabled);
    METHOD(void, set_collide_separation_ray_enabled);
    METHOD(Array, get_exclude_bodies);
    METHOD(void, set_exclude_bodies);
    METHOD(Array, get_exclude_objects);
    METHOD(void, set_exclude_objects);
    METHOD(bool, is_recovery_as_collision_enabled);
    METHOD(void, set_recovery_as_collision_enabled);
};
struct PhysicsTestMotionResult2D : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Vector2, get_travel);
    METHOD(Vector2, get_remainder);
    METHOD(Vector2, get_collision_point);
    METHOD(Vector2, get_collision_normal);
    METHOD(Vector2, get_collider_velocity);
    METHOD(int64_t, get_collider_id);
    METHOD(::RID, get_collider_rid);
    METHOD(Object, get_collider);
    METHOD(int64_t, get_collider_shape);
    METHOD(int64_t, get_collision_local_shape);
    METHOD(double, get_collision_depth);
    METHOD(double, get_collision_safe_fraction);
    METHOD(double, get_collision_unsafe_fraction);
};
struct PhysicsTestMotionResult3D : public RefCounted {
    using RefCounted::RefCounted;
    METHOD(Vector3, get_travel);
    METHOD(Vector3, get_remainder);
    METHOD(double, get_collision_safe_fraction);
    METHOD(double, get_collision_unsafe_fraction);
    METHOD(int64_t, get_collision_count);
    METHOD(Vector3, get_collision_point);
    METHOD(Vector3, get_collision_normal);
    METHOD(Vector3, get_collider_velocity);
    METHOD(int64_t, get_collider_id);
    METHOD(::RID, get_collider_rid);
    METHOD(Object, get_collider);
    METHOD(int64_t, get_collider_shape);
    METHOD(int64_t, get_collision_local_shape);
    METHOD(double, get_collision_depth);
};
struct RDAttachmentFormat : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(format, int64_t);
    PROPERTY(samples, int64_t);
    PROPERTY(usage_flags, int64_t);
    METHOD(void, set_format);
    METHOD(int64_t, get_format);
    METHOD(void, set_samples);
    METHOD(int64_t, get_samples);
    METHOD(void, set_usage_flags);
    METHOD(int64_t, get_usage_flags);
};
struct RDFramebufferPass : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(color_attachments, PackedArray<int32_t>);
    PROPERTY(input_attachments, PackedArray<int32_t>);
    PROPERTY(resolve_attachments, PackedArray<int32_t>);
    PROPERTY(preserve_attachments, PackedArray<int32_t>);
    PROPERTY(depth_attachment, int64_t);
    METHOD(void, set_color_attachments);
    METHOD(PackedArray<int32_t>, get_color_attachments);
    METHOD(void, set_input_attachments);
    METHOD(PackedArray<int32_t>, get_input_attachments);
    METHOD(void, set_resolve_attachments);
    METHOD(PackedArray<int32_t>, get_resolve_attachments);
    METHOD(void, set_preserve_attachments);
    METHOD(PackedArray<int32_t>, get_preserve_attachments);
    METHOD(void, set_depth_attachment);
    METHOD(int64_t, get_depth_attachment);
    static constexpr int64_t ATTACHMENT_UNUSED = -1;
};
struct RDPipelineColorBlendState : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(enable_logic_op, bool);
    PROPERTY(logic_op, int64_t);
    PROPERTY(blend_constant, Color);
    PROPERTY(attachments, Array);
    METHOD(void, set_enable_logic_op);
    METHOD(bool, get_enable_logic_op);
    METHOD(void, set_logic_op);
    METHOD(int64_t, get_logic_op);
    METHOD(void, set_blend_constant);
    METHOD(Color, get_blend_constant);
    METHOD(void, set_attachments);
    METHOD(Array, get_attachments);
};
struct RDPipelineColorBlendStateAttachment : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(enable_blend, bool);
    PROPERTY(src_color_blend_factor, int64_t);
    PROPERTY(dst_color_blend_factor, int64_t);
    PROPERTY(color_blend_op, int64_t);
    PROPERTY(src_alpha_blend_factor, int64_t);
    PROPERTY(dst_alpha_blend_factor, int64_t);
    PROPERTY(alpha_blend_op, int64_t);
    PROPERTY(write_r, bool);
    PROPERTY(write_g, bool);
    PROPERTY(write_b, bool);
    PROPERTY(write_a, bool);
    METHOD(void, set_as_mix);
    METHOD(void, set_enable_blend);
    METHOD(bool, get_enable_blend);
    METHOD(void, set_src_color_blend_factor);
    METHOD(int64_t, get_src_color_blend_factor);
    METHOD(void, set_dst_color_blend_factor);
    METHOD(int64_t, get_dst_color_blend_factor);
    METHOD(void, set_color_blend_op);
    METHOD(int64_t, get_color_blend_op);
    METHOD(void, set_src_alpha_blend_factor);
    METHOD(int64_t, get_src_alpha_blend_factor);
    METHOD(void, set_dst_alpha_blend_factor);
    METHOD(int64_t, get_dst_alpha_blend_factor);
    METHOD(void, set_alpha_blend_op);
    METHOD(int64_t, get_alpha_blend_op);
    METHOD(void, set_write_r);
    METHOD(bool, get_write_r);
    METHOD(void, set_write_g);
    METHOD(bool, get_write_g);
    METHOD(void, set_write_b);
    METHOD(bool, get_write_b);
    METHOD(void, set_write_a);
    METHOD(bool, get_write_a);
};
struct RDPipelineDepthStencilState : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(enable_depth_test, bool);
    PROPERTY(enable_depth_write, bool);
    PROPERTY(depth_compare_operator, int64_t);
    PROPERTY(enable_depth_range, bool);
    PROPERTY(depth_range_min, double);
    PROPERTY(depth_range_max, double);
    PROPERTY(enable_stencil, bool);
    PROPERTY(front_op_fail, int64_t);
    PROPERTY(front_op_pass, int64_t);
    PROPERTY(front_op_depth_fail, int64_t);
    PROPERTY(front_op_compare, int64_t);
    PROPERTY(front_op_compare_mask, int64_t);
    PROPERTY(front_op_write_mask, int64_t);
    PROPERTY(front_op_reference, int64_t);
    PROPERTY(back_op_fail, int64_t);
    PROPERTY(back_op_pass, int64_t);
    PROPERTY(back_op_depth_fail, int64_t);
    PROPERTY(back_op_compare, int64_t);
    PROPERTY(back_op_compare_mask, int64_t);
    PROPERTY(back_op_write_mask, int64_t);
    PROPERTY(back_op_reference, int64_t);
    METHOD(void, set_enable_depth_test);
    METHOD(bool, get_enable_depth_test);
    METHOD(void, set_enable_depth_write);
    METHOD(bool, get_enable_depth_write);
    METHOD(void, set_depth_compare_operator);
    METHOD(int64_t, get_depth_compare_operator);
    METHOD(void, set_enable_depth_range);
    METHOD(bool, get_enable_depth_range);
    METHOD(void, set_depth_range_min);
    METHOD(double, get_depth_range_min);
    METHOD(void, set_depth_range_max);
    METHOD(double, get_depth_range_max);
    METHOD(void, set_enable_stencil);
    METHOD(bool, get_enable_stencil);
    METHOD(void, set_front_op_fail);
    METHOD(int64_t, get_front_op_fail);
    METHOD(void, set_front_op_pass);
    METHOD(int64_t, get_front_op_pass);
    METHOD(void, set_front_op_depth_fail);
    METHOD(int64_t, get_front_op_depth_fail);
    METHOD(void, set_front_op_compare);
    METHOD(int64_t, get_front_op_compare);
    METHOD(void, set_front_op_compare_mask);
    METHOD(int64_t, get_front_op_compare_mask);
    METHOD(void, set_front_op_write_mask);
    METHOD(int64_t, get_front_op_write_mask);
    METHOD(void, set_front_op_reference);
    METHOD(int64_t, get_front_op_reference);
    METHOD(void, set_back_op_fail);
    METHOD(int64_t, get_back_op_fail);
    METHOD(void, set_back_op_pass);
    METHOD(int64_t, get_back_op_pass);
    METHOD(void, set_back_op_depth_fail);
    METHOD(int64_t, get_back_op_depth_fail);
    METHOD(void, set_back_op_compare);
    METHOD(int64_t, get_back_op_compare);
    METHOD(void, set_back_op_compare_mask);
    METHOD(int64_t, get_back_op_compare_mask);
    METHOD(void, set_back_op_write_mask);
    METHOD(int64_t, get_back_op_write_mask);
    METHOD(void, set_back_op_reference);
    METHOD(int64_t, get_back_op_reference);
};
struct RDPipelineMultisampleState : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(sample_count, int64_t);
    PROPERTY(enable_sample_shading, bool);
    PROPERTY(min_sample_shading, double);
    PROPERTY(enable_alpha_to_coverage, bool);
    PROPERTY(enable_alpha_to_one, bool);
    PROPERTY(sample_masks, Array);
    METHOD(void, set_sample_count);
    METHOD(int64_t, get_sample_count);
    METHOD(void, set_enable_sample_shading);
    METHOD(bool, get_enable_sample_shading);
    METHOD(void, set_min_sample_shading);
    METHOD(double, get_min_sample_shading);
    METHOD(void, set_enable_alpha_to_coverage);
    METHOD(bool, get_enable_alpha_to_coverage);
    METHOD(void, set_enable_alpha_to_one);
    METHOD(bool, get_enable_alpha_to_one);
    METHOD(void, set_sample_masks);
    METHOD(Array, get_sample_masks);
};
struct RDPipelineRasterizationState : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(enable_depth_clamp, bool);
    PROPERTY(discard_primitives, bool);
    PROPERTY(wireframe, bool);
    PROPERTY(cull_mode, int64_t);
    PROPERTY(front_face, int64_t);
    PROPERTY(depth_bias_enabled, bool);
    PROPERTY(depth_bias_constant_factor, double);
    PROPERTY(depth_bias_clamp, double);
    PROPERTY(depth_bias_slope_factor, double);
    PROPERTY(line_width, double);
    PROPERTY(patch_control_points, int64_t);
    METHOD(void, set_enable_depth_clamp);
    METHOD(bool, get_enable_depth_clamp);
    METHOD(void, set_discard_primitives);
    METHOD(bool, get_discard_primitives);
    METHOD(void, set_wireframe);
    METHOD(bool, get_wireframe);
    METHOD(void, set_cull_mode);
    METHOD(int64_t, get_cull_mode);
    METHOD(void, set_front_face);
    METHOD(int64_t, get_front_face);
    METHOD(void, set_depth_bias_enabled);
    METHOD(bool, get_depth_bias_enabled);
    METHOD(void, set_depth_bias_constant_factor);
    METHOD(double, get_depth_bias_constant_factor);
    METHOD(void, set_depth_bias_clamp);
    METHOD(double, get_depth_bias_clamp);
    METHOD(void, set_depth_bias_slope_factor);
    METHOD(double, get_depth_bias_slope_factor);
    METHOD(void, set_line_width);
    METHOD(double, get_line_width);
    METHOD(void, set_patch_control_points);
    METHOD(int64_t, get_patch_control_points);
};
struct RDPipelineSpecializationConstant : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(constant_id, int64_t);
    METHOD(void, set_value);
    METHOD(Variant, get_value);
    METHOD(void, set_constant_id);
    METHOD(int64_t, get_constant_id);
};
struct RDSamplerState : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(mag_filter, int64_t);
    PROPERTY(min_filter, int64_t);
    PROPERTY(mip_filter, int64_t);
    PROPERTY(repeat_u, int64_t);
    PROPERTY(repeat_v, int64_t);
    PROPERTY(repeat_w, int64_t);
    PROPERTY(lod_bias, double);
    PROPERTY(use_anisotropy, bool);
    PROPERTY(anisotropy_max, double);
    PROPERTY(enable_compare, bool);
    PROPERTY(compare_op, int64_t);
    PROPERTY(min_lod, double);
    PROPERTY(max_lod, double);
    PROPERTY(border_color, int64_t);
    PROPERTY(unnormalized_uvw, bool);
    METHOD(void, set_mag_filter);
    METHOD(int64_t, get_mag_filter);
    METHOD(void, set_min_filter);
    METHOD(int64_t, get_min_filter);
    METHOD(void, set_mip_filter);
    METHOD(int64_t, get_mip_filter);
    METHOD(void, set_repeat_u);
    METHOD(int64_t, get_repeat_u);
    METHOD(void, set_repeat_v);
    METHOD(int64_t, get_repeat_v);
    METHOD(void, set_repeat_w);
    METHOD(int64_t, get_repeat_w);
    METHOD(void, set_lod_bias);
    METHOD(double, get_lod_bias);
    METHOD(void, set_use_anisotropy);
    METHOD(bool, get_use_anisotropy);
    METHOD(void, set_anisotropy_max);
    METHOD(double, get_anisotropy_max);
    METHOD(void, set_enable_compare);
    METHOD(bool, get_enable_compare);
    METHOD(void, set_compare_op);
    METHOD(int64_t, get_compare_op);
    METHOD(void, set_min_lod);
    METHOD(double, get_min_lod);
    METHOD(void, set_max_lod);
    METHOD(double, get_max_lod);
    METHOD(void, set_border_color);
    METHOD(int64_t, get_border_color);
    METHOD(void, set_unnormalized_uvw);
    METHOD(bool, get_unnormalized_uvw);
};
struct RDShaderSource : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(source_vertex, String);
    PROPERTY(source_fragment, String);
    PROPERTY(source_tesselation_control, String);
    PROPERTY(source_tesselation_evaluation, String);
    PROPERTY(source_compute, String);
    PROPERTY(language, int64_t);
    METHOD(void, set_stage_source);
    METHOD(String, get_stage_source);
    METHOD(void, set_language);
    METHOD(int64_t, get_language);
};
struct RDTextureFormat : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(format, int64_t);
    PROPERTY(width, int64_t);
    PROPERTY(height, int64_t);
    PROPERTY(depth, int64_t);
    PROPERTY(array_layers, int64_t);
    PROPERTY(mipmaps, int64_t);
    PROPERTY(texture_type, int64_t);
    PROPERTY(samples, int64_t);
    PROPERTY(usage_bits, int64_t);
    METHOD(void, set_format);
    METHOD(int64_t, get_format);
    METHOD(void, set_width);
    METHOD(int64_t, get_width);
    METHOD(void, set_height);
    METHOD(int64_t, get_height);
    METHOD(void, set_depth);
    METHOD(int64_t, get_depth);
    METHOD(void, set_array_layers);
    METHOD(int64_t, get_array_layers);
    METHOD(void, set_mipmaps);
    METHOD(int64_t, get_mipmaps);
    METHOD(void, set_texture_type);
    METHOD(int64_t, get_texture_type);
    METHOD(void, set_samples);
    METHOD(int64_t, get_samples);
    METHOD(void, set_usage_bits);
    METHOD(int64_t, get_usage_bits);
    METHOD(Variant, add_shareable_format);
    METHOD(Variant, remove_shareable_format);
};
struct RDTextureView : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(format_override, int64_t);
    PROPERTY(swizzle_r, int64_t);
    PROPERTY(swizzle_g, int64_t);
    PROPERTY(swizzle_b, int64_t);
    PROPERTY(swizzle_a, int64_t);
    METHOD(void, set_format_override);
    METHOD(int64_t, get_format_override);
    METHOD(void, set_swizzle_r);
    METHOD(int64_t, get_swizzle_r);
    METHOD(void, set_swizzle_g);
    METHOD(int64_t, get_swizzle_g);
    METHOD(void, set_swizzle_b);
    METHOD(int64_t, get_swizzle_b);
    METHOD(void, set_swizzle_a);
    METHOD(int64_t, get_swizzle_a);
};
struct RDUniform : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(uniform_type, int64_t);
    PROPERTY(binding, int64_t);
    PROPERTY(_ids, Array);
    METHOD(void, set_uniform_type);
    METHOD(int64_t, get_uniform_type);
    METHOD(void, set_binding);
    METHOD(int64_t, get_binding);
    METHOD(Variant, add_id);
    METHOD(Variant, clear_ids);
    METHOD(Variant, _set_ids);
    METHOD(Array, get_ids);
};
struct RDVertexAttribute : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(location, int64_t);
    PROPERTY(offset, int64_t);
    PROPERTY(format, int64_t);
    PROPERTY(stride, int64_t);
    PROPERTY(frequency, int64_t);
    METHOD(void, set_location);
    METHOD(int64_t, get_location);
    METHOD(void, set_offset);
    METHOD(int64_t, get_offset);
    METHOD(void, set_format);
    METHOD(int64_t, get_format);
    METHOD(void, set_stride);
    METHOD(int64_t, get_stride);
    METHOD(void, set_frequency);
    METHOD(int64_t, get_frequency);
};
struct RandomNumberGenerator : public RefCounted {
    using RefCounted::RefCounted;
    PROPERTY(seed, int64_t);
    PROPERTY(state, int64_t);
    METHOD(void, set_seed);
    METHOD(int64_t, get_seed);
    METHOD(void, set_state);
    METHOD(int64_t, get_state);
    METHOD(int64_t, randi);
    METHOD(double, randf);
    METHOD(double, randfn);
    METHOD(double, randf_range);
    METHOD(int64_t, randi_range);
    METHOD(int64_t, rand_weighted);
    METHOD(Variant, randomize);
};
struct AcceptDialog : public Window {
    using Window::Window;
    PROPERTY(ok_button_text, String);
    PROPERTY(dialog_text, String);
    PROPERTY(dialog_hide_on_ok, bool);
    PROPERTY(dialog_close_on_escape, bool);
    PROPERTY(dialog_autowrap, bool);
    METHOD(Object, get_ok_button);
    METHOD(Object, get_label);
    METHOD(void, set_hide_on_ok);
    METHOD(bool, get_hide_on_ok);
    METHOD(void, set_close_on_escape);
    METHOD(bool, get_close_on_escape);
    METHOD(Object, add_button);
    METHOD(Object, add_cancel_button);
    METHOD(Variant, remove_button);
    METHOD(Variant, register_text_enter);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(void, set_autowrap);
    METHOD(bool, has_autowrap);
    METHOD(void, set_ok_button_text);
    METHOD(String, get_ok_button_text);
};
struct Popup : public Window {
    using Window::Window;
};
struct AnimatableBody2D : public StaticBody2D {
    using StaticBody2D::StaticBody2D;
    PROPERTY(sync_to_physics, bool);
    METHOD(void, set_sync_to_physics);
    METHOD(bool, is_sync_to_physics_enabled);
};
struct AnimatableBody3D : public StaticBody3D {
    using StaticBody3D::StaticBody3D;
    PROPERTY(sync_to_physics, bool);
    METHOD(void, set_sync_to_physics);
    METHOD(bool, is_sync_to_physics_enabled);
};
struct AnimatedTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(frames, int64_t);
    PROPERTY(current_frame, int64_t);
    PROPERTY(pause, bool);
    PROPERTY(one_shot, bool);
    PROPERTY(speed_scale, double);
    METHOD(void, set_frames);
    METHOD(int64_t, get_frames);
    METHOD(void, set_current_frame);
    METHOD(int64_t, get_current_frame);
    METHOD(void, set_pause);
    METHOD(bool, get_pause);
    METHOD(void, set_one_shot);
    METHOD(bool, get_one_shot);
    METHOD(void, set_speed_scale);
    METHOD(double, get_speed_scale);
    METHOD(void, set_frame_texture);
    METHOD(Object, get_frame_texture);
    METHOD(void, set_frame_duration);
    METHOD(double, get_frame_duration);
    static constexpr int64_t MAX_FRAMES = 256;
};
struct AtlasTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(atlas, Object);
    PROPERTY(region, Rect2);
    PROPERTY(margin, Rect2);
    PROPERTY(filter_clip, bool);
    METHOD(void, set_atlas);
    METHOD(Object, get_atlas);
    METHOD(void, set_region);
    METHOD(Rect2, get_region);
    METHOD(void, set_margin);
    METHOD(Rect2, get_margin);
    METHOD(void, set_filter_clip);
    METHOD(bool, has_filter_clip);
};
struct CameraTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(camera_feed_id, int64_t);
    PROPERTY(which_feed, int64_t);
    PROPERTY(camera_is_active, bool);
    METHOD(void, set_camera_feed_id);
    METHOD(int64_t, get_camera_feed_id);
    METHOD(void, set_which_feed);
    METHOD(int64_t, get_which_feed);
    METHOD(void, set_camera_active);
    METHOD(bool, get_camera_active);
};
struct CanvasTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(diffuse_texture, Object);
    PROPERTY(normal_texture, Object);
    PROPERTY(specular_texture, Object);
    PROPERTY(specular_color, Color);
    PROPERTY(specular_shininess, double);
    PROPERTY(texture_filter, int64_t);
    PROPERTY(texture_repeat, int64_t);
    METHOD(void, set_diffuse_texture);
    METHOD(Object, get_diffuse_texture);
    METHOD(void, set_normal_texture);
    METHOD(Object, get_normal_texture);
    METHOD(void, set_specular_texture);
    METHOD(Object, get_specular_texture);
    METHOD(void, set_specular_color);
    METHOD(Color, get_specular_color);
    METHOD(void, set_specular_shininess);
    METHOD(double, get_specular_shininess);
    METHOD(void, set_texture_filter);
    METHOD(int64_t, get_texture_filter);
    METHOD(void, set_texture_repeat);
    METHOD(int64_t, get_texture_repeat);
};
struct CompressedTexture2D : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(load_path, String);
    METHOD(int64_t, load);
    METHOD(String, get_load_path);
};
struct CurveTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(width, int64_t);
    PROPERTY(texture_mode, int64_t);
    PROPERTY(curve, Object);
    METHOD(void, set_width);
    METHOD(void, set_curve);
    METHOD(Object, get_curve);
    METHOD(void, set_texture_mode);
    METHOD(int64_t, get_texture_mode);
    static constexpr int64_t TEXTURE_MODE_RGB = 0;
    static constexpr int64_t TEXTURE_MODE_RED = 1;
};
struct CurveXYZTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(width, int64_t);
    PROPERTY(curve_x, Object);
    PROPERTY(curve_y, Object);
    PROPERTY(curve_z, Object);
    METHOD(void, set_width);
    METHOD(void, set_curve_x);
    METHOD(Object, get_curve_x);
    METHOD(void, set_curve_y);
    METHOD(Object, get_curve_y);
    METHOD(void, set_curve_z);
    METHOD(Object, get_curve_z);
};
struct GradientTexture1D : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(gradient, Object);
    PROPERTY(width, int64_t);
    PROPERTY(use_hdr, bool);
    METHOD(void, set_gradient);
    METHOD(Object, get_gradient);
    METHOD(void, set_width);
    METHOD(void, set_use_hdr);
    METHOD(bool, is_using_hdr);
};
struct GradientTexture2D : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(gradient, Object);
    PROPERTY(width, int64_t);
    PROPERTY(height, int64_t);
    PROPERTY(use_hdr, bool);
    PROPERTY(fill, int64_t);
    PROPERTY(fill_from, Vector2);
    PROPERTY(fill_to, Vector2);
    PROPERTY(repeat, int64_t);
    METHOD(void, set_gradient);
    METHOD(Object, get_gradient);
    METHOD(void, set_width);
    METHOD(void, set_height);
    METHOD(void, set_use_hdr);
    METHOD(bool, is_using_hdr);
    METHOD(void, set_fill);
    METHOD(int64_t, get_fill);
    METHOD(void, set_fill_from);
    METHOD(Vector2, get_fill_from);
    METHOD(void, set_fill_to);
    METHOD(Vector2, get_fill_to);
    METHOD(void, set_repeat);
    METHOD(int64_t, get_repeat);
    static constexpr int64_t FILL_LINEAR = 0;
    static constexpr int64_t FILL_RADIAL = 1;
    static constexpr int64_t FILL_SQUARE = 2;
    static constexpr int64_t REPEAT_NONE = 0;
    static constexpr int64_t REPEAT = 1;
    static constexpr int64_t REPEAT_MIRROR = 2;
};
struct ImageTexture : public Texture2D {
    using Texture2D::Texture2D;
    METHOD(Object, create_from_image);
    METHOD(int64_t, get_format);
    METHOD(void, set_image);
    METHOD(Variant, update);
    METHOD(void, set_size_override);
};
struct MeshTexture : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(mesh, Object);
    PROPERTY(base_texture, Object);
    PROPERTY(image_size, Vector2);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(void, set_image_size);
    METHOD(Vector2, get_image_size);
    METHOD(void, set_base_texture);
    METHOD(Object, get_base_texture);
};
struct NoiseTexture2D : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(width, int64_t);
    PROPERTY(height, int64_t);
    PROPERTY(invert, bool);
    PROPERTY(in_3d_space, bool);
    PROPERTY(generate_mipmaps, bool);
    PROPERTY(seamless, bool);
    PROPERTY(seamless_blend_skirt, double);
    PROPERTY(as_normal_map, bool);
    PROPERTY(bump_strength, double);
    PROPERTY(normalize, bool);
    PROPERTY(color_ramp, Object);
    PROPERTY(noise, Object);
    METHOD(void, set_width);
    METHOD(void, set_height);
    METHOD(void, set_invert);
    METHOD(bool, get_invert);
    METHOD(void, set_in_3d_space);
    METHOD(bool, is_in_3d_space);
    METHOD(void, set_generate_mipmaps);
    METHOD(bool, is_generating_mipmaps);
    METHOD(void, set_seamless);
    METHOD(bool, get_seamless);
    METHOD(void, set_seamless_blend_skirt);
    METHOD(double, get_seamless_blend_skirt);
    METHOD(void, set_as_normal_map);
    METHOD(bool, is_normal_map);
    METHOD(void, set_bump_strength);
    METHOD(double, get_bump_strength);
    METHOD(void, set_normalize);
    METHOD(bool, is_normalized);
    METHOD(void, set_color_ramp);
    METHOD(Object, get_color_ramp);
    METHOD(void, set_noise);
    METHOD(Object, get_noise);
};
struct PlaceholderTexture2D : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(size, Vector2);
    METHOD(void, set_size);
};
struct PortableCompressedTexture2D : public Texture2D {
    using Texture2D::Texture2D;
    PROPERTY(_data, PackedArray<uint8_t>);
    PROPERTY(size_override, Vector2);
    PROPERTY(keep_compressed_buffer, bool);
    METHOD(Variant, create_from_image);
    METHOD(int64_t, get_format);
    METHOD(int64_t, get_compression_mode);
    METHOD(void, set_size_override);
    METHOD(Vector2, get_size_override);
    METHOD(void, set_keep_compressed_buffer);
    METHOD(bool, is_keeping_compressed_buffer);
    METHOD(Variant, _set_data);
    METHOD(PackedArray<uint8_t>, _get_data);
    METHOD(void, set_keep_all_compressed_buffers);
    METHOD(bool, is_keeping_all_compressed_buffers);
    static constexpr int64_t COMPRESSION_MODE_LOSSLESS = 0;
    static constexpr int64_t COMPRESSION_MODE_LOSSY = 1;
    static constexpr int64_t COMPRESSION_MODE_BASIS_UNIVERSAL = 2;
    static constexpr int64_t COMPRESSION_MODE_S3TC = 3;
    static constexpr int64_t COMPRESSION_MODE_ETC2 = 4;
    static constexpr int64_t COMPRESSION_MODE_BPTC = 5;
};
struct Animation : public Resource {
    using Resource::Resource;
    PROPERTY(length, double);
    PROPERTY(loop_mode, int64_t);
    PROPERTY(step, double);
    PROPERTY(capture_included, bool);
    METHOD(int64_t, add_track);
    METHOD(Variant, remove_track);
    METHOD(int64_t, get_track_count);
    METHOD(int64_t, track_get_type);
    METHOD(String, track_get_path);
    METHOD(Variant, track_set_path);
    METHOD(int64_t, find_track);
    METHOD(Variant, track_move_up);
    METHOD(Variant, track_move_down);
    METHOD(Variant, track_move_to);
    METHOD(Variant, track_swap);
    METHOD(Variant, track_set_imported);
    METHOD(bool, track_is_imported);
    METHOD(Variant, track_set_enabled);
    METHOD(bool, track_is_enabled);
    METHOD(int64_t, position_track_insert_key);
    METHOD(int64_t, rotation_track_insert_key);
    METHOD(int64_t, scale_track_insert_key);
    METHOD(int64_t, blend_shape_track_insert_key);
    METHOD(Vector3, position_track_interpolate);
    METHOD(Quaternion, rotation_track_interpolate);
    METHOD(Vector3, scale_track_interpolate);
    METHOD(double, blend_shape_track_interpolate);
    METHOD(int64_t, track_insert_key);
    METHOD(Variant, track_remove_key);
    METHOD(Variant, track_remove_key_at_time);
    METHOD(Variant, track_set_key_value);
    METHOD(Variant, track_set_key_transition);
    METHOD(Variant, track_set_key_time);
    METHOD(double, track_get_key_transition);
    METHOD(int64_t, track_get_key_count);
    METHOD(Variant, track_get_key_value);
    METHOD(double, track_get_key_time);
    METHOD(int64_t, track_find_key);
    METHOD(Variant, track_set_interpolation_type);
    METHOD(int64_t, track_get_interpolation_type);
    METHOD(Variant, track_set_interpolation_loop_wrap);
    METHOD(bool, track_get_interpolation_loop_wrap);
    METHOD(bool, track_is_compressed);
    METHOD(Variant, value_track_set_update_mode);
    METHOD(int64_t, value_track_get_update_mode);
    METHOD(Variant, value_track_interpolate);
    METHOD(String, method_track_get_name);
    METHOD(Array, method_track_get_params);
    METHOD(int64_t, bezier_track_insert_key);
    METHOD(Variant, bezier_track_set_key_value);
    METHOD(Variant, bezier_track_set_key_in_handle);
    METHOD(Variant, bezier_track_set_key_out_handle);
    METHOD(double, bezier_track_get_key_value);
    METHOD(Vector2, bezier_track_get_key_in_handle);
    METHOD(Vector2, bezier_track_get_key_out_handle);
    METHOD(double, bezier_track_interpolate);
    METHOD(int64_t, audio_track_insert_key);
    METHOD(Variant, audio_track_set_key_stream);
    METHOD(Variant, audio_track_set_key_start_offset);
    METHOD(Variant, audio_track_set_key_end_offset);
    METHOD(Object, audio_track_get_key_stream);
    METHOD(double, audio_track_get_key_start_offset);
    METHOD(double, audio_track_get_key_end_offset);
    METHOD(Variant, audio_track_set_use_blend);
    METHOD(bool, audio_track_is_use_blend);
    METHOD(int64_t, animation_track_insert_key);
    METHOD(Variant, animation_track_set_key_animation);
    METHOD(String, animation_track_get_key_animation);
    METHOD(void, set_length);
    METHOD(double, get_length);
    METHOD(void, set_loop_mode);
    METHOD(int64_t, get_loop_mode);
    METHOD(void, set_step);
    METHOD(double, get_step);
    METHOD(Variant, clear);
    METHOD(Variant, copy_track);
    METHOD(Variant, compress);
    METHOD(bool, is_capture_included);
    static constexpr int64_t TYPE_VALUE = 0;
    static constexpr int64_t TYPE_POSITION_3D = 1;
    static constexpr int64_t TYPE_ROTATION_3D = 2;
    static constexpr int64_t TYPE_SCALE_3D = 3;
    static constexpr int64_t TYPE_BLEND_SHAPE = 4;
    static constexpr int64_t TYPE_METHOD = 5;
    static constexpr int64_t TYPE_BEZIER = 6;
    static constexpr int64_t TYPE_AUDIO = 7;
    static constexpr int64_t TYPE_ANIMATION = 8;
    static constexpr int64_t INTERPOLATION_NEAREST = 0;
    static constexpr int64_t INTERPOLATION_LINEAR = 1;
    static constexpr int64_t INTERPOLATION_CUBIC = 2;
    static constexpr int64_t INTERPOLATION_LINEAR_ANGLE = 3;
    static constexpr int64_t INTERPOLATION_CUBIC_ANGLE = 4;
    static constexpr int64_t UPDATE_CONTINUOUS = 0;
    static constexpr int64_t UPDATE_DISCRETE = 1;
    static constexpr int64_t UPDATE_CAPTURE = 2;
    static constexpr int64_t LOOP_NONE = 0;
    static constexpr int64_t LOOP_LINEAR = 1;
    static constexpr int64_t LOOP_PINGPONG = 2;
    static constexpr int64_t LOOPED_FLAG_NONE = 0;
    static constexpr int64_t LOOPED_FLAG_END = 1;
    static constexpr int64_t LOOPED_FLAG_START = 2;
    static constexpr int64_t FIND_MODE_NEAREST = 0;
    static constexpr int64_t FIND_MODE_APPROX = 1;
    static constexpr int64_t FIND_MODE_EXACT = 2;
};
struct AnimationLibrary : public Resource {
    using Resource::Resource;
    PROPERTY(_data, Dictionary);
    METHOD(int64_t, add_animation);
    METHOD(Variant, remove_animation);
    METHOD(Variant, rename_animation);
    METHOD(bool, has_animation);
    METHOD(Object, get_animation);
    METHOD(Array, get_animation_list);
    METHOD(Variant, _set_data);
    METHOD(Dictionary, _get_data);
};
struct AnimationNode : public Resource {
    using Resource::Resource;
    PROPERTY(filter_enabled, bool);
    PROPERTY(filters, Array);
    METHOD(Dictionary, _get_child_nodes);
    METHOD(Array, _get_parameter_list);
    METHOD(Object, _get_child_by_name);
    METHOD(Variant, _get_parameter_default_value);
    METHOD(bool, _is_parameter_read_only);
    METHOD(double, _process);
    METHOD(String, _get_caption);
    METHOD(bool, _has_filter);
    METHOD(bool, add_input);
    METHOD(Variant, remove_input);
    METHOD(bool, set_input_name);
    METHOD(String, get_input_name);
    METHOD(int64_t, get_input_count);
    METHOD(int64_t, find_input);
    METHOD(void, set_filter_path);
    METHOD(bool, is_path_filtered);
    METHOD(void, set_filter_enabled);
    METHOD(bool, is_filter_enabled);
    METHOD(Variant, _set_filters);
    METHOD(Array, _get_filters);
    METHOD(Variant, blend_animation);
    METHOD(double, blend_node);
    METHOD(double, blend_input);
    METHOD(void, set_parameter);
    METHOD(Variant, get_parameter);
    static constexpr int64_t FILTER_IGNORE = 0;
    static constexpr int64_t FILTER_PASS = 1;
    static constexpr int64_t FILTER_STOP = 2;
    static constexpr int64_t FILTER_BLEND = 3;
};
struct AnimationNodeStateMachinePlayback : public Resource {
    using Resource::Resource;
    METHOD(Variant, travel);
    METHOD(Variant, start);
    METHOD(Variant, next);
    METHOD(Variant, stop);
    METHOD(bool, is_playing);
    METHOD(String, get_current_node);
    METHOD(double, get_current_play_position);
    METHOD(double, get_current_length);
    METHOD(String, get_fading_from_node);
    METHOD(Array, get_travel_path);
};
struct AnimationNodeStateMachineTransition : public Resource {
    using Resource::Resource;
    PROPERTY(xfade_time, double);
    PROPERTY(xfade_curve, Object);
    PROPERTY(break_loop_at_end, bool);
    PROPERTY(reset, bool);
    PROPERTY(priority, int64_t);
    PROPERTY(switch_mode, int64_t);
    PROPERTY(advance_mode, int64_t);
    PROPERTY(advance_condition, String);
    PROPERTY(advance_expression, String);
    METHOD(void, set_switch_mode);
    METHOD(int64_t, get_switch_mode);
    METHOD(void, set_advance_mode);
    METHOD(int64_t, get_advance_mode);
    METHOD(void, set_advance_condition);
    METHOD(String, get_advance_condition);
    METHOD(void, set_xfade_time);
    METHOD(double, get_xfade_time);
    METHOD(void, set_xfade_curve);
    METHOD(Object, get_xfade_curve);
    METHOD(void, set_break_loop_at_end);
    METHOD(bool, is_loop_broken_at_end);
    METHOD(void, set_reset);
    METHOD(bool, is_reset);
    METHOD(void, set_priority);
    METHOD(int64_t, get_priority);
    METHOD(void, set_advance_expression);
    METHOD(String, get_advance_expression);
    static constexpr int64_t SWITCH_MODE_IMMEDIATE = 0;
    static constexpr int64_t SWITCH_MODE_SYNC = 1;
    static constexpr int64_t SWITCH_MODE_AT_END = 2;
    static constexpr int64_t ADVANCE_MODE_DISABLED = 0;
    static constexpr int64_t ADVANCE_MODE_ENABLED = 1;
    static constexpr int64_t ADVANCE_MODE_AUTO = 2;
};
struct AudioBusLayout : public Resource {
    using Resource::Resource;
};
struct AudioEffect : public Resource {
    using Resource::Resource;
    METHOD(Object, _instantiate);
};
struct AudioStream : public Resource {
    using Resource::Resource;
    METHOD(Object, _instantiate_playback);
    METHOD(String, _get_stream_name);
    METHOD(double, _get_length);
    METHOD(bool, _is_monophonic);
    METHOD(double, _get_bpm);
    METHOD(int64_t, _get_beat_count);
    METHOD(Array, _get_parameter_list);
    METHOD(double, get_length);
    METHOD(bool, is_monophonic);
    METHOD(Object, instantiate_playback);
    METHOD(bool, can_be_sampled);
    METHOD(Object, generate_sample);
    METHOD(bool, is_meta_stream);
};
struct BitMap : public Resource {
    using Resource::Resource;
    PROPERTY(data, Dictionary);
    METHOD(Variant, create);
    METHOD(Variant, create_from_image_alpha);
    METHOD(void, set_bitv);
    METHOD(void, set_bit);
    METHOD(bool, get_bitv);
    METHOD(bool, get_bit);
    METHOD(void, set_bit_rect);
    METHOD(int64_t, get_true_bit_count);
    METHOD(Vector2i, get_size);
    METHOD(Variant, resize);
    METHOD(Variant, _set_data);
    METHOD(Dictionary, _get_data);
    METHOD(Variant, grow_mask);
    METHOD(Object, convert_to_image);
    METHOD(Array, opaque_to_polygons);
};
struct BoneMap : public Resource {
    using Resource::Resource;
    PROPERTY(profile, Object);
    METHOD(Object, get_profile);
    METHOD(void, set_profile);
    METHOD(String, get_skeleton_bone_name);
    METHOD(void, set_skeleton_bone_name);
    METHOD(String, find_profile_bone_name);
};
struct ButtonGroup : public Resource {
    using Resource::Resource;
    PROPERTY(allow_unpress, bool);
    METHOD(Object, get_pressed_button);
    METHOD(Array, get_buttons);
    METHOD(void, set_allow_unpress);
    METHOD(bool, is_allow_unpress);
};
struct CameraAttributes : public Resource {
    using Resource::Resource;
    PROPERTY(exposure_sensitivity, double);
    PROPERTY(exposure_multiplier, double);
    PROPERTY(auto_exposure_enabled, bool);
    PROPERTY(auto_exposure_scale, double);
    PROPERTY(auto_exposure_speed, double);
    METHOD(void, set_exposure_multiplier);
    METHOD(double, get_exposure_multiplier);
    METHOD(void, set_exposure_sensitivity);
    METHOD(double, get_exposure_sensitivity);
    METHOD(void, set_auto_exposure_enabled);
    METHOD(bool, is_auto_exposure_enabled);
    METHOD(void, set_auto_exposure_speed);
    METHOD(double, get_auto_exposure_speed);
    METHOD(void, set_auto_exposure_scale);
    METHOD(double, get_auto_exposure_scale);
};
struct Compositor : public Resource {
    using Resource::Resource;
    PROPERTY(compositor_effects, Array);
    METHOD(void, set_compositor_effects);
    METHOD(Array, get_compositor_effects);
};
struct CompositorEffect : public Resource {
    using Resource::Resource;
    PROPERTY(enabled, bool);
    PROPERTY(effect_callback_type, int64_t);
    PROPERTY(access_resolved_color, bool);
    PROPERTY(access_resolved_depth, bool);
    PROPERTY(needs_motion_vectors, bool);
    PROPERTY(needs_normal_roughness, bool);
    PROPERTY(needs_separate_specular, bool);
    METHOD(Variant, _render_callback);
    METHOD(void, set_enabled);
    METHOD(bool, get_enabled);
    METHOD(void, set_effect_callback_type);
    METHOD(int64_t, get_effect_callback_type);
    METHOD(void, set_access_resolved_color);
    METHOD(bool, get_access_resolved_color);
    METHOD(void, set_access_resolved_depth);
    METHOD(bool, get_access_resolved_depth);
    METHOD(void, set_needs_motion_vectors);
    METHOD(bool, get_needs_motion_vectors);
    METHOD(void, set_needs_normal_roughness);
    METHOD(bool, get_needs_normal_roughness);
    METHOD(void, set_needs_separate_specular);
    METHOD(bool, get_needs_separate_specular);
    static constexpr int64_t EFFECT_CALLBACK_TYPE_PRE_OPAQUE = 0;
    static constexpr int64_t EFFECT_CALLBACK_TYPE_POST_OPAQUE = 1;
    static constexpr int64_t EFFECT_CALLBACK_TYPE_POST_SKY = 2;
    static constexpr int64_t EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT = 3;
    static constexpr int64_t EFFECT_CALLBACK_TYPE_POST_TRANSPARENT = 4;
    static constexpr int64_t EFFECT_CALLBACK_TYPE_MAX = 5;
};
struct CryptoKey : public Resource {
    using Resource::Resource;
    METHOD(int64_t, save);
    METHOD(int64_t, load);
    METHOD(bool, is_public_only);
    METHOD(String, save_to_string);
    METHOD(int64_t, load_from_string);
};
struct Curve : public Resource {
    using Resource::Resource;
    PROPERTY(min_value, double);
    PROPERTY(max_value, double);
    PROPERTY(bake_resolution, int64_t);
    PROPERTY(_data, int64_t);
    PROPERTY(point_count, int64_t);
    METHOD(int64_t, get_point_count);
    METHOD(void, set_point_count);
    METHOD(int64_t, add_point);
    METHOD(Variant, remove_point);
    METHOD(Variant, clear_points);
    METHOD(Vector2, get_point_position);
    METHOD(void, set_point_value);
    METHOD(int64_t, set_point_offset);
    METHOD(double, sample);
    METHOD(double, sample_baked);
    METHOD(double, get_point_left_tangent);
    METHOD(double, get_point_right_tangent);
    METHOD(int64_t, get_point_left_mode);
    METHOD(int64_t, get_point_right_mode);
    METHOD(void, set_point_left_tangent);
    METHOD(void, set_point_right_tangent);
    METHOD(void, set_point_left_mode);
    METHOD(void, set_point_right_mode);
    METHOD(double, get_min_value);
    METHOD(void, set_min_value);
    METHOD(double, get_max_value);
    METHOD(void, set_max_value);
    METHOD(Variant, clean_dupes);
    METHOD(Variant, bake);
    METHOD(int64_t, get_bake_resolution);
    METHOD(void, set_bake_resolution);
    METHOD(Array, _get_data);
    METHOD(Variant, _set_data);
    static constexpr int64_t TANGENT_FREE = 0;
    static constexpr int64_t TANGENT_LINEAR = 1;
    static constexpr int64_t TANGENT_MODE_COUNT = 2;
};
struct Curve2D : public Resource {
    using Resource::Resource;
    PROPERTY(bake_interval, double);
    PROPERTY(_data, int64_t);
    PROPERTY(point_count, int64_t);
    METHOD(int64_t, get_point_count);
    METHOD(void, set_point_count);
    METHOD(Variant, add_point);
    METHOD(void, set_point_position);
    METHOD(Vector2, get_point_position);
    METHOD(void, set_point_in);
    METHOD(Vector2, get_point_in);
    METHOD(void, set_point_out);
    METHOD(Vector2, get_point_out);
    METHOD(Variant, remove_point);
    METHOD(Variant, clear_points);
    METHOD(Vector2, sample);
    METHOD(Vector2, samplef);
    METHOD(void, set_bake_interval);
    METHOD(double, get_bake_interval);
    METHOD(double, get_baked_length);
    METHOD(Vector2, sample_baked);
    METHOD(Transform2D, sample_baked_with_rotation);
    METHOD(PackedArray<Vector2>, get_baked_points);
    METHOD(Vector2, get_closest_point);
    METHOD(double, get_closest_offset);
    METHOD(PackedArray<Vector2>, tessellate);
    METHOD(PackedArray<Vector2>, tessellate_even_length);
    METHOD(Dictionary, _get_data);
    METHOD(Variant, _set_data);
};
struct Curve3D : public Resource {
    using Resource::Resource;
    PROPERTY(bake_interval, double);
    PROPERTY(_data, int64_t);
    PROPERTY(point_count, int64_t);
    PROPERTY(up_vector_enabled, bool);
    METHOD(int64_t, get_point_count);
    METHOD(void, set_point_count);
    METHOD(Variant, add_point);
    METHOD(void, set_point_position);
    METHOD(Vector3, get_point_position);
    METHOD(void, set_point_tilt);
    METHOD(double, get_point_tilt);
    METHOD(void, set_point_in);
    METHOD(Vector3, get_point_in);
    METHOD(void, set_point_out);
    METHOD(Vector3, get_point_out);
    METHOD(Variant, remove_point);
    METHOD(Variant, clear_points);
    METHOD(Vector3, sample);
    METHOD(Vector3, samplef);
    METHOD(void, set_bake_interval);
    METHOD(double, get_bake_interval);
    METHOD(void, set_up_vector_enabled);
    METHOD(bool, is_up_vector_enabled);
    METHOD(double, get_baked_length);
    METHOD(Vector3, sample_baked);
    METHOD(Transform3D, sample_baked_with_rotation);
    METHOD(Vector3, sample_baked_up_vector);
    METHOD(PackedArray<Vector3>, get_baked_points);
    METHOD(PackedArray<float>, get_baked_tilts);
    METHOD(PackedArray<Vector3>, get_baked_up_vectors);
    METHOD(Vector3, get_closest_point);
    METHOD(double, get_closest_offset);
    METHOD(PackedArray<Vector3>, tessellate);
    METHOD(PackedArray<Vector3>, tessellate_even_length);
    METHOD(Dictionary, _get_data);
    METHOD(Variant, _set_data);
};
struct Environment : public Resource {
    using Resource::Resource;
    PROPERTY(background_mode, int64_t);
    PROPERTY(background_color, Color);
    PROPERTY(background_energy_multiplier, double);
    PROPERTY(background_intensity, double);
    PROPERTY(background_canvas_max_layer, int64_t);
    PROPERTY(background_camera_feed_id, int64_t);
    PROPERTY(sky, Object);
    PROPERTY(sky_custom_fov, double);
    PROPERTY(sky_rotation, Vector3);
    PROPERTY(ambient_light_source, int64_t);
    PROPERTY(ambient_light_color, Color);
    PROPERTY(ambient_light_sky_contribution, double);
    PROPERTY(ambient_light_energy, double);
    PROPERTY(reflected_light_source, int64_t);
    PROPERTY(tonemap_mode, int64_t);
    PROPERTY(tonemap_exposure, double);
    PROPERTY(tonemap_white, double);
    PROPERTY(ssr_enabled, bool);
    PROPERTY(ssr_max_steps, int64_t);
    PROPERTY(ssr_fade_in, double);
    PROPERTY(ssr_fade_out, double);
    PROPERTY(ssr_depth_tolerance, double);
    PROPERTY(ssao_enabled, bool);
    PROPERTY(ssao_radius, double);
    PROPERTY(ssao_intensity, double);
    PROPERTY(ssao_power, double);
    PROPERTY(ssao_detail, double);
    PROPERTY(ssao_horizon, double);
    PROPERTY(ssao_sharpness, double);
    PROPERTY(ssao_light_affect, double);
    PROPERTY(ssao_ao_channel_affect, double);
    PROPERTY(ssil_enabled, bool);
    PROPERTY(ssil_radius, double);
    PROPERTY(ssil_intensity, double);
    PROPERTY(ssil_sharpness, double);
    PROPERTY(ssil_normal_rejection, double);
    PROPERTY(sdfgi_enabled, bool);
    PROPERTY(sdfgi_use_occlusion, bool);
    PROPERTY(sdfgi_read_sky_light, bool);
    PROPERTY(sdfgi_bounce_feedback, double);
    PROPERTY(sdfgi_cascades, int64_t);
    PROPERTY(sdfgi_min_cell_size, double);
    PROPERTY(sdfgi_cascade0_distance, double);
    PROPERTY(sdfgi_max_distance, double);
    PROPERTY(sdfgi_y_scale, int64_t);
    PROPERTY(sdfgi_energy, double);
    PROPERTY(sdfgi_normal_bias, double);
    PROPERTY(sdfgi_probe_bias, double);
    PROPERTY(glow_enabled, bool);
    PROPERTY(glow_normalized, bool);
    PROPERTY(glow_intensity, double);
    PROPERTY(glow_strength, double);
    PROPERTY(glow_mix, double);
    PROPERTY(glow_bloom, double);
    PROPERTY(glow_blend_mode, int64_t);
    PROPERTY(glow_hdr_threshold, double);
    PROPERTY(glow_hdr_scale, double);
    PROPERTY(glow_hdr_luminance_cap, double);
    PROPERTY(glow_map_strength, double);
    PROPERTY(glow_map, Object);
    PROPERTY(fog_enabled, bool);
    PROPERTY(fog_mode, int64_t);
    PROPERTY(fog_light_color, Color);
    PROPERTY(fog_light_energy, double);
    PROPERTY(fog_sun_scatter, double);
    PROPERTY(fog_density, double);
    PROPERTY(fog_aerial_perspective, double);
    PROPERTY(fog_sky_affect, double);
    PROPERTY(fog_height, double);
    PROPERTY(fog_height_density, double);
    PROPERTY(fog_depth_curve, double);
    PROPERTY(fog_depth_begin, double);
    PROPERTY(fog_depth_end, double);
    PROPERTY(volumetric_fog_enabled, bool);
    PROPERTY(volumetric_fog_density, double);
    PROPERTY(volumetric_fog_albedo, Color);
    PROPERTY(volumetric_fog_emission, Color);
    PROPERTY(volumetric_fog_emission_energy, double);
    PROPERTY(volumetric_fog_gi_inject, double);
    PROPERTY(volumetric_fog_anisotropy, double);
    PROPERTY(volumetric_fog_length, double);
    PROPERTY(volumetric_fog_detail_spread, double);
    PROPERTY(volumetric_fog_ambient_inject, double);
    PROPERTY(volumetric_fog_sky_affect, double);
    PROPERTY(volumetric_fog_temporal_reprojection_enabled, bool);
    PROPERTY(volumetric_fog_temporal_reprojection_amount, double);
    PROPERTY(adjustment_enabled, bool);
    PROPERTY(adjustment_brightness, double);
    PROPERTY(adjustment_contrast, double);
    PROPERTY(adjustment_saturation, double);
    PROPERTY(adjustment_color_correction, Object);
    METHOD(void, set_background);
    METHOD(int64_t, get_background);
    METHOD(void, set_sky);
    METHOD(Object, get_sky);
    METHOD(void, set_sky_custom_fov);
    METHOD(double, get_sky_custom_fov);
    METHOD(void, set_sky_rotation);
    METHOD(Vector3, get_sky_rotation);
    METHOD(void, set_bg_color);
    METHOD(Color, get_bg_color);
    METHOD(void, set_bg_energy_multiplier);
    METHOD(double, get_bg_energy_multiplier);
    METHOD(void, set_bg_intensity);
    METHOD(double, get_bg_intensity);
    METHOD(void, set_canvas_max_layer);
    METHOD(int64_t, get_canvas_max_layer);
    METHOD(void, set_camera_feed_id);
    METHOD(int64_t, get_camera_feed_id);
    METHOD(void, set_ambient_light_color);
    METHOD(Color, get_ambient_light_color);
    METHOD(void, set_ambient_source);
    METHOD(int64_t, get_ambient_source);
    METHOD(void, set_ambient_light_energy);
    METHOD(double, get_ambient_light_energy);
    METHOD(void, set_ambient_light_sky_contribution);
    METHOD(double, get_ambient_light_sky_contribution);
    METHOD(void, set_reflection_source);
    METHOD(int64_t, get_reflection_source);
    METHOD(void, set_tonemapper);
    METHOD(int64_t, get_tonemapper);
    METHOD(void, set_tonemap_exposure);
    METHOD(double, get_tonemap_exposure);
    METHOD(void, set_tonemap_white);
    METHOD(double, get_tonemap_white);
    METHOD(void, set_ssr_enabled);
    METHOD(bool, is_ssr_enabled);
    METHOD(void, set_ssr_max_steps);
    METHOD(int64_t, get_ssr_max_steps);
    METHOD(void, set_ssr_fade_in);
    METHOD(double, get_ssr_fade_in);
    METHOD(void, set_ssr_fade_out);
    METHOD(double, get_ssr_fade_out);
    METHOD(void, set_ssr_depth_tolerance);
    METHOD(double, get_ssr_depth_tolerance);
    METHOD(void, set_ssao_enabled);
    METHOD(bool, is_ssao_enabled);
    METHOD(void, set_ssao_radius);
    METHOD(double, get_ssao_radius);
    METHOD(void, set_ssao_intensity);
    METHOD(double, get_ssao_intensity);
    METHOD(void, set_ssao_power);
    METHOD(double, get_ssao_power);
    METHOD(void, set_ssao_detail);
    METHOD(double, get_ssao_detail);
    METHOD(void, set_ssao_horizon);
    METHOD(double, get_ssao_horizon);
    METHOD(void, set_ssao_sharpness);
    METHOD(double, get_ssao_sharpness);
    METHOD(void, set_ssao_direct_light_affect);
    METHOD(double, get_ssao_direct_light_affect);
    METHOD(void, set_ssao_ao_channel_affect);
    METHOD(double, get_ssao_ao_channel_affect);
    METHOD(void, set_ssil_enabled);
    METHOD(bool, is_ssil_enabled);
    METHOD(void, set_ssil_radius);
    METHOD(double, get_ssil_radius);
    METHOD(void, set_ssil_intensity);
    METHOD(double, get_ssil_intensity);
    METHOD(void, set_ssil_sharpness);
    METHOD(double, get_ssil_sharpness);
    METHOD(void, set_ssil_normal_rejection);
    METHOD(double, get_ssil_normal_rejection);
    METHOD(void, set_sdfgi_enabled);
    METHOD(bool, is_sdfgi_enabled);
    METHOD(void, set_sdfgi_cascades);
    METHOD(int64_t, get_sdfgi_cascades);
    METHOD(void, set_sdfgi_min_cell_size);
    METHOD(double, get_sdfgi_min_cell_size);
    METHOD(void, set_sdfgi_max_distance);
    METHOD(double, get_sdfgi_max_distance);
    METHOD(void, set_sdfgi_cascade0_distance);
    METHOD(double, get_sdfgi_cascade0_distance);
    METHOD(void, set_sdfgi_y_scale);
    METHOD(int64_t, get_sdfgi_y_scale);
    METHOD(void, set_sdfgi_use_occlusion);
    METHOD(bool, is_sdfgi_using_occlusion);
    METHOD(void, set_sdfgi_bounce_feedback);
    METHOD(double, get_sdfgi_bounce_feedback);
    METHOD(void, set_sdfgi_read_sky_light);
    METHOD(bool, is_sdfgi_reading_sky_light);
    METHOD(void, set_sdfgi_energy);
    METHOD(double, get_sdfgi_energy);
    METHOD(void, set_sdfgi_normal_bias);
    METHOD(double, get_sdfgi_normal_bias);
    METHOD(void, set_sdfgi_probe_bias);
    METHOD(double, get_sdfgi_probe_bias);
    METHOD(void, set_glow_enabled);
    METHOD(bool, is_glow_enabled);
    METHOD(void, set_glow_level);
    METHOD(double, get_glow_level);
    METHOD(void, set_glow_normalized);
    METHOD(bool, is_glow_normalized);
    METHOD(void, set_glow_intensity);
    METHOD(double, get_glow_intensity);
    METHOD(void, set_glow_strength);
    METHOD(double, get_glow_strength);
    METHOD(void, set_glow_mix);
    METHOD(double, get_glow_mix);
    METHOD(void, set_glow_bloom);
    METHOD(double, get_glow_bloom);
    METHOD(void, set_glow_blend_mode);
    METHOD(int64_t, get_glow_blend_mode);
    METHOD(void, set_glow_hdr_bleed_threshold);
    METHOD(double, get_glow_hdr_bleed_threshold);
    METHOD(void, set_glow_hdr_bleed_scale);
    METHOD(double, get_glow_hdr_bleed_scale);
    METHOD(void, set_glow_hdr_luminance_cap);
    METHOD(double, get_glow_hdr_luminance_cap);
    METHOD(void, set_glow_map_strength);
    METHOD(double, get_glow_map_strength);
    METHOD(void, set_glow_map);
    METHOD(Object, get_glow_map);
    METHOD(void, set_fog_enabled);
    METHOD(bool, is_fog_enabled);
    METHOD(void, set_fog_mode);
    METHOD(int64_t, get_fog_mode);
    METHOD(void, set_fog_light_color);
    METHOD(Color, get_fog_light_color);
    METHOD(void, set_fog_light_energy);
    METHOD(double, get_fog_light_energy);
    METHOD(void, set_fog_sun_scatter);
    METHOD(double, get_fog_sun_scatter);
    METHOD(void, set_fog_density);
    METHOD(double, get_fog_density);
    METHOD(void, set_fog_height);
    METHOD(double, get_fog_height);
    METHOD(void, set_fog_height_density);
    METHOD(double, get_fog_height_density);
    METHOD(void, set_fog_aerial_perspective);
    METHOD(double, get_fog_aerial_perspective);
    METHOD(void, set_fog_sky_affect);
    METHOD(double, get_fog_sky_affect);
    METHOD(void, set_fog_depth_curve);
    METHOD(double, get_fog_depth_curve);
    METHOD(void, set_fog_depth_begin);
    METHOD(double, get_fog_depth_begin);
    METHOD(void, set_fog_depth_end);
    METHOD(double, get_fog_depth_end);
    METHOD(void, set_volumetric_fog_enabled);
    METHOD(bool, is_volumetric_fog_enabled);
    METHOD(void, set_volumetric_fog_emission);
    METHOD(Color, get_volumetric_fog_emission);
    METHOD(void, set_volumetric_fog_albedo);
    METHOD(Color, get_volumetric_fog_albedo);
    METHOD(void, set_volumetric_fog_density);
    METHOD(double, get_volumetric_fog_density);
    METHOD(void, set_volumetric_fog_emission_energy);
    METHOD(double, get_volumetric_fog_emission_energy);
    METHOD(void, set_volumetric_fog_anisotropy);
    METHOD(double, get_volumetric_fog_anisotropy);
    METHOD(void, set_volumetric_fog_length);
    METHOD(double, get_volumetric_fog_length);
    METHOD(void, set_volumetric_fog_detail_spread);
    METHOD(double, get_volumetric_fog_detail_spread);
    METHOD(void, set_volumetric_fog_gi_inject);
    METHOD(double, get_volumetric_fog_gi_inject);
    METHOD(void, set_volumetric_fog_ambient_inject);
    METHOD(double, get_volumetric_fog_ambient_inject);
    METHOD(void, set_volumetric_fog_sky_affect);
    METHOD(double, get_volumetric_fog_sky_affect);
    METHOD(void, set_volumetric_fog_temporal_reprojection_enabled);
    METHOD(bool, is_volumetric_fog_temporal_reprojection_enabled);
    METHOD(void, set_volumetric_fog_temporal_reprojection_amount);
    METHOD(double, get_volumetric_fog_temporal_reprojection_amount);
    METHOD(void, set_adjustment_enabled);
    METHOD(bool, is_adjustment_enabled);
    METHOD(void, set_adjustment_brightness);
    METHOD(double, get_adjustment_brightness);
    METHOD(void, set_adjustment_contrast);
    METHOD(double, get_adjustment_contrast);
    METHOD(void, set_adjustment_saturation);
    METHOD(double, get_adjustment_saturation);
    METHOD(void, set_adjustment_color_correction);
    METHOD(Object, get_adjustment_color_correction);
    static constexpr int64_t BG_CLEAR_COLOR = 0;
    static constexpr int64_t BG_COLOR = 1;
    static constexpr int64_t BG_SKY = 2;
    static constexpr int64_t BG_CANVAS = 3;
    static constexpr int64_t BG_KEEP = 4;
    static constexpr int64_t BG_CAMERA_FEED = 5;
    static constexpr int64_t BG_MAX = 6;
    static constexpr int64_t AMBIENT_SOURCE_BG = 0;
    static constexpr int64_t AMBIENT_SOURCE_DISABLED = 1;
    static constexpr int64_t AMBIENT_SOURCE_COLOR = 2;
    static constexpr int64_t AMBIENT_SOURCE_SKY = 3;
    static constexpr int64_t REFLECTION_SOURCE_BG = 0;
    static constexpr int64_t REFLECTION_SOURCE_DISABLED = 1;
    static constexpr int64_t REFLECTION_SOURCE_SKY = 2;
    static constexpr int64_t TONE_MAPPER_LINEAR = 0;
    static constexpr int64_t TONE_MAPPER_REINHARDT = 1;
    static constexpr int64_t TONE_MAPPER_FILMIC = 2;
    static constexpr int64_t TONE_MAPPER_ACES = 3;
    static constexpr int64_t GLOW_BLEND_MODE_ADDITIVE = 0;
    static constexpr int64_t GLOW_BLEND_MODE_SCREEN = 1;
    static constexpr int64_t GLOW_BLEND_MODE_SOFTLIGHT = 2;
    static constexpr int64_t GLOW_BLEND_MODE_REPLACE = 3;
    static constexpr int64_t GLOW_BLEND_MODE_MIX = 4;
    static constexpr int64_t FOG_MODE_EXPONENTIAL = 0;
    static constexpr int64_t FOG_MODE_DEPTH = 1;
    static constexpr int64_t SDFGI_Y_SCALE_50_PERCENT = 0;
    static constexpr int64_t SDFGI_Y_SCALE_75_PERCENT = 1;
    static constexpr int64_t SDFGI_Y_SCALE_100_PERCENT = 2;
};
struct Font : public Resource {
    using Resource::Resource;
    PROPERTY(fallbacks, Array);
    METHOD(void, set_fallbacks);
    METHOD(Array, get_fallbacks);
    METHOD(::RID, find_variation);
    METHOD(Array, get_rids);
    METHOD(double, get_height);
    METHOD(double, get_ascent);
    METHOD(double, get_descent);
    METHOD(double, get_underline_position);
    METHOD(double, get_underline_thickness);
    METHOD(String, get_font_name);
    METHOD(String, get_font_style_name);
    METHOD(Dictionary, get_ot_name_strings);
    METHOD(int64_t, get_font_style);
    METHOD(int64_t, get_font_weight);
    METHOD(int64_t, get_font_stretch);
    METHOD(int64_t, get_spacing);
    METHOD(Dictionary, get_opentype_features);
    METHOD(void, set_cache_capacity);
    METHOD(Vector2, get_string_size);
    METHOD(Vector2, get_multiline_string_size);
    METHOD(Variant, draw_string);
    METHOD(Variant, draw_multiline_string);
    METHOD(Variant, draw_string_outline);
    METHOD(Variant, draw_multiline_string_outline);
    METHOD(Vector2, get_char_size);
    METHOD(double, draw_char);
    METHOD(double, draw_char_outline);
    METHOD(bool, has_char);
    METHOD(String, get_supported_chars);
    METHOD(bool, is_language_supported);
    METHOD(bool, is_script_supported);
    METHOD(Dictionary, get_supported_feature_list);
    METHOD(Dictionary, get_supported_variation_list);
    METHOD(int64_t, get_face_count);
};
struct GDExtension : public Resource {
    using Resource::Resource;
    METHOD(bool, is_library_open);
    METHOD(int64_t, get_minimum_library_initialization_level);
    static constexpr int64_t INITIALIZATION_LEVEL_CORE = 0;
    static constexpr int64_t INITIALIZATION_LEVEL_SERVERS = 1;
    static constexpr int64_t INITIALIZATION_LEVEL_SCENE = 2;
    static constexpr int64_t INITIALIZATION_LEVEL_EDITOR = 3;
};
struct GLTFAccessor : public Resource {
    using Resource::Resource;
    PROPERTY(buffer_view, int64_t);
    PROPERTY(byte_offset, int64_t);
    PROPERTY(component_type, int64_t);
    PROPERTY(normalized, bool);
    PROPERTY(count, int64_t);
    PROPERTY(accessor_type, int64_t);
    PROPERTY(type, int64_t);
    PROPERTY(min, PackedArray<double>);
    PROPERTY(max, PackedArray<double>);
    PROPERTY(sparse_count, int64_t);
    PROPERTY(sparse_indices_buffer_view, int64_t);
    PROPERTY(sparse_indices_byte_offset, int64_t);
    PROPERTY(sparse_indices_component_type, int64_t);
    PROPERTY(sparse_values_buffer_view, int64_t);
    PROPERTY(sparse_values_byte_offset, int64_t);
    METHOD(int64_t, get_buffer_view);
    METHOD(void, set_buffer_view);
    METHOD(int64_t, get_byte_offset);
    METHOD(void, set_byte_offset);
    METHOD(int64_t, get_component_type);
    METHOD(void, set_component_type);
    METHOD(bool, get_normalized);
    METHOD(void, set_normalized);
    METHOD(int64_t, get_count);
    METHOD(void, set_count);
    METHOD(int64_t, get_accessor_type);
    METHOD(void, set_accessor_type);
    METHOD(int64_t, get_type);
    METHOD(void, set_type);
    METHOD(PackedArray<double>, get_min);
    METHOD(void, set_min);
    METHOD(PackedArray<double>, get_max);
    METHOD(void, set_max);
    METHOD(int64_t, get_sparse_count);
    METHOD(void, set_sparse_count);
    METHOD(int64_t, get_sparse_indices_buffer_view);
    METHOD(void, set_sparse_indices_buffer_view);
    METHOD(int64_t, get_sparse_indices_byte_offset);
    METHOD(void, set_sparse_indices_byte_offset);
    METHOD(int64_t, get_sparse_indices_component_type);
    METHOD(void, set_sparse_indices_component_type);
    METHOD(int64_t, get_sparse_values_buffer_view);
    METHOD(void, set_sparse_values_buffer_view);
    METHOD(int64_t, get_sparse_values_byte_offset);
    METHOD(void, set_sparse_values_byte_offset);
    static constexpr int64_t TYPE_SCALAR = 0;
    static constexpr int64_t TYPE_VEC2 = 1;
    static constexpr int64_t TYPE_VEC3 = 2;
    static constexpr int64_t TYPE_VEC4 = 3;
    static constexpr int64_t TYPE_MAT2 = 4;
    static constexpr int64_t TYPE_MAT3 = 5;
    static constexpr int64_t TYPE_MAT4 = 6;
};
struct GLTFAnimation : public Resource {
    using Resource::Resource;
    PROPERTY(original_name, String);
    PROPERTY(loop, bool);
    METHOD(String, get_original_name);
    METHOD(void, set_original_name);
    METHOD(bool, get_loop);
    METHOD(void, set_loop);
    METHOD(Variant, get_additional_data);
    METHOD(void, set_additional_data);
};
struct GLTFBufferView : public Resource {
    using Resource::Resource;
    PROPERTY(buffer, int64_t);
    PROPERTY(byte_offset, int64_t);
    PROPERTY(byte_length, int64_t);
    PROPERTY(byte_stride, int64_t);
    PROPERTY(indices, bool);
    PROPERTY(vertex_attributes, bool);
    METHOD(PackedArray<uint8_t>, load_buffer_view_data);
    METHOD(int64_t, get_buffer);
    METHOD(void, set_buffer);
    METHOD(int64_t, get_byte_offset);
    METHOD(void, set_byte_offset);
    METHOD(int64_t, get_byte_length);
    METHOD(void, set_byte_length);
    METHOD(int64_t, get_byte_stride);
    METHOD(void, set_byte_stride);
    METHOD(bool, get_indices);
    METHOD(void, set_indices);
    METHOD(bool, get_vertex_attributes);
    METHOD(void, set_vertex_attributes);
};
struct GLTFCamera : public Resource {
    using Resource::Resource;
    PROPERTY(perspective, bool);
    PROPERTY(fov, double);
    PROPERTY(size_mag, double);
    PROPERTY(depth_far, double);
    PROPERTY(depth_near, double);
    METHOD(Object, from_node);
    METHOD(Object, to_node);
    METHOD(Object, from_dictionary);
    METHOD(Dictionary, to_dictionary);
    METHOD(bool, get_perspective);
    METHOD(void, set_perspective);
    METHOD(double, get_fov);
    METHOD(void, set_fov);
    METHOD(double, get_size_mag);
    METHOD(void, set_size_mag);
    METHOD(double, get_depth_far);
    METHOD(void, set_depth_far);
    METHOD(double, get_depth_near);
    METHOD(void, set_depth_near);
};
struct GLTFDocument : public Resource {
    using Resource::Resource;
    PROPERTY(image_format, String);
    PROPERTY(lossy_quality, double);
    PROPERTY(root_node_mode, int64_t);
    METHOD(void, set_image_format);
    METHOD(String, get_image_format);
    METHOD(void, set_lossy_quality);
    METHOD(double, get_lossy_quality);
    METHOD(void, set_root_node_mode);
    METHOD(int64_t, get_root_node_mode);
    METHOD(int64_t, append_from_file);
    METHOD(int64_t, append_from_buffer);
    METHOD(int64_t, append_from_scene);
    METHOD(Object, generate_scene);
    METHOD(PackedArray<uint8_t>, generate_buffer);
    METHOD(int64_t, write_to_filesystem);
    METHOD(Variant, register_gltf_document_extension);
    METHOD(Variant, unregister_gltf_document_extension);
    static constexpr int64_t ROOT_NODE_MODE_SINGLE_ROOT = 0;
    static constexpr int64_t ROOT_NODE_MODE_KEEP_ROOT = 1;
    static constexpr int64_t ROOT_NODE_MODE_MULTI_ROOT = 2;
};
struct GLTFDocumentExtension : public Resource {
    using Resource::Resource;
    METHOD(int64_t, _import_preflight);
    METHOD(PackedArray<std::string>, _get_supported_extensions);
    METHOD(int64_t, _parse_node_extensions);
    METHOD(int64_t, _parse_image_data);
    METHOD(String, _get_image_file_extension);
    METHOD(int64_t, _parse_texture_json);
    METHOD(Object, _generate_scene_node);
    METHOD(int64_t, _import_post_parse);
    METHOD(int64_t, _import_node);
    METHOD(int64_t, _import_post);
    METHOD(int64_t, _export_preflight);
    METHOD(Variant, _convert_scene_node);
    METHOD(int64_t, _export_preserialize);
    METHOD(PackedArray<std::string>, _get_saveable_image_formats);
    METHOD(PackedArray<uint8_t>, _serialize_image_to_bytes);
    METHOD(int64_t, _save_image_at_path);
    METHOD(int64_t, _serialize_texture_json);
    METHOD(int64_t, _export_node);
    METHOD(int64_t, _export_post);
};
struct GLTFLight : public Resource {
    using Resource::Resource;
    PROPERTY(color, Color);
    PROPERTY(intensity, double);
    PROPERTY(light_type, String);
    PROPERTY(range, double);
    PROPERTY(inner_cone_angle, double);
    PROPERTY(outer_cone_angle, double);
    METHOD(Object, from_node);
    METHOD(Object, to_node);
    METHOD(Object, from_dictionary);
    METHOD(Dictionary, to_dictionary);
    METHOD(Color, get_color);
    METHOD(void, set_color);
    METHOD(double, get_intensity);
    METHOD(void, set_intensity);
    METHOD(String, get_light_type);
    METHOD(void, set_light_type);
    METHOD(double, get_range);
    METHOD(void, set_range);
    METHOD(double, get_inner_cone_angle);
    METHOD(void, set_inner_cone_angle);
    METHOD(double, get_outer_cone_angle);
    METHOD(void, set_outer_cone_angle);
    METHOD(Variant, get_additional_data);
    METHOD(void, set_additional_data);
};
struct GLTFMesh : public Resource {
    using Resource::Resource;
    PROPERTY(original_name, String);
    PROPERTY(mesh, Object);
    PROPERTY(blend_weights, PackedArray<float>);
    PROPERTY(instance_materials, Array);
    METHOD(String, get_original_name);
    METHOD(void, set_original_name);
    METHOD(Object, get_mesh);
    METHOD(void, set_mesh);
    METHOD(PackedArray<float>, get_blend_weights);
    METHOD(void, set_blend_weights);
    METHOD(Array, get_instance_materials);
    METHOD(void, set_instance_materials);
    METHOD(Variant, get_additional_data);
    METHOD(void, set_additional_data);
};
struct GLTFNode : public Resource {
    using Resource::Resource;
    PROPERTY(original_name, String);
    PROPERTY(parent, int64_t);
    PROPERTY(height, int64_t);
    PROPERTY(xform, Transform3D);
    PROPERTY(mesh, int64_t);
    PROPERTY(camera, int64_t);
    PROPERTY(skin, int64_t);
    PROPERTY(skeleton, int64_t);
    PROPERTY(position, Vector3);
    PROPERTY(rotation, Quaternion);
    PROPERTY(scale, Vector3);
    PROPERTY(children, PackedArray<int32_t>);
    PROPERTY(light, int64_t);
    METHOD(String, get_original_name);
    METHOD(void, set_original_name);
    METHOD(int64_t, get_parent);
    METHOD(void, set_parent);
    METHOD(int64_t, get_height);
    METHOD(void, set_height);
    METHOD(Transform3D, get_xform);
    METHOD(void, set_xform);
    METHOD(int64_t, get_mesh);
    METHOD(void, set_mesh);
    METHOD(int64_t, get_camera);
    METHOD(void, set_camera);
    METHOD(int64_t, get_skin);
    METHOD(void, set_skin);
    METHOD(int64_t, get_skeleton);
    METHOD(void, set_skeleton);
    METHOD(Vector3, get_position);
    METHOD(void, set_position);
    METHOD(Quaternion, get_rotation);
    METHOD(void, set_rotation);
    METHOD(Vector3, get_scale);
    METHOD(void, set_scale);
    METHOD(PackedArray<int32_t>, get_children);
    METHOD(void, set_children);
    METHOD(int64_t, get_light);
    METHOD(void, set_light);
    METHOD(Variant, get_additional_data);
    METHOD(void, set_additional_data);
};
struct GLTFPhysicsBody : public Resource {
    using Resource::Resource;
    PROPERTY(body_type, String);
    PROPERTY(mass, double);
    PROPERTY(linear_velocity, Vector3);
    PROPERTY(angular_velocity, Vector3);
    PROPERTY(center_of_mass, Vector3);
    PROPERTY(inertia_diagonal, Vector3);
    PROPERTY(inertia_orientation, Quaternion);
    PROPERTY(inertia_tensor, Basis);
    METHOD(Object, from_node);
    METHOD(Object, to_node);
    METHOD(Object, from_dictionary);
    METHOD(Dictionary, to_dictionary);
    METHOD(String, get_body_type);
    METHOD(void, set_body_type);
    METHOD(double, get_mass);
    METHOD(void, set_mass);
    METHOD(Vector3, get_linear_velocity);
    METHOD(void, set_linear_velocity);
    METHOD(Vector3, get_angular_velocity);
    METHOD(void, set_angular_velocity);
    METHOD(Vector3, get_center_of_mass);
    METHOD(void, set_center_of_mass);
    METHOD(Vector3, get_inertia_diagonal);
    METHOD(void, set_inertia_diagonal);
    METHOD(Quaternion, get_inertia_orientation);
    METHOD(void, set_inertia_orientation);
    METHOD(Basis, get_inertia_tensor);
    METHOD(void, set_inertia_tensor);
};
struct GLTFPhysicsShape : public Resource {
    using Resource::Resource;
    PROPERTY(shape_type, String);
    PROPERTY(size, Vector3);
    PROPERTY(radius, double);
    PROPERTY(height, double);
    PROPERTY(is_trigger, bool);
    PROPERTY(mesh_index, int64_t);
    PROPERTY(importer_mesh, Object);
    METHOD(Object, from_node);
    METHOD(Object, to_node);
    METHOD(Object, from_resource);
    METHOD(Object, to_resource);
    METHOD(Object, from_dictionary);
    METHOD(Dictionary, to_dictionary);
    METHOD(String, get_shape_type);
    METHOD(void, set_shape_type);
    METHOD(Vector3, get_size);
    METHOD(void, set_size);
    METHOD(double, get_radius);
    METHOD(void, set_radius);
    METHOD(double, get_height);
    METHOD(void, set_height);
    METHOD(bool, get_is_trigger);
    METHOD(void, set_is_trigger);
    METHOD(int64_t, get_mesh_index);
    METHOD(void, set_mesh_index);
    METHOD(Object, get_importer_mesh);
    METHOD(void, set_importer_mesh);
};
struct GLTFSkeleton : public Resource {
    using Resource::Resource;
    PROPERTY(joints, PackedArray<int32_t>);
    PROPERTY(roots, PackedArray<int32_t>);
    PROPERTY(unique_names, Array);
    PROPERTY(godot_bone_node, Dictionary);
    METHOD(PackedArray<int32_t>, get_joints);
    METHOD(void, set_joints);
    METHOD(PackedArray<int32_t>, get_roots);
    METHOD(void, set_roots);
    METHOD(Object, get_godot_skeleton);
    METHOD(Array, get_unique_names);
    METHOD(void, set_unique_names);
    METHOD(Dictionary, get_godot_bone_node);
    METHOD(void, set_godot_bone_node);
    METHOD(int64_t, get_bone_attachment_count);
    METHOD(Object, get_bone_attachment);
};
struct GLTFSkin : public Resource {
    using Resource::Resource;
    PROPERTY(skin_root, int64_t);
    PROPERTY(joints_original, PackedArray<int32_t>);
    PROPERTY(inverse_binds, Array);
    PROPERTY(joints, PackedArray<int32_t>);
    PROPERTY(non_joints, PackedArray<int32_t>);
    PROPERTY(roots, PackedArray<int32_t>);
    PROPERTY(skeleton, int64_t);
    PROPERTY(joint_i_to_bone_i, Dictionary);
    PROPERTY(joint_i_to_name, Dictionary);
    PROPERTY(godot_skin, Object);
    METHOD(int64_t, get_skin_root);
    METHOD(void, set_skin_root);
    METHOD(PackedArray<int32_t>, get_joints_original);
    METHOD(void, set_joints_original);
    METHOD(Array, get_inverse_binds);
    METHOD(void, set_inverse_binds);
    METHOD(PackedArray<int32_t>, get_joints);
    METHOD(void, set_joints);
    METHOD(PackedArray<int32_t>, get_non_joints);
    METHOD(void, set_non_joints);
    METHOD(PackedArray<int32_t>, get_roots);
    METHOD(void, set_roots);
    METHOD(int64_t, get_skeleton);
    METHOD(void, set_skeleton);
    METHOD(Dictionary, get_joint_i_to_bone_i);
    METHOD(void, set_joint_i_to_bone_i);
    METHOD(Dictionary, get_joint_i_to_name);
    METHOD(void, set_joint_i_to_name);
    METHOD(Object, get_godot_skin);
    METHOD(void, set_godot_skin);
};
struct GLTFSpecGloss : public Resource {
    using Resource::Resource;
    PROPERTY(diffuse_img, Object);
    PROPERTY(diffuse_factor, Color);
    PROPERTY(gloss_factor, double);
    PROPERTY(specular_factor, Color);
    PROPERTY(spec_gloss_img, Object);
    METHOD(Object, get_diffuse_img);
    METHOD(void, set_diffuse_img);
    METHOD(Color, get_diffuse_factor);
    METHOD(void, set_diffuse_factor);
    METHOD(double, get_gloss_factor);
    METHOD(void, set_gloss_factor);
    METHOD(Color, get_specular_factor);
    METHOD(void, set_specular_factor);
    METHOD(Object, get_spec_gloss_img);
    METHOD(void, set_spec_gloss_img);
};
struct GLTFState : public Resource {
    using Resource::Resource;
    PROPERTY(json, Dictionary);
    PROPERTY(major_version, int64_t);
    PROPERTY(minor_version, int64_t);
    PROPERTY(copyright, String);
    PROPERTY(glb_data, PackedArray<uint8_t>);
    PROPERTY(use_named_skin_binds, bool);
    PROPERTY(nodes, Array);
    PROPERTY(buffers, Array);
    PROPERTY(buffer_views, Array);
    PROPERTY(accessors, Array);
    PROPERTY(meshes, Array);
    PROPERTY(materials, Array);
    PROPERTY(scene_name, String);
    PROPERTY(base_path, String);
    PROPERTY(filename, String);
    PROPERTY(root_nodes, PackedArray<int32_t>);
    PROPERTY(textures, Array);
    PROPERTY(texture_samplers, Array);
    PROPERTY(images, Array);
    PROPERTY(skins, Array);
    PROPERTY(cameras, Array);
    PROPERTY(lights, Array);
    PROPERTY(unique_names, Array);
    PROPERTY(unique_animation_names, Array);
    PROPERTY(skeletons, Array);
    PROPERTY(create_animations, bool);
    PROPERTY(import_as_skeleton_bones, bool);
    PROPERTY(animations, Array);
    PROPERTY(handle_binary_image, int64_t);
    PROPERTY(bake_fps, double);
    METHOD(Variant, add_used_extension);
    METHOD(int64_t, append_data_to_buffers);
    METHOD(Dictionary, get_json);
    METHOD(void, set_json);
    METHOD(int64_t, get_major_version);
    METHOD(void, set_major_version);
    METHOD(int64_t, get_minor_version);
    METHOD(void, set_minor_version);
    METHOD(String, get_copyright);
    METHOD(void, set_copyright);
    METHOD(PackedArray<uint8_t>, get_glb_data);
    METHOD(void, set_glb_data);
    METHOD(bool, get_use_named_skin_binds);
    METHOD(void, set_use_named_skin_binds);
    METHOD(Array, get_nodes);
    METHOD(void, set_nodes);
    METHOD(Array, get_buffers);
    METHOD(void, set_buffers);
    METHOD(Array, get_buffer_views);
    METHOD(void, set_buffer_views);
    METHOD(Array, get_accessors);
    METHOD(void, set_accessors);
    METHOD(Array, get_meshes);
    METHOD(void, set_meshes);
    METHOD(int64_t, get_animation_players_count);
    METHOD(Object, get_animation_player);
    METHOD(Array, get_materials);
    METHOD(void, set_materials);
    METHOD(String, get_scene_name);
    METHOD(void, set_scene_name);
    METHOD(String, get_base_path);
    METHOD(void, set_base_path);
    METHOD(String, get_filename);
    METHOD(void, set_filename);
    METHOD(PackedArray<int32_t>, get_root_nodes);
    METHOD(void, set_root_nodes);
    METHOD(Array, get_textures);
    METHOD(void, set_textures);
    METHOD(Array, get_texture_samplers);
    METHOD(void, set_texture_samplers);
    METHOD(Array, get_images);
    METHOD(void, set_images);
    METHOD(Array, get_skins);
    METHOD(void, set_skins);
    METHOD(Array, get_cameras);
    METHOD(void, set_cameras);
    METHOD(Array, get_lights);
    METHOD(void, set_lights);
    METHOD(Array, get_unique_names);
    METHOD(void, set_unique_names);
    METHOD(Array, get_unique_animation_names);
    METHOD(void, set_unique_animation_names);
    METHOD(Array, get_skeletons);
    METHOD(void, set_skeletons);
    METHOD(bool, get_create_animations);
    METHOD(void, set_create_animations);
    METHOD(bool, get_import_as_skeleton_bones);
    METHOD(void, set_import_as_skeleton_bones);
    METHOD(Array, get_animations);
    METHOD(void, set_animations);
    METHOD(Object, get_scene_node);
    METHOD(int64_t, get_node_index);
    METHOD(Variant, get_additional_data);
    METHOD(void, set_additional_data);
    METHOD(int64_t, get_handle_binary_image);
    METHOD(void, set_handle_binary_image);
    METHOD(void, set_bake_fps);
    METHOD(double, get_bake_fps);
    static constexpr int64_t HANDLE_BINARY_DISCARD_TEXTURES = 0;
    static constexpr int64_t HANDLE_BINARY_EXTRACT_TEXTURES = 1;
    static constexpr int64_t HANDLE_BINARY_EMBED_AS_BASISU = 2;
    static constexpr int64_t HANDLE_BINARY_EMBED_AS_UNCOMPRESSED = 3;
};
struct GLTFTexture : public Resource {
    using Resource::Resource;
    PROPERTY(src_image, int64_t);
    PROPERTY(sampler, int64_t);
    METHOD(int64_t, get_src_image);
    METHOD(void, set_src_image);
    METHOD(int64_t, get_sampler);
    METHOD(void, set_sampler);
};
struct GLTFTextureSampler : public Resource {
    using Resource::Resource;
    PROPERTY(mag_filter, int64_t);
    PROPERTY(min_filter, int64_t);
    PROPERTY(wrap_s, int64_t);
    PROPERTY(wrap_t, int64_t);
    METHOD(int64_t, get_mag_filter);
    METHOD(void, set_mag_filter);
    METHOD(int64_t, get_min_filter);
    METHOD(void, set_min_filter);
    METHOD(int64_t, get_wrap_s);
    METHOD(void, set_wrap_s);
    METHOD(int64_t, get_wrap_t);
    METHOD(void, set_wrap_t);
};
struct Gradient : public Resource {
    using Resource::Resource;
    PROPERTY(interpolation_mode, int64_t);
    PROPERTY(interpolation_color_space, int64_t);
    PROPERTY(offsets, PackedArray<float>);
    PROPERTY(colors, PackedArray<Color>);
    METHOD(Variant, add_point);
    METHOD(Variant, remove_point);
    METHOD(void, set_offset);
    METHOD(double, get_offset);
    METHOD(Variant, reverse);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(Color, sample);
    METHOD(int64_t, get_point_count);
    METHOD(void, set_offsets);
    METHOD(PackedArray<float>, get_offsets);
    METHOD(void, set_colors);
    METHOD(PackedArray<Color>, get_colors);
    METHOD(void, set_interpolation_mode);
    METHOD(int64_t, get_interpolation_mode);
    METHOD(void, set_interpolation_color_space);
    METHOD(int64_t, get_interpolation_color_space);
    static constexpr int64_t GRADIENT_INTERPOLATE_LINEAR = 0;
    static constexpr int64_t GRADIENT_INTERPOLATE_CONSTANT = 1;
    static constexpr int64_t GRADIENT_INTERPOLATE_CUBIC = 2;
    static constexpr int64_t GRADIENT_COLOR_SPACE_SRGB = 0;
    static constexpr int64_t GRADIENT_COLOR_SPACE_LINEAR_SRGB = 1;
    static constexpr int64_t GRADIENT_COLOR_SPACE_OKLAB = 2;
};
struct Image : public Resource {
    using Resource::Resource;
    PROPERTY(data, Dictionary);
    METHOD(int64_t, get_width);
    METHOD(int64_t, get_height);
    METHOD(Vector2i, get_size);
    METHOD(bool, has_mipmaps);
    METHOD(int64_t, get_format);
    METHOD(PackedArray<uint8_t>, get_data);
    METHOD(int64_t, get_data_size);
    METHOD(Variant, convert);
    METHOD(int64_t, get_mipmap_count);
    METHOD(int64_t, get_mipmap_offset);
    METHOD(Variant, resize_to_po2);
    METHOD(Variant, resize);
    METHOD(Variant, shrink_x2);
    METHOD(Variant, crop);
    METHOD(Variant, flip_x);
    METHOD(Variant, flip_y);
    METHOD(int64_t, generate_mipmaps);
    METHOD(Variant, clear_mipmaps);
    METHOD(Object, create);
    METHOD(Object, create_empty);
    METHOD(Object, create_from_data);
    METHOD(void, set_data);
    METHOD(bool, is_empty);
    METHOD(int64_t, load);
    METHOD(Object, load_from_file);
    METHOD(int64_t, save_png);
    METHOD(PackedArray<uint8_t>, save_png_to_buffer);
    METHOD(int64_t, save_jpg);
    METHOD(PackedArray<uint8_t>, save_jpg_to_buffer);
    METHOD(int64_t, save_exr);
    METHOD(PackedArray<uint8_t>, save_exr_to_buffer);
    METHOD(int64_t, save_webp);
    METHOD(PackedArray<uint8_t>, save_webp_to_buffer);
    METHOD(int64_t, detect_alpha);
    METHOD(bool, is_invisible);
    METHOD(int64_t, detect_used_channels);
    METHOD(int64_t, compress);
    METHOD(int64_t, compress_from_channels);
    METHOD(int64_t, decompress);
    METHOD(bool, is_compressed);
    METHOD(Variant, rotate_90);
    METHOD(Variant, rotate_180);
    METHOD(Variant, fix_alpha_edges);
    METHOD(Variant, premultiply_alpha);
    METHOD(Variant, srgb_to_linear);
    METHOD(Variant, normal_map_to_xy);
    METHOD(Object, rgbe_to_srgb);
    METHOD(Variant, bump_map_to_normal_map);
    METHOD(Dictionary, compute_image_metrics);
    METHOD(Variant, blit_rect);
    METHOD(Variant, blit_rect_mask);
    METHOD(Variant, blend_rect);
    METHOD(Variant, blend_rect_mask);
    METHOD(Variant, fill);
    METHOD(Variant, fill_rect);
    METHOD(Rect2i, get_used_rect);
    METHOD(Object, get_region);
    METHOD(Variant, copy_from);
    METHOD(Variant, _set_data);
    METHOD(Dictionary, _get_data);
    METHOD(Color, get_pixelv);
    METHOD(Color, get_pixel);
    METHOD(void, set_pixelv);
    METHOD(void, set_pixel);
    METHOD(Variant, adjust_bcs);
    METHOD(int64_t, load_png_from_buffer);
    METHOD(int64_t, load_jpg_from_buffer);
    METHOD(int64_t, load_webp_from_buffer);
    METHOD(int64_t, load_tga_from_buffer);
    METHOD(int64_t, load_bmp_from_buffer);
    METHOD(int64_t, load_ktx_from_buffer);
    METHOD(int64_t, load_svg_from_buffer);
    METHOD(int64_t, load_svg_from_string);
    static constexpr int64_t MAX_WIDTH = 16777216;
    static constexpr int64_t MAX_HEIGHT = 16777216;
    static constexpr int64_t FORMAT_L8 = 0;
    static constexpr int64_t FORMAT_LA8 = 1;
    static constexpr int64_t FORMAT_R8 = 2;
    static constexpr int64_t FORMAT_RG8 = 3;
    static constexpr int64_t FORMAT_RGB8 = 4;
    static constexpr int64_t FORMAT_RGBA8 = 5;
    static constexpr int64_t FORMAT_RGBA4444 = 6;
    static constexpr int64_t FORMAT_RGB565 = 7;
    static constexpr int64_t FORMAT_RF = 8;
    static constexpr int64_t FORMAT_RGF = 9;
    static constexpr int64_t FORMAT_RGBF = 10;
    static constexpr int64_t FORMAT_RGBAF = 11;
    static constexpr int64_t FORMAT_RH = 12;
    static constexpr int64_t FORMAT_RGH = 13;
    static constexpr int64_t FORMAT_RGBH = 14;
    static constexpr int64_t FORMAT_RGBAH = 15;
    static constexpr int64_t FORMAT_RGBE9995 = 16;
    static constexpr int64_t FORMAT_DXT1 = 17;
    static constexpr int64_t FORMAT_DXT3 = 18;
    static constexpr int64_t FORMAT_DXT5 = 19;
    static constexpr int64_t FORMAT_RGTC_R = 20;
    static constexpr int64_t FORMAT_RGTC_RG = 21;
    static constexpr int64_t FORMAT_BPTC_RGBA = 22;
    static constexpr int64_t FORMAT_BPTC_RGBF = 23;
    static constexpr int64_t FORMAT_BPTC_RGBFU = 24;
    static constexpr int64_t FORMAT_ETC = 25;
    static constexpr int64_t FORMAT_ETC2_R11 = 26;
    static constexpr int64_t FORMAT_ETC2_R11S = 27;
    static constexpr int64_t FORMAT_ETC2_RG11 = 28;
    static constexpr int64_t FORMAT_ETC2_RG11S = 29;
    static constexpr int64_t FORMAT_ETC2_RGB8 = 30;
    static constexpr int64_t FORMAT_ETC2_RGBA8 = 31;
    static constexpr int64_t FORMAT_ETC2_RGB8A1 = 32;
    static constexpr int64_t FORMAT_ETC2_RA_AS_RG = 33;
    static constexpr int64_t FORMAT_DXT5_RA_AS_RG = 34;
    static constexpr int64_t FORMAT_ASTC_4x4 = 35;
    static constexpr int64_t FORMAT_ASTC_4x4_HDR = 36;
    static constexpr int64_t FORMAT_ASTC_8x8 = 37;
    static constexpr int64_t FORMAT_ASTC_8x8_HDR = 38;
    static constexpr int64_t FORMAT_MAX = 39;
    static constexpr int64_t INTERPOLATE_NEAREST = 0;
    static constexpr int64_t INTERPOLATE_BILINEAR = 1;
    static constexpr int64_t INTERPOLATE_CUBIC = 2;
    static constexpr int64_t INTERPOLATE_TRILINEAR = 3;
    static constexpr int64_t INTERPOLATE_LANCZOS = 4;
    static constexpr int64_t ALPHA_NONE = 0;
    static constexpr int64_t ALPHA_BIT = 1;
    static constexpr int64_t ALPHA_BLEND = 2;
    static constexpr int64_t COMPRESS_S3TC = 0;
    static constexpr int64_t COMPRESS_ETC = 1;
    static constexpr int64_t COMPRESS_ETC2 = 2;
    static constexpr int64_t COMPRESS_BPTC = 3;
    static constexpr int64_t COMPRESS_ASTC = 4;
    static constexpr int64_t COMPRESS_MAX = 5;
    static constexpr int64_t USED_CHANNELS_L = 0;
    static constexpr int64_t USED_CHANNELS_LA = 1;
    static constexpr int64_t USED_CHANNELS_R = 2;
    static constexpr int64_t USED_CHANNELS_RG = 3;
    static constexpr int64_t USED_CHANNELS_RGB = 4;
    static constexpr int64_t USED_CHANNELS_RGBA = 5;
    static constexpr int64_t COMPRESS_SOURCE_GENERIC = 0;
    static constexpr int64_t COMPRESS_SOURCE_SRGB = 1;
    static constexpr int64_t COMPRESS_SOURCE_NORMAL = 2;
    static constexpr int64_t ASTC_FORMAT_4x4 = 0;
    static constexpr int64_t ASTC_FORMAT_8x8 = 1;
};
struct ImporterMesh : public Resource {
    using Resource::Resource;
    PROPERTY(_data, Dictionary);
    METHOD(Variant, add_blend_shape);
    METHOD(int64_t, get_blend_shape_count);
    METHOD(String, get_blend_shape_name);
    METHOD(void, set_blend_shape_mode);
    METHOD(int64_t, get_blend_shape_mode);
    METHOD(Variant, add_surface);
    METHOD(int64_t, get_surface_count);
    METHOD(int64_t, get_surface_primitive_type);
    METHOD(String, get_surface_name);
    METHOD(Array, get_surface_arrays);
    METHOD(Array, get_surface_blend_shape_arrays);
    METHOD(int64_t, get_surface_lod_count);
    METHOD(double, get_surface_lod_size);
    METHOD(PackedArray<int32_t>, get_surface_lod_indices);
    METHOD(Object, get_surface_material);
    METHOD(int64_t, get_surface_format);
    METHOD(void, set_surface_name);
    METHOD(void, set_surface_material);
    METHOD(Variant, generate_lods);
    METHOD(Object, get_mesh);
    METHOD(Variant, clear);
    METHOD(Variant, _set_data);
    METHOD(Dictionary, _get_data);
    METHOD(void, set_lightmap_size_hint);
    METHOD(Vector2i, get_lightmap_size_hint);
};
struct InputEvent : public Resource {
    using Resource::Resource;
    PROPERTY(device, int64_t);
    METHOD(void, set_device);
    METHOD(int64_t, get_device);
    METHOD(bool, is_action);
    METHOD(bool, is_action_pressed);
    METHOD(bool, is_action_released);
    METHOD(double, get_action_strength);
    METHOD(bool, is_canceled);
    METHOD(bool, is_pressed);
    METHOD(bool, is_released);
    METHOD(bool, is_echo);
    METHOD(String, as_text);
    METHOD(bool, is_match);
    METHOD(bool, is_action_type);
    METHOD(bool, accumulate);
    METHOD(Object, xformed_by);
    static constexpr int64_t DEVICE_ID_EMULATION = -1;
};
struct JSON : public Resource {
    using Resource::Resource;
    METHOD(String, stringify);
    METHOD(Variant, parse_string);
    METHOD(int64_t, parse);
    METHOD(Variant, get_data);
    METHOD(void, set_data);
    METHOD(String, get_parsed_text);
    METHOD(int64_t, get_error_line);
    METHOD(String, get_error_message);
};
struct LabelSettings : public Resource {
    using Resource::Resource;
    PROPERTY(line_spacing, double);
    PROPERTY(font, Object);
    PROPERTY(font_size, int64_t);
    PROPERTY(font_color, Color);
    PROPERTY(outline_size, int64_t);
    PROPERTY(outline_color, Color);
    PROPERTY(shadow_size, int64_t);
    PROPERTY(shadow_color, Color);
    PROPERTY(shadow_offset, Vector2);
    METHOD(void, set_line_spacing);
    METHOD(double, get_line_spacing);
    METHOD(void, set_font);
    METHOD(Object, get_font);
    METHOD(void, set_font_size);
    METHOD(int64_t, get_font_size);
    METHOD(void, set_font_color);
    METHOD(Color, get_font_color);
    METHOD(void, set_outline_size);
    METHOD(int64_t, get_outline_size);
    METHOD(void, set_outline_color);
    METHOD(Color, get_outline_color);
    METHOD(void, set_shadow_size);
    METHOD(int64_t, get_shadow_size);
    METHOD(void, set_shadow_color);
    METHOD(Color, get_shadow_color);
    METHOD(void, set_shadow_offset);
    METHOD(Vector2, get_shadow_offset);
};
struct LightmapGIData : public Resource {
    using Resource::Resource;
    PROPERTY(lightmap_textures, Array);
    PROPERTY(uses_spherical_harmonics, bool);
    PROPERTY(user_data, Array);
    PROPERTY(probe_data, Dictionary);
    PROPERTY(light_texture, Object);
    PROPERTY(light_textures, Array);
    METHOD(Variant, _set_user_data);
    METHOD(Array, _get_user_data);
    METHOD(void, set_lightmap_textures);
    METHOD(Array, get_lightmap_textures);
    METHOD(void, set_uses_spherical_harmonics);
    METHOD(bool, is_using_spherical_harmonics);
    METHOD(Variant, add_user);
    METHOD(int64_t, get_user_count);
    METHOD(String, get_user_path);
    METHOD(Variant, clear_users);
    METHOD(Variant, _set_probe_data);
    METHOD(Dictionary, _get_probe_data);
    METHOD(void, set_light_texture);
    METHOD(Object, get_light_texture);
    METHOD(Variant, _set_light_textures_data);
    METHOD(Array, _get_light_textures_data);
};
struct Material : public Resource {
    using Resource::Resource;
    PROPERTY(render_priority, int64_t);
    PROPERTY(next_pass, Object);
    METHOD(::RID, _get_shader_rid);
    METHOD(int64_t, _get_shader_mode);
    METHOD(bool, _can_do_next_pass);
    METHOD(bool, _can_use_render_priority);
    METHOD(void, set_next_pass);
    METHOD(Object, get_next_pass);
    METHOD(void, set_render_priority);
    METHOD(int64_t, get_render_priority);
    METHOD(Variant, inspect_native_shader_code);
    METHOD(Object, create_placeholder);
    static constexpr int64_t RENDER_PRIORITY_MAX = 127;
    static constexpr int64_t RENDER_PRIORITY_MIN = -128;
};
struct Mesh : public Resource {
    using Resource::Resource;
    PROPERTY(lightmap_size_hint, Vector2i);
    METHOD(int64_t, _get_surface_count);
    METHOD(int64_t, _surface_get_array_len);
    METHOD(int64_t, _surface_get_array_index_len);
    METHOD(Array, _surface_get_arrays);
    METHOD(Array, _surface_get_blend_shape_arrays);
    METHOD(Dictionary, _surface_get_lods);
    METHOD(int64_t, _surface_get_format);
    METHOD(int64_t, _surface_get_primitive_type);
    METHOD(Variant, _surface_set_material);
    METHOD(Object, _surface_get_material);
    METHOD(int64_t, _get_blend_shape_count);
    METHOD(String, _get_blend_shape_name);
    METHOD(Variant, _set_blend_shape_name);
    METHOD(Variant, _get_aabb);
    METHOD(void, set_lightmap_size_hint);
    METHOD(Vector2i, get_lightmap_size_hint);
    METHOD(Variant, get_aabb);
    METHOD(PackedArray<Vector3>, get_faces);
    METHOD(int64_t, get_surface_count);
    METHOD(Array, surface_get_arrays);
    METHOD(Array, surface_get_blend_shape_arrays);
    METHOD(Variant, surface_set_material);
    METHOD(Object, surface_get_material);
    METHOD(Object, create_placeholder);
    METHOD(Object, create_trimesh_shape);
    METHOD(Object, create_convex_shape);
    METHOD(Object, create_outline);
    METHOD(Object, generate_triangle_mesh);
    static constexpr int64_t PRIMITIVE_POINTS = 0;
    static constexpr int64_t PRIMITIVE_LINES = 1;
    static constexpr int64_t PRIMITIVE_LINE_STRIP = 2;
    static constexpr int64_t PRIMITIVE_TRIANGLES = 3;
    static constexpr int64_t PRIMITIVE_TRIANGLE_STRIP = 4;
    static constexpr int64_t ARRAY_VERTEX = 0;
    static constexpr int64_t ARRAY_NORMAL = 1;
    static constexpr int64_t ARRAY_TANGENT = 2;
    static constexpr int64_t ARRAY_COLOR = 3;
    static constexpr int64_t ARRAY_TEX_UV = 4;
    static constexpr int64_t ARRAY_TEX_UV2 = 5;
    static constexpr int64_t ARRAY_CUSTOM0 = 6;
    static constexpr int64_t ARRAY_CUSTOM1 = 7;
    static constexpr int64_t ARRAY_CUSTOM2 = 8;
    static constexpr int64_t ARRAY_CUSTOM3 = 9;
    static constexpr int64_t ARRAY_BONES = 10;
    static constexpr int64_t ARRAY_WEIGHTS = 11;
    static constexpr int64_t ARRAY_INDEX = 12;
    static constexpr int64_t ARRAY_MAX = 13;
    static constexpr int64_t ARRAY_CUSTOM_RGBA8_UNORM = 0;
    static constexpr int64_t ARRAY_CUSTOM_RGBA8_SNORM = 1;
    static constexpr int64_t ARRAY_CUSTOM_RG_HALF = 2;
    static constexpr int64_t ARRAY_CUSTOM_RGBA_HALF = 3;
    static constexpr int64_t ARRAY_CUSTOM_R_FLOAT = 4;
    static constexpr int64_t ARRAY_CUSTOM_RG_FLOAT = 5;
    static constexpr int64_t ARRAY_CUSTOM_RGB_FLOAT = 6;
    static constexpr int64_t ARRAY_CUSTOM_RGBA_FLOAT = 7;
    static constexpr int64_t ARRAY_CUSTOM_MAX = 8;
    static constexpr int64_t ARRAY_FORMAT_VERTEX = 1;
    static constexpr int64_t ARRAY_FORMAT_NORMAL = 2;
    static constexpr int64_t ARRAY_FORMAT_TANGENT = 4;
    static constexpr int64_t ARRAY_FORMAT_COLOR = 8;
    static constexpr int64_t ARRAY_FORMAT_TEX_UV = 16;
    static constexpr int64_t ARRAY_FORMAT_TEX_UV2 = 32;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM0 = 64;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM1 = 128;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM2 = 256;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM3 = 512;
    static constexpr int64_t ARRAY_FORMAT_BONES = 1024;
    static constexpr int64_t ARRAY_FORMAT_WEIGHTS = 2048;
    static constexpr int64_t ARRAY_FORMAT_INDEX = 4096;
    static constexpr int64_t ARRAY_FORMAT_BLEND_SHAPE_MASK = 7;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM_BASE = 13;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM_BITS = 3;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM0_SHIFT = 13;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM1_SHIFT = 16;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM2_SHIFT = 19;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM3_SHIFT = 22;
    static constexpr int64_t ARRAY_FORMAT_CUSTOM_MASK = 7;
    static constexpr int64_t ARRAY_COMPRESS_FLAGS_BASE = 25;
    static constexpr int64_t ARRAY_FLAG_USE_2D_VERTICES = 33554432;
    static constexpr int64_t ARRAY_FLAG_USE_DYNAMIC_UPDATE = 67108864;
    static constexpr int64_t ARRAY_FLAG_USE_8_BONE_WEIGHTS = 134217728;
    static constexpr int64_t ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY = 268435456;
    static constexpr int64_t ARRAY_FLAG_COMPRESS_ATTRIBUTES = 536870912;
    static constexpr int64_t BLEND_SHAPE_MODE_NORMALIZED = 0;
    static constexpr int64_t BLEND_SHAPE_MODE_RELATIVE = 1;
};
struct MeshLibrary : public Resource {
    using Resource::Resource;
    METHOD(Variant, create_item);
    METHOD(void, set_item_name);
    METHOD(void, set_item_mesh);
    METHOD(void, set_item_mesh_transform);
    METHOD(void, set_item_navigation_mesh);
    METHOD(void, set_item_navigation_mesh_transform);
    METHOD(void, set_item_navigation_layers);
    METHOD(void, set_item_shapes);
    METHOD(void, set_item_preview);
    METHOD(String, get_item_name);
    METHOD(Object, get_item_mesh);
    METHOD(Transform3D, get_item_mesh_transform);
    METHOD(Object, get_item_navigation_mesh);
    METHOD(Transform3D, get_item_navigation_mesh_transform);
    METHOD(int64_t, get_item_navigation_layers);
    METHOD(Array, get_item_shapes);
    METHOD(Object, get_item_preview);
    METHOD(Variant, remove_item);
    METHOD(int64_t, find_item_by_name);
    METHOD(Variant, clear);
    METHOD(PackedArray<int32_t>, get_item_list);
    METHOD(int64_t, get_last_unused_item_id);
};
struct MissingResource : public Resource {
    using Resource::Resource;
    PROPERTY(original_class, String);
    PROPERTY(recording_properties, bool);
    METHOD(void, set_original_class);
    METHOD(String, get_original_class);
    METHOD(void, set_recording_properties);
    METHOD(bool, is_recording_properties);
};
struct MultiMesh : public Resource {
    using Resource::Resource;
    PROPERTY(transform_format, int64_t);
    PROPERTY(use_colors, bool);
    PROPERTY(use_custom_data, bool);
    PROPERTY(custom_aabb, Variant);
    PROPERTY(instance_count, int64_t);
    PROPERTY(visible_instance_count, int64_t);
    PROPERTY(mesh, Object);
    PROPERTY(buffer, PackedArray<float>);
    PROPERTY(transform_array, PackedArray<Vector3>);
    PROPERTY(transform_2d_array, PackedArray<Vector2>);
    PROPERTY(color_array, PackedArray<Color>);
    PROPERTY(custom_data_array, PackedArray<Color>);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(void, set_use_colors);
    METHOD(bool, is_using_colors);
    METHOD(void, set_use_custom_data);
    METHOD(bool, is_using_custom_data);
    METHOD(void, set_transform_format);
    METHOD(int64_t, get_transform_format);
    METHOD(void, set_instance_count);
    METHOD(int64_t, get_instance_count);
    METHOD(void, set_visible_instance_count);
    METHOD(int64_t, get_visible_instance_count);
    METHOD(void, set_instance_transform);
    METHOD(void, set_instance_transform_2d);
    METHOD(Transform3D, get_instance_transform);
    METHOD(Transform2D, get_instance_transform_2d);
    METHOD(void, set_instance_color);
    METHOD(Color, get_instance_color);
    METHOD(void, set_instance_custom_data);
    METHOD(Color, get_instance_custom_data);
    METHOD(void, set_custom_aabb);
    METHOD(Variant, get_custom_aabb);
    METHOD(Variant, get_aabb);
    METHOD(PackedArray<float>, get_buffer);
    METHOD(void, set_buffer);
    METHOD(Variant, _set_transform_array);
    METHOD(PackedArray<Vector3>, _get_transform_array);
    METHOD(Variant, _set_transform_2d_array);
    METHOD(PackedArray<Vector2>, _get_transform_2d_array);
    METHOD(Variant, _set_color_array);
    METHOD(PackedArray<Color>, _get_color_array);
    METHOD(Variant, _set_custom_data_array);
    METHOD(PackedArray<Color>, _get_custom_data_array);
    static constexpr int64_t TRANSFORM_2D = 0;
    static constexpr int64_t TRANSFORM_3D = 1;
};
struct NavigationMesh : public Resource {
    using Resource::Resource;
    PROPERTY(vertices, PackedArray<Vector3>);
    PROPERTY(polygons, Array);
    PROPERTY(sample_partition_type, int64_t);
    PROPERTY(geometry_parsed_geometry_type, int64_t);
    PROPERTY(geometry_collision_mask, int64_t);
    PROPERTY(geometry_source_geometry_mode, int64_t);
    PROPERTY(geometry_source_group_name, String);
    PROPERTY(cell_size, double);
    PROPERTY(cell_height, double);
    PROPERTY(border_size, double);
    PROPERTY(agent_height, double);
    PROPERTY(agent_radius, double);
    PROPERTY(agent_max_climb, double);
    PROPERTY(agent_max_slope, double);
    PROPERTY(region_min_size, double);
    PROPERTY(region_merge_size, double);
    PROPERTY(edge_max_length, double);
    PROPERTY(edge_max_error, double);
    PROPERTY(vertices_per_polygon, double);
    PROPERTY(detail_sample_distance, double);
    PROPERTY(detail_sample_max_error, double);
    PROPERTY(filter_low_hanging_obstacles, bool);
    PROPERTY(filter_ledge_spans, bool);
    PROPERTY(filter_walkable_low_height_spans, bool);
    PROPERTY(filter_baking_aabb, Variant);
    PROPERTY(filter_baking_aabb_offset, Vector3);
    METHOD(void, set_sample_partition_type);
    METHOD(int64_t, get_sample_partition_type);
    METHOD(void, set_parsed_geometry_type);
    METHOD(int64_t, get_parsed_geometry_type);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_source_geometry_mode);
    METHOD(int64_t, get_source_geometry_mode);
    METHOD(void, set_source_group_name);
    METHOD(String, get_source_group_name);
    METHOD(void, set_cell_size);
    METHOD(double, get_cell_size);
    METHOD(void, set_cell_height);
    METHOD(double, get_cell_height);
    METHOD(void, set_border_size);
    METHOD(double, get_border_size);
    METHOD(void, set_agent_height);
    METHOD(double, get_agent_height);
    METHOD(void, set_agent_radius);
    METHOD(double, get_agent_radius);
    METHOD(void, set_agent_max_climb);
    METHOD(double, get_agent_max_climb);
    METHOD(void, set_agent_max_slope);
    METHOD(double, get_agent_max_slope);
    METHOD(void, set_region_min_size);
    METHOD(double, get_region_min_size);
    METHOD(void, set_region_merge_size);
    METHOD(double, get_region_merge_size);
    METHOD(void, set_edge_max_length);
    METHOD(double, get_edge_max_length);
    METHOD(void, set_edge_max_error);
    METHOD(double, get_edge_max_error);
    METHOD(void, set_vertices_per_polygon);
    METHOD(double, get_vertices_per_polygon);
    METHOD(void, set_detail_sample_distance);
    METHOD(double, get_detail_sample_distance);
    METHOD(void, set_detail_sample_max_error);
    METHOD(double, get_detail_sample_max_error);
    METHOD(void, set_filter_low_hanging_obstacles);
    METHOD(bool, get_filter_low_hanging_obstacles);
    METHOD(void, set_filter_ledge_spans);
    METHOD(bool, get_filter_ledge_spans);
    METHOD(void, set_filter_walkable_low_height_spans);
    METHOD(bool, get_filter_walkable_low_height_spans);
    METHOD(void, set_filter_baking_aabb);
    METHOD(Variant, get_filter_baking_aabb);
    METHOD(void, set_filter_baking_aabb_offset);
    METHOD(Vector3, get_filter_baking_aabb_offset);
    METHOD(void, set_vertices);
    METHOD(PackedArray<Vector3>, get_vertices);
    METHOD(Variant, add_polygon);
    METHOD(int64_t, get_polygon_count);
    METHOD(PackedArray<int32_t>, get_polygon);
    METHOD(Variant, clear_polygons);
    METHOD(Variant, create_from_mesh);
    METHOD(Variant, _set_polygons);
    METHOD(Array, _get_polygons);
    METHOD(Variant, clear);
    static constexpr int64_t SAMPLE_PARTITION_WATERSHED = 0;
    static constexpr int64_t SAMPLE_PARTITION_MONOTONE = 1;
    static constexpr int64_t SAMPLE_PARTITION_LAYERS = 2;
    static constexpr int64_t SAMPLE_PARTITION_MAX = 3;
    static constexpr int64_t PARSED_GEOMETRY_MESH_INSTANCES = 0;
    static constexpr int64_t PARSED_GEOMETRY_STATIC_COLLIDERS = 1;
    static constexpr int64_t PARSED_GEOMETRY_BOTH = 2;
    static constexpr int64_t PARSED_GEOMETRY_MAX = 3;
    static constexpr int64_t SOURCE_GEOMETRY_ROOT_NODE_CHILDREN = 0;
    static constexpr int64_t SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN = 1;
    static constexpr int64_t SOURCE_GEOMETRY_GROUPS_EXPLICIT = 2;
    static constexpr int64_t SOURCE_GEOMETRY_MAX = 3;
};
struct NavigationMeshSourceGeometryData2D : public Resource {
    using Resource::Resource;
    PROPERTY(traversable_outlines, Array);
    PROPERTY(obstruction_outlines, Array);
    PROPERTY(projected_obstructions, Array);
    METHOD(Variant, clear);
    METHOD(bool, has_data);
    METHOD(void, set_traversable_outlines);
    METHOD(Array, get_traversable_outlines);
    METHOD(void, set_obstruction_outlines);
    METHOD(Array, get_obstruction_outlines);
    METHOD(Variant, append_traversable_outlines);
    METHOD(Variant, append_obstruction_outlines);
    METHOD(Variant, add_traversable_outline);
    METHOD(Variant, add_obstruction_outline);
    METHOD(Variant, merge);
    METHOD(Variant, add_projected_obstruction);
    METHOD(Variant, clear_projected_obstructions);
    METHOD(void, set_projected_obstructions);
    METHOD(Array, get_projected_obstructions);
};
struct NavigationMeshSourceGeometryData3D : public Resource {
    using Resource::Resource;
    PROPERTY(vertices, PackedArray<Vector3>);
    PROPERTY(indices, PackedArray<int32_t>);
    PROPERTY(projected_obstructions, Array);
    METHOD(void, set_vertices);
    METHOD(PackedArray<float>, get_vertices);
    METHOD(void, set_indices);
    METHOD(PackedArray<int32_t>, get_indices);
    METHOD(Variant, append_arrays);
    METHOD(Variant, clear);
    METHOD(bool, has_data);
    METHOD(Variant, add_mesh);
    METHOD(Variant, add_mesh_array);
    METHOD(Variant, add_faces);
    METHOD(Variant, merge);
    METHOD(Variant, add_projected_obstruction);
    METHOD(Variant, clear_projected_obstructions);
    METHOD(void, set_projected_obstructions);
    METHOD(Array, get_projected_obstructions);
};
struct NavigationPolygon : public Resource {
    using Resource::Resource;
    PROPERTY(vertices, PackedArray<Vector2>);
    PROPERTY(polygons, Array);
    PROPERTY(outlines, Array);
    PROPERTY(parsed_geometry_type, int64_t);
    PROPERTY(parsed_collision_mask, int64_t);
    PROPERTY(source_geometry_mode, int64_t);
    PROPERTY(source_geometry_group_name, String);
    PROPERTY(cell_size, double);
    PROPERTY(border_size, double);
    PROPERTY(agent_radius, double);
    PROPERTY(baking_rect, Rect2);
    PROPERTY(baking_rect_offset, Vector2);
    METHOD(void, set_vertices);
    METHOD(PackedArray<Vector2>, get_vertices);
    METHOD(Variant, add_polygon);
    METHOD(int64_t, get_polygon_count);
    METHOD(PackedArray<int32_t>, get_polygon);
    METHOD(Variant, clear_polygons);
    METHOD(Object, get_navigation_mesh);
    METHOD(Variant, add_outline);
    METHOD(Variant, add_outline_at_index);
    METHOD(int64_t, get_outline_count);
    METHOD(void, set_outline);
    METHOD(PackedArray<Vector2>, get_outline);
    METHOD(Variant, remove_outline);
    METHOD(Variant, clear_outlines);
    METHOD(Variant, make_polygons_from_outlines);
    METHOD(Variant, _set_polygons);
    METHOD(Array, _get_polygons);
    METHOD(Variant, _set_outlines);
    METHOD(Array, _get_outlines);
    METHOD(void, set_cell_size);
    METHOD(double, get_cell_size);
    METHOD(void, set_border_size);
    METHOD(double, get_border_size);
    METHOD(void, set_parsed_geometry_type);
    METHOD(int64_t, get_parsed_geometry_type);
    METHOD(void, set_parsed_collision_mask);
    METHOD(int64_t, get_parsed_collision_mask);
    METHOD(void, set_parsed_collision_mask_value);
    METHOD(bool, get_parsed_collision_mask_value);
    METHOD(void, set_source_geometry_mode);
    METHOD(int64_t, get_source_geometry_mode);
    METHOD(void, set_source_geometry_group_name);
    METHOD(String, get_source_geometry_group_name);
    METHOD(void, set_agent_radius);
    METHOD(double, get_agent_radius);
    METHOD(void, set_baking_rect);
    METHOD(Rect2, get_baking_rect);
    METHOD(void, set_baking_rect_offset);
    METHOD(Vector2, get_baking_rect_offset);
    METHOD(Variant, clear);
    static constexpr int64_t PARSED_GEOMETRY_MESH_INSTANCES = 0;
    static constexpr int64_t PARSED_GEOMETRY_STATIC_COLLIDERS = 1;
    static constexpr int64_t PARSED_GEOMETRY_BOTH = 2;
    static constexpr int64_t PARSED_GEOMETRY_MAX = 3;
    static constexpr int64_t SOURCE_GEOMETRY_ROOT_NODE_CHILDREN = 0;
    static constexpr int64_t SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN = 1;
    static constexpr int64_t SOURCE_GEOMETRY_GROUPS_EXPLICIT = 2;
    static constexpr int64_t SOURCE_GEOMETRY_MAX = 3;
};
struct Noise : public Resource {
    using Resource::Resource;
    METHOD(double, get_noise_1d);
    METHOD(double, get_noise_2d);
    METHOD(double, get_noise_2dv);
    METHOD(double, get_noise_3d);
    METHOD(double, get_noise_3dv);
    METHOD(Object, get_image);
    METHOD(Object, get_seamless_image);
    METHOD(Array, get_image_3d);
    METHOD(Array, get_seamless_image_3d);
};
struct Occluder3D : public Resource {
    using Resource::Resource;
    METHOD(PackedArray<Vector3>, get_vertices);
    METHOD(PackedArray<int32_t>, get_indices);
};
struct OccluderPolygon2D : public Resource {
    using Resource::Resource;
    PROPERTY(closed, bool);
    PROPERTY(cull_mode, int64_t);
    PROPERTY(polygon, PackedArray<Vector2>);
    METHOD(void, set_closed);
    METHOD(bool, is_closed);
    METHOD(void, set_cull_mode);
    METHOD(int64_t, get_cull_mode);
    METHOD(void, set_polygon);
    METHOD(PackedArray<Vector2>, get_polygon);
    static constexpr int64_t CULL_DISABLED = 0;
    static constexpr int64_t CULL_CLOCKWISE = 1;
    static constexpr int64_t CULL_COUNTER_CLOCKWISE = 2;
};
struct OpenXRAction : public Resource {
    using Resource::Resource;
    PROPERTY(localized_name, String);
    PROPERTY(action_type, int64_t);
    PROPERTY(toplevel_paths, PackedArray<std::string>);
    METHOD(void, set_localized_name);
    METHOD(String, get_localized_name);
    METHOD(void, set_action_type);
    METHOD(int64_t, get_action_type);
    METHOD(void, set_toplevel_paths);
    METHOD(PackedArray<std::string>, get_toplevel_paths);
    static constexpr int64_t OPENXR_ACTION_BOOL = 0;
    static constexpr int64_t OPENXR_ACTION_FLOAT = 1;
    static constexpr int64_t OPENXR_ACTION_VECTOR2 = 2;
    static constexpr int64_t OPENXR_ACTION_POSE = 3;
};
struct OpenXRActionMap : public Resource {
    using Resource::Resource;
    PROPERTY(action_sets, Array);
    PROPERTY(interaction_profiles, Array);
    METHOD(void, set_action_sets);
    METHOD(Array, get_action_sets);
    METHOD(int64_t, get_action_set_count);
    METHOD(Object, find_action_set);
    METHOD(Object, get_action_set);
    METHOD(Variant, add_action_set);
    METHOD(Variant, remove_action_set);
    METHOD(void, set_interaction_profiles);
    METHOD(Array, get_interaction_profiles);
    METHOD(int64_t, get_interaction_profile_count);
    METHOD(Object, find_interaction_profile);
    METHOD(Object, get_interaction_profile);
    METHOD(Variant, add_interaction_profile);
    METHOD(Variant, remove_interaction_profile);
    METHOD(Variant, create_default_action_sets);
};
struct OpenXRActionSet : public Resource {
    using Resource::Resource;
    PROPERTY(localized_name, String);
    PROPERTY(priority, int64_t);
    PROPERTY(actions, Array);
    METHOD(void, set_localized_name);
    METHOD(String, get_localized_name);
    METHOD(void, set_priority);
    METHOD(int64_t, get_priority);
    METHOD(int64_t, get_action_count);
    METHOD(void, set_actions);
    METHOD(Array, get_actions);
    METHOD(Variant, add_action);
    METHOD(Variant, remove_action);
};
struct OpenXRIPBinding : public Resource {
    using Resource::Resource;
    PROPERTY(action, Object);
    PROPERTY(paths, PackedArray<std::string>);
    METHOD(void, set_action);
    METHOD(Object, get_action);
    METHOD(int64_t, get_path_count);
    METHOD(void, set_paths);
    METHOD(PackedArray<std::string>, get_paths);
    METHOD(bool, has_path);
    METHOD(Variant, add_path);
    METHOD(Variant, remove_path);
};
struct OpenXRInteractionProfile : public Resource {
    using Resource::Resource;
    PROPERTY(interaction_profile_path, String);
    PROPERTY(bindings, Array);
    METHOD(void, set_interaction_profile_path);
    METHOD(String, get_interaction_profile_path);
    METHOD(int64_t, get_binding_count);
    METHOD(Object, get_binding);
    METHOD(void, set_bindings);
    METHOD(Array, get_bindings);
};
struct PackedDataContainer : public Resource {
    using Resource::Resource;
    PROPERTY(__data__, PackedArray<uint8_t>);
    METHOD(Variant, _set_data);
    METHOD(PackedArray<uint8_t>, _get_data);
    METHOD(Variant, _iter_init);
    METHOD(Variant, _iter_get);
    METHOD(Variant, _iter_next);
    METHOD(int64_t, pack);
    METHOD(int64_t, size);
};
struct PackedScene : public Resource {
    using Resource::Resource;
    PROPERTY(_bundled, Dictionary);
    METHOD(int64_t, pack);
    METHOD(Object, instantiate);
    METHOD(bool, can_instantiate);
    METHOD(Variant, _set_bundled_scene);
    METHOD(Dictionary, _get_bundled_scene);
    METHOD(Object, get_state);
    static constexpr int64_t GEN_EDIT_STATE_DISABLED = 0;
    static constexpr int64_t GEN_EDIT_STATE_INSTANCE = 1;
    static constexpr int64_t GEN_EDIT_STATE_MAIN = 2;
    static constexpr int64_t GEN_EDIT_STATE_MAIN_INHERITED = 3;
};
struct PhysicsMaterial : public Resource {
    using Resource::Resource;
    PROPERTY(friction, double);
    PROPERTY(rough, bool);
    PROPERTY(bounce, double);
    PROPERTY(absorbent, bool);
    METHOD(void, set_friction);
    METHOD(double, get_friction);
    METHOD(void, set_rough);
    METHOD(bool, is_rough);
    METHOD(void, set_bounce);
    METHOD(double, get_bounce);
    METHOD(void, set_absorbent);
    METHOD(bool, is_absorbent);
};
struct PolygonPathFinder : public Resource {
    using Resource::Resource;
    PROPERTY(data, Dictionary);
    METHOD(Variant, setup);
    METHOD(PackedArray<Vector2>, find_path);
    METHOD(PackedArray<Vector2>, get_intersections);
    METHOD(Vector2, get_closest_point);
    METHOD(bool, is_point_inside);
    METHOD(void, set_point_penalty);
    METHOD(double, get_point_penalty);
    METHOD(Rect2, get_bounds);
    METHOD(Variant, _set_data);
    METHOD(Dictionary, _get_data);
};
struct RDShaderFile : public Resource {
    using Resource::Resource;
    PROPERTY(_versions, Dictionary);
    PROPERTY(base_error, String);
    METHOD(void, set_bytecode);
    METHOD(Object, get_spirv);
    METHOD(Array, get_version_list);
    METHOD(void, set_base_error);
    METHOD(String, get_base_error);
    METHOD(Variant, _set_versions);
    METHOD(Dictionary, _get_versions);
};
struct RDShaderSPIRV : public Resource {
    using Resource::Resource;
    PROPERTY(bytecode_vertex, PackedArray<uint8_t>);
    PROPERTY(bytecode_fragment, PackedArray<uint8_t>);
    PROPERTY(bytecode_tesselation_control, PackedArray<uint8_t>);
    PROPERTY(bytecode_tesselation_evaluation, PackedArray<uint8_t>);
    PROPERTY(bytecode_compute, PackedArray<uint8_t>);
    PROPERTY(compile_error_vertex, String);
    PROPERTY(compile_error_fragment, String);
    PROPERTY(compile_error_tesselation_control, String);
    PROPERTY(compile_error_tesselation_evaluation, String);
    PROPERTY(compile_error_compute, String);
    METHOD(void, set_stage_bytecode);
    METHOD(PackedArray<uint8_t>, get_stage_bytecode);
    METHOD(void, set_stage_compile_error);
    METHOD(String, get_stage_compile_error);
};
struct AnimationBezierTrackEdit : public Control {
    using Control::Control;
    METHOD(Variant, _clear_selection);
    METHOD(Variant, _clear_selection_for_anim);
    METHOD(Variant, _select_at_anim);
    METHOD(Variant, _update_hidden_tracks_after);
    METHOD(Variant, _update_locked_tracks_after);
    METHOD(Variant, _bezier_track_insert_key_at_anim);
};
struct BaseButton : public Control {
    using Control::Control;
    PROPERTY(disabled, bool);
    PROPERTY(toggle_mode, bool);
    PROPERTY(button_pressed, bool);
    PROPERTY(action_mode, int64_t);
    PROPERTY(button_mask, int64_t);
    PROPERTY(keep_pressed_outside, bool);
    PROPERTY(button_group, Object);
    PROPERTY(shortcut, Object);
    PROPERTY(shortcut_feedback, bool);
    PROPERTY(shortcut_in_tooltip, bool);
    METHOD(Variant, _pressed);
    METHOD(Variant, _toggled);
    METHOD(void, set_pressed);
    METHOD(bool, is_pressed);
    METHOD(void, set_pressed_no_signal);
    METHOD(bool, is_hovered);
    METHOD(void, set_toggle_mode);
    METHOD(bool, is_toggle_mode);
    METHOD(void, set_shortcut_in_tooltip);
    METHOD(bool, is_shortcut_in_tooltip_enabled);
    METHOD(void, set_disabled);
    METHOD(bool, is_disabled);
    METHOD(void, set_action_mode);
    METHOD(int64_t, get_action_mode);
    METHOD(void, set_button_mask);
    METHOD(int64_t, get_button_mask);
    METHOD(int64_t, get_draw_mode);
    METHOD(void, set_keep_pressed_outside);
    METHOD(bool, is_keep_pressed_outside);
    METHOD(void, set_shortcut_feedback);
    METHOD(bool, is_shortcut_feedback);
    METHOD(void, set_shortcut);
    METHOD(Object, get_shortcut);
    METHOD(void, set_button_group);
    METHOD(Object, get_button_group);
    static constexpr int64_t DRAW_NORMAL = 0;
    static constexpr int64_t DRAW_PRESSED = 1;
    static constexpr int64_t DRAW_HOVER = 2;
    static constexpr int64_t DRAW_DISABLED = 3;
    static constexpr int64_t DRAW_HOVER_PRESSED = 4;
    static constexpr int64_t ACTION_MODE_BUTTON_PRESS = 0;
    static constexpr int64_t ACTION_MODE_BUTTON_RELEASE = 1;
};
struct ColorRect : public Control {
    using Control::Control;
    PROPERTY(color, Color);
    METHOD(void, set_color);
    METHOD(Color, get_color);
};
struct Container : public Control {
    using Control::Control;
    METHOD(PackedArray<int32_t>, _get_allowed_size_flags_horizontal);
    METHOD(PackedArray<int32_t>, _get_allowed_size_flags_vertical);
    METHOD(Variant, queue_sort);
    METHOD(Variant, fit_child_in_rect);
    static constexpr int64_t NOTIFICATION_PRE_SORT_CHILDREN = 50;
    static constexpr int64_t NOTIFICATION_SORT_CHILDREN = 51;
};
struct AnimationNodeOutput : public AnimationNode {
    using AnimationNode::AnimationNode;
};
struct AnimationNodeSync : public AnimationNode {
    using AnimationNode::AnimationNode;
    PROPERTY(sync, bool);
    METHOD(void, set_use_sync);
    METHOD(bool, is_using_sync);
};
struct AnimationNodeTimeScale : public AnimationNode {
    using AnimationNode::AnimationNode;
};
struct AnimationNodeTimeSeek : public AnimationNode {
    using AnimationNode::AnimationNode;
};
struct AnimationRootNode : public AnimationNode {
    using AnimationNode::AnimationNode;
};
struct AnimationNodeAdd2 : public AnimationNodeSync {
    using AnimationNodeSync::AnimationNodeSync;
};
struct AnimationNodeAdd3 : public AnimationNodeSync {
    using AnimationNodeSync::AnimationNodeSync;
};
struct AnimationNodeBlend2 : public AnimationNodeSync {
    using AnimationNodeSync::AnimationNodeSync;
};
struct AnimationNodeBlend3 : public AnimationNodeSync {
    using AnimationNodeSync::AnimationNodeSync;
};
struct AnimationNodeOneShot : public AnimationNodeSync {
    using AnimationNodeSync::AnimationNodeSync;
    PROPERTY(mix_mode, int64_t);
    PROPERTY(fadein_time, double);
    PROPERTY(fadein_curve, Object);
    PROPERTY(fadeout_time, double);
    PROPERTY(fadeout_curve, Object);
    PROPERTY(break_loop_at_end, bool);
    PROPERTY(autorestart, bool);
    PROPERTY(autorestart_delay, double);
    PROPERTY(autorestart_random_delay, double);
    METHOD(void, set_fadein_time);
    METHOD(double, get_fadein_time);
    METHOD(void, set_fadein_curve);
    METHOD(Object, get_fadein_curve);
    METHOD(void, set_fadeout_time);
    METHOD(double, get_fadeout_time);
    METHOD(void, set_fadeout_curve);
    METHOD(Object, get_fadeout_curve);
    METHOD(void, set_break_loop_at_end);
    METHOD(bool, is_loop_broken_at_end);
    METHOD(void, set_autorestart);
    METHOD(bool, has_autorestart);
    METHOD(void, set_autorestart_delay);
    METHOD(double, get_autorestart_delay);
    METHOD(void, set_autorestart_random_delay);
    METHOD(double, get_autorestart_random_delay);
    METHOD(void, set_mix_mode);
    METHOD(int64_t, get_mix_mode);
    static constexpr int64_t ONE_SHOT_REQUEST_NONE = 0;
    static constexpr int64_t ONE_SHOT_REQUEST_FIRE = 1;
    static constexpr int64_t ONE_SHOT_REQUEST_ABORT = 2;
    static constexpr int64_t ONE_SHOT_REQUEST_FADE_OUT = 3;
    static constexpr int64_t MIX_MODE_BLEND = 0;
    static constexpr int64_t MIX_MODE_ADD = 1;
};
struct AnimationNodeSub2 : public AnimationNodeSync {
    using AnimationNodeSync::AnimationNodeSync;
};
struct AnimationNodeTransition : public AnimationNodeSync {
    using AnimationNodeSync::AnimationNodeSync;
    PROPERTY(xfade_time, double);
    PROPERTY(xfade_curve, Object);
    PROPERTY(allow_transition_to_self, bool);
    PROPERTY(input_count, int64_t);
    METHOD(void, set_input_count);
    METHOD(void, set_input_as_auto_advance);
    METHOD(bool, is_input_set_as_auto_advance);
    METHOD(void, set_input_break_loop_at_end);
    METHOD(bool, is_input_loop_broken_at_end);
    METHOD(void, set_input_reset);
    METHOD(bool, is_input_reset);
    METHOD(void, set_xfade_time);
    METHOD(double, get_xfade_time);
    METHOD(void, set_xfade_curve);
    METHOD(Object, get_xfade_curve);
    METHOD(void, set_allow_transition_to_self);
    METHOD(bool, is_allow_transition_to_self);
};
struct AnimationNodeAnimation : public AnimationRootNode {
    using AnimationRootNode::AnimationRootNode;
    PROPERTY(animation, String);
    PROPERTY(play_mode, int64_t);
    PROPERTY(use_custom_timeline, bool);
    PROPERTY(timeline_length, double);
    PROPERTY(stretch_time_scale, bool);
    PROPERTY(start_offset, double);
    PROPERTY(loop_mode, int64_t);
    METHOD(void, set_animation);
    METHOD(String, get_animation);
    METHOD(void, set_play_mode);
    METHOD(int64_t, get_play_mode);
    METHOD(void, set_use_custom_timeline);
    METHOD(bool, is_using_custom_timeline);
    METHOD(void, set_timeline_length);
    METHOD(double, get_timeline_length);
    METHOD(void, set_stretch_time_scale);
    METHOD(bool, is_stretching_time_scale);
    METHOD(void, set_start_offset);
    METHOD(double, get_start_offset);
    METHOD(void, set_loop_mode);
    METHOD(int64_t, get_loop_mode);
    static constexpr int64_t PLAY_MODE_FORWARD = 0;
    static constexpr int64_t PLAY_MODE_BACKWARD = 1;
};
struct AnimationNodeBlendSpace1D : public AnimationRootNode {
    using AnimationRootNode::AnimationRootNode;
    PROPERTY(min_space, double);
    PROPERTY(max_space, double);
    PROPERTY(snap, double);
    PROPERTY(value_label, String);
    PROPERTY(blend_mode, int64_t);
    PROPERTY(sync, bool);
    METHOD(Variant, add_blend_point);
    METHOD(void, set_blend_point_position);
    METHOD(double, get_blend_point_position);
    METHOD(void, set_blend_point_node);
    METHOD(Object, get_blend_point_node);
    METHOD(Variant, remove_blend_point);
    METHOD(int64_t, get_blend_point_count);
    METHOD(void, set_min_space);
    METHOD(double, get_min_space);
    METHOD(void, set_max_space);
    METHOD(double, get_max_space);
    METHOD(void, set_snap);
    METHOD(double, get_snap);
    METHOD(void, set_value_label);
    METHOD(String, get_value_label);
    METHOD(void, set_blend_mode);
    METHOD(int64_t, get_blend_mode);
    METHOD(void, set_use_sync);
    METHOD(bool, is_using_sync);
    METHOD(Variant, _add_blend_point);
    static constexpr int64_t BLEND_MODE_INTERPOLATED = 0;
    static constexpr int64_t BLEND_MODE_DISCRETE = 1;
    static constexpr int64_t BLEND_MODE_DISCRETE_CARRY = 2;
};
struct AnimationNodeBlendSpace2D : public AnimationRootNode {
    using AnimationRootNode::AnimationRootNode;
    PROPERTY(auto_triangles, bool);
    PROPERTY(triangles, PackedArray<int32_t>);
    PROPERTY(min_space, Vector2);
    PROPERTY(max_space, Vector2);
    PROPERTY(snap, Vector2);
    PROPERTY(x_label, String);
    PROPERTY(y_label, String);
    PROPERTY(blend_mode, int64_t);
    PROPERTY(sync, bool);
    METHOD(Variant, add_blend_point);
    METHOD(void, set_blend_point_position);
    METHOD(Vector2, get_blend_point_position);
    METHOD(void, set_blend_point_node);
    METHOD(Object, get_blend_point_node);
    METHOD(Variant, remove_blend_point);
    METHOD(int64_t, get_blend_point_count);
    METHOD(Variant, add_triangle);
    METHOD(int64_t, get_triangle_point);
    METHOD(Variant, remove_triangle);
    METHOD(int64_t, get_triangle_count);
    METHOD(void, set_min_space);
    METHOD(Vector2, get_min_space);
    METHOD(void, set_max_space);
    METHOD(Vector2, get_max_space);
    METHOD(void, set_snap);
    METHOD(Vector2, get_snap);
    METHOD(void, set_x_label);
    METHOD(String, get_x_label);
    METHOD(void, set_y_label);
    METHOD(String, get_y_label);
    METHOD(Variant, _add_blend_point);
    METHOD(Variant, _set_triangles);
    METHOD(PackedArray<int32_t>, _get_triangles);
    METHOD(void, set_auto_triangles);
    METHOD(bool, get_auto_triangles);
    METHOD(void, set_blend_mode);
    METHOD(int64_t, get_blend_mode);
    METHOD(void, set_use_sync);
    METHOD(bool, is_using_sync);
    static constexpr int64_t BLEND_MODE_INTERPOLATED = 0;
    static constexpr int64_t BLEND_MODE_DISCRETE = 1;
    static constexpr int64_t BLEND_MODE_DISCRETE_CARRY = 2;
};
struct AnimationNodeBlendTree : public AnimationRootNode {
    using AnimationRootNode::AnimationRootNode;
    PROPERTY(graph_offset, Vector2);
    METHOD(Variant, add_node);
    METHOD(Object, get_node);
    METHOD(Variant, remove_node);
    METHOD(Variant, rename_node);
    METHOD(bool, has_node);
    METHOD(Variant, connect_node);
    METHOD(Variant, disconnect_node);
    METHOD(void, set_node_position);
    METHOD(Vector2, get_node_position);
    METHOD(void, set_graph_offset);
    METHOD(Vector2, get_graph_offset);
    static constexpr int64_t CONNECTION_OK = 0;
    static constexpr int64_t CONNECTION_ERROR_NO_INPUT = 1;
    static constexpr int64_t CONNECTION_ERROR_NO_INPUT_INDEX = 2;
    static constexpr int64_t CONNECTION_ERROR_NO_OUTPUT = 3;
    static constexpr int64_t CONNECTION_ERROR_SAME_NODE = 4;
    static constexpr int64_t CONNECTION_ERROR_CONNECTION_EXISTS = 5;
};
struct AnimationNodeStateMachine : public AnimationRootNode {
    using AnimationRootNode::AnimationRootNode;
    PROPERTY(state_machine_type, int64_t);
    PROPERTY(allow_transition_to_self, bool);
    PROPERTY(reset_ends, bool);
    METHOD(Variant, add_node);
    METHOD(Variant, replace_node);
    METHOD(Object, get_node);
    METHOD(Variant, remove_node);
    METHOD(Variant, rename_node);
    METHOD(bool, has_node);
    METHOD(String, get_node_name);
    METHOD(void, set_node_position);
    METHOD(Vector2, get_node_position);
    METHOD(bool, has_transition);
    METHOD(Variant, add_transition);
    METHOD(Object, get_transition);
    METHOD(String, get_transition_from);
    METHOD(String, get_transition_to);
    METHOD(int64_t, get_transition_count);
    METHOD(Variant, remove_transition_by_index);
    METHOD(Variant, remove_transition);
    METHOD(void, set_graph_offset);
    METHOD(Vector2, get_graph_offset);
    METHOD(void, set_state_machine_type);
    METHOD(int64_t, get_state_machine_type);
    METHOD(void, set_allow_transition_to_self);
    METHOD(bool, is_allow_transition_to_self);
    METHOD(void, set_reset_ends);
    METHOD(bool, are_ends_reset);
    static constexpr int64_t STATE_MACHINE_TYPE_ROOT = 0;
    static constexpr int64_t STATE_MACHINE_TYPE_NESTED = 1;
    static constexpr int64_t STATE_MACHINE_TYPE_GROUPED = 2;
};
struct AnimationTimelineEdit : public Range {
    using Range::Range;
    METHOD(Variant, update_values);
};
struct ProgressBar : public Range {
    using Range::Range;
    PROPERTY(fill_mode, int64_t);
    PROPERTY(show_percentage, bool);
    PROPERTY(indeterminate, bool);
    PROPERTY(editor_preview_indeterminate, bool);
    METHOD(void, set_fill_mode);
    METHOD(int64_t, get_fill_mode);
    METHOD(void, set_show_percentage);
    METHOD(bool, is_percentage_shown);
    METHOD(void, set_indeterminate);
    METHOD(bool, is_indeterminate);
    METHOD(void, set_editor_preview_indeterminate);
    METHOD(bool, is_editor_preview_indeterminate_enabled);
    static constexpr int64_t FILL_BEGIN_TO_END = 0;
    static constexpr int64_t FILL_END_TO_BEGIN = 1;
    static constexpr int64_t FILL_TOP_TO_BOTTOM = 2;
    static constexpr int64_t FILL_BOTTOM_TO_TOP = 3;
};
struct AnimationTrackEditDefaultPlugin : public AnimationTrackEditPlugin {
    using AnimationTrackEditPlugin::AnimationTrackEditPlugin;
};
struct Area2D : public CollisionObject2D {
    using CollisionObject2D::CollisionObject2D;
    PROPERTY(monitoring, bool);
    PROPERTY(monitorable, bool);
    PROPERTY(priority, int64_t);
    PROPERTY(gravity_space_override, int64_t);
    PROPERTY(gravity_point, bool);
    PROPERTY(gravity_point_unit_distance, double);
    PROPERTY(gravity_point_center, Vector2);
    PROPERTY(gravity_direction, Vector2);
    PROPERTY(gravity, double);
    PROPERTY(linear_damp_space_override, int64_t);
    PROPERTY(linear_damp, double);
    PROPERTY(angular_damp_space_override, int64_t);
    PROPERTY(angular_damp, double);
    PROPERTY(audio_bus_override, bool);
    PROPERTY(audio_bus_name, String);
    METHOD(void, set_gravity_space_override_mode);
    METHOD(int64_t, get_gravity_space_override_mode);
    METHOD(void, set_gravity_is_point);
    METHOD(bool, is_gravity_a_point);
    METHOD(void, set_gravity_point_unit_distance);
    METHOD(double, get_gravity_point_unit_distance);
    METHOD(void, set_gravity_point_center);
    METHOD(Vector2, get_gravity_point_center);
    METHOD(void, set_gravity_direction);
    METHOD(Vector2, get_gravity_direction);
    METHOD(void, set_gravity);
    METHOD(double, get_gravity);
    METHOD(void, set_linear_damp_space_override_mode);
    METHOD(int64_t, get_linear_damp_space_override_mode);
    METHOD(void, set_angular_damp_space_override_mode);
    METHOD(int64_t, get_angular_damp_space_override_mode);
    METHOD(void, set_linear_damp);
    METHOD(double, get_linear_damp);
    METHOD(void, set_angular_damp);
    METHOD(double, get_angular_damp);
    METHOD(void, set_priority);
    METHOD(int64_t, get_priority);
    METHOD(void, set_monitoring);
    METHOD(bool, is_monitoring);
    METHOD(void, set_monitorable);
    METHOD(bool, is_monitorable);
    METHOD(Array, get_overlapping_bodies);
    METHOD(Array, get_overlapping_areas);
    METHOD(bool, has_overlapping_bodies);
    METHOD(bool, has_overlapping_areas);
    METHOD(bool, overlaps_body);
    METHOD(bool, overlaps_area);
    METHOD(void, set_audio_bus_name);
    METHOD(String, get_audio_bus_name);
    METHOD(void, set_audio_bus_override);
    METHOD(bool, is_overriding_audio_bus);
    static constexpr int64_t SPACE_OVERRIDE_DISABLED = 0;
    static constexpr int64_t SPACE_OVERRIDE_COMBINE = 1;
    static constexpr int64_t SPACE_OVERRIDE_COMBINE_REPLACE = 2;
    static constexpr int64_t SPACE_OVERRIDE_REPLACE = 3;
    static constexpr int64_t SPACE_OVERRIDE_REPLACE_COMBINE = 4;
};
struct Area3D : public CollisionObject3D {
    using CollisionObject3D::CollisionObject3D;
    PROPERTY(monitoring, bool);
    PROPERTY(monitorable, bool);
    PROPERTY(priority, int64_t);
    PROPERTY(gravity_space_override, int64_t);
    PROPERTY(gravity_point, bool);
    PROPERTY(gravity_point_unit_distance, double);
    PROPERTY(gravity_point_center, Vector3);
    PROPERTY(gravity_direction, Vector3);
    PROPERTY(gravity, double);
    PROPERTY(linear_damp_space_override, int64_t);
    PROPERTY(linear_damp, double);
    PROPERTY(angular_damp_space_override, int64_t);
    PROPERTY(angular_damp, double);
    PROPERTY(wind_force_magnitude, double);
    PROPERTY(wind_attenuation_factor, double);
    PROPERTY(wind_source_path, String);
    PROPERTY(audio_bus_override, bool);
    PROPERTY(audio_bus_name, String);
    PROPERTY(reverb_bus_enabled, bool);
    PROPERTY(reverb_bus_name, String);
    PROPERTY(reverb_bus_amount, double);
    PROPERTY(reverb_bus_uniformity, double);
    METHOD(void, set_gravity_space_override_mode);
    METHOD(int64_t, get_gravity_space_override_mode);
    METHOD(void, set_gravity_is_point);
    METHOD(bool, is_gravity_a_point);
    METHOD(void, set_gravity_point_unit_distance);
    METHOD(double, get_gravity_point_unit_distance);
    METHOD(void, set_gravity_point_center);
    METHOD(Vector3, get_gravity_point_center);
    METHOD(void, set_gravity_direction);
    METHOD(Vector3, get_gravity_direction);
    METHOD(void, set_gravity);
    METHOD(double, get_gravity);
    METHOD(void, set_linear_damp_space_override_mode);
    METHOD(int64_t, get_linear_damp_space_override_mode);
    METHOD(void, set_angular_damp_space_override_mode);
    METHOD(int64_t, get_angular_damp_space_override_mode);
    METHOD(void, set_angular_damp);
    METHOD(double, get_angular_damp);
    METHOD(void, set_linear_damp);
    METHOD(double, get_linear_damp);
    METHOD(void, set_priority);
    METHOD(int64_t, get_priority);
    METHOD(void, set_wind_force_magnitude);
    METHOD(double, get_wind_force_magnitude);
    METHOD(void, set_wind_attenuation_factor);
    METHOD(double, get_wind_attenuation_factor);
    METHOD(void, set_wind_source_path);
    METHOD(String, get_wind_source_path);
    METHOD(void, set_monitorable);
    METHOD(bool, is_monitorable);
    METHOD(void, set_monitoring);
    METHOD(bool, is_monitoring);
    METHOD(Array, get_overlapping_bodies);
    METHOD(Array, get_overlapping_areas);
    METHOD(bool, has_overlapping_bodies);
    METHOD(bool, has_overlapping_areas);
    METHOD(bool, overlaps_body);
    METHOD(bool, overlaps_area);
    METHOD(void, set_audio_bus_override);
    METHOD(bool, is_overriding_audio_bus);
    METHOD(void, set_audio_bus_name);
    METHOD(String, get_audio_bus_name);
    METHOD(void, set_use_reverb_bus);
    METHOD(bool, is_using_reverb_bus);
    METHOD(void, set_reverb_bus_name);
    METHOD(String, get_reverb_bus_name);
    METHOD(void, set_reverb_amount);
    METHOD(double, get_reverb_amount);
    METHOD(void, set_reverb_uniformity);
    METHOD(double, get_reverb_uniformity);
    static constexpr int64_t SPACE_OVERRIDE_DISABLED = 0;
    static constexpr int64_t SPACE_OVERRIDE_COMBINE = 1;
    static constexpr int64_t SPACE_OVERRIDE_COMBINE_REPLACE = 2;
    static constexpr int64_t SPACE_OVERRIDE_REPLACE = 3;
    static constexpr int64_t SPACE_OVERRIDE_REPLACE_COMBINE = 4;
};
struct ArrayMesh : public Mesh {
    using Mesh::Mesh;
    PROPERTY(_blend_shape_names, PackedArray<std::string>);
    PROPERTY(_surfaces, Array);
    PROPERTY(blend_shape_mode, int64_t);
    PROPERTY(custom_aabb, Variant);
    PROPERTY(shadow_mesh, Object);
    METHOD(Variant, add_blend_shape);
    METHOD(int64_t, get_blend_shape_count);
    METHOD(String, get_blend_shape_name);
    METHOD(void, set_blend_shape_name);
    METHOD(Variant, clear_blend_shapes);
    METHOD(void, set_blend_shape_mode);
    METHOD(int64_t, get_blend_shape_mode);
    METHOD(Variant, add_surface_from_arrays);
    METHOD(Variant, clear_surfaces);
    METHOD(Variant, surface_update_vertex_region);
    METHOD(Variant, surface_update_attribute_region);
    METHOD(Variant, surface_update_skin_region);
    METHOD(int64_t, surface_get_array_len);
    METHOD(int64_t, surface_get_array_index_len);
    METHOD(int64_t, surface_get_format);
    METHOD(int64_t, surface_get_primitive_type);
    METHOD(int64_t, surface_find_by_name);
    METHOD(Variant, surface_set_name);
    METHOD(String, surface_get_name);
    METHOD(Variant, regen_normal_maps);
    METHOD(int64_t, lightmap_unwrap);
    METHOD(void, set_custom_aabb);
    METHOD(Variant, get_custom_aabb);
    METHOD(void, set_shadow_mesh);
    METHOD(Object, get_shadow_mesh);
    METHOD(Variant, _set_blend_shape_names);
    METHOD(PackedArray<std::string>, _get_blend_shape_names);
    METHOD(Variant, _set_surfaces);
    METHOD(Array, _get_surfaces);
};
struct ImmediateMesh : public Mesh {
    using Mesh::Mesh;
    METHOD(Variant, surface_begin);
    METHOD(Variant, surface_set_color);
    METHOD(Variant, surface_set_normal);
    METHOD(Variant, surface_set_tangent);
    METHOD(Variant, surface_set_uv);
    METHOD(Variant, surface_set_uv2);
    METHOD(Variant, surface_add_vertex);
    METHOD(Variant, surface_add_vertex_2d);
    METHOD(Variant, surface_end);
    METHOD(Variant, clear_surfaces);
};
struct PlaceholderMesh : public Mesh {
    using Mesh::Mesh;
    PROPERTY(aabb, Variant);
    METHOD(void, set_aabb);
};
struct PrimitiveMesh : public Mesh {
    using Mesh::Mesh;
    PROPERTY(material, Object);
    PROPERTY(custom_aabb, Variant);
    PROPERTY(flip_faces, bool);
    PROPERTY(add_uv2, bool);
    PROPERTY(uv2_padding, double);
    METHOD(Array, _create_mesh_array);
    METHOD(void, set_material);
    METHOD(Object, get_material);
    METHOD(Array, get_mesh_arrays);
    METHOD(void, set_custom_aabb);
    METHOD(Variant, get_custom_aabb);
    METHOD(void, set_flip_faces);
    METHOD(bool, get_flip_faces);
    METHOD(void, set_add_uv2);
    METHOD(bool, get_add_uv2);
    METHOD(void, set_uv2_padding);
    METHOD(double, get_uv2_padding);
    METHOD(Variant, request_update);
};
struct ArrayOccluder3D : public Occluder3D {
    using Occluder3D::Occluder3D;
    PROPERTY(vertices, PackedArray<Vector3>);
    PROPERTY(indices, PackedArray<int32_t>);
    METHOD(void, set_arrays);
    METHOD(void, set_vertices);
    METHOD(void, set_indices);
};
struct BoxOccluder3D : public Occluder3D {
    using Occluder3D::Occluder3D;
    PROPERTY(size, Vector3);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
};
struct PolygonOccluder3D : public Occluder3D {
    using Occluder3D::Occluder3D;
    PROPERTY(polygon, PackedArray<Vector2>);
    METHOD(void, set_polygon);
    METHOD(PackedArray<Vector2>, get_polygon);
    METHOD(bool, _has_editable_3d_polygon_no_depth);
};
struct QuadOccluder3D : public Occluder3D {
    using Occluder3D::Occluder3D;
    PROPERTY(size, Vector2);
    METHOD(void, set_size);
    METHOD(Vector2, get_size);
};
struct SphereOccluder3D : public Occluder3D {
    using Occluder3D::Occluder3D;
    PROPERTY(radius, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
};
struct AspectRatioContainer : public Container {
    using Container::Container;
    PROPERTY(ratio, double);
    PROPERTY(stretch_mode, int64_t);
    PROPERTY(alignment_horizontal, int64_t);
    PROPERTY(alignment_vertical, int64_t);
    METHOD(void, set_ratio);
    METHOD(double, get_ratio);
    METHOD(void, set_stretch_mode);
    METHOD(int64_t, get_stretch_mode);
    METHOD(void, set_alignment_horizontal);
    METHOD(int64_t, get_alignment_horizontal);
    METHOD(void, set_alignment_vertical);
    METHOD(int64_t, get_alignment_vertical);
    static constexpr int64_t STRETCH_WIDTH_CONTROLS_HEIGHT = 0;
    static constexpr int64_t STRETCH_HEIGHT_CONTROLS_WIDTH = 1;
    static constexpr int64_t STRETCH_FIT = 2;
    static constexpr int64_t STRETCH_COVER = 3;
    static constexpr int64_t ALIGNMENT_BEGIN = 0;
    static constexpr int64_t ALIGNMENT_CENTER = 1;
    static constexpr int64_t ALIGNMENT_END = 2;
};
struct BoxContainer : public Container {
    using Container::Container;
    PROPERTY(alignment, int64_t);
    PROPERTY(vertical, bool);
    METHOD(Object, add_spacer);
    METHOD(void, set_alignment);
    METHOD(int64_t, get_alignment);
    METHOD(void, set_vertical);
    METHOD(bool, is_vertical);
    static constexpr int64_t ALIGNMENT_BEGIN = 0;
    static constexpr int64_t ALIGNMENT_CENTER = 1;
    static constexpr int64_t ALIGNMENT_END = 2;
};
struct CenterContainer : public Container {
    using Container::Container;
    PROPERTY(use_top_left, bool);
    METHOD(void, set_use_top_left);
    METHOD(bool, is_using_top_left);
};
struct FlowContainer : public Container {
    using Container::Container;
    PROPERTY(alignment, int64_t);
    PROPERTY(last_wrap_alignment, int64_t);
    PROPERTY(vertical, bool);
    PROPERTY(reverse_fill, bool);
    METHOD(int64_t, get_line_count);
    METHOD(void, set_alignment);
    METHOD(int64_t, get_alignment);
    METHOD(void, set_last_wrap_alignment);
    METHOD(int64_t, get_last_wrap_alignment);
    METHOD(void, set_vertical);
    METHOD(bool, is_vertical);
    METHOD(void, set_reverse_fill);
    METHOD(bool, is_reverse_fill);
    static constexpr int64_t ALIGNMENT_BEGIN = 0;
    static constexpr int64_t ALIGNMENT_CENTER = 1;
    static constexpr int64_t ALIGNMENT_END = 2;
    static constexpr int64_t LAST_WRAP_ALIGNMENT_INHERIT = 0;
    static constexpr int64_t LAST_WRAP_ALIGNMENT_BEGIN = 1;
    static constexpr int64_t LAST_WRAP_ALIGNMENT_CENTER = 2;
    static constexpr int64_t LAST_WRAP_ALIGNMENT_END = 3;
};
struct GraphElement : public Container {
    using Container::Container;
    PROPERTY(position_offset, Vector2);
    PROPERTY(resizable, bool);
    PROPERTY(draggable, bool);
    PROPERTY(selectable, bool);
    PROPERTY(selected, bool);
    METHOD(void, set_resizable);
    METHOD(bool, is_resizable);
    METHOD(void, set_draggable);
    METHOD(bool, is_draggable);
    METHOD(void, set_selectable);
    METHOD(bool, is_selectable);
    METHOD(void, set_selected);
    METHOD(bool, is_selected);
    METHOD(void, set_position_offset);
    METHOD(Vector2, get_position_offset);
};
struct GridContainer : public Container {
    using Container::Container;
    PROPERTY(columns, int64_t);
    METHOD(void, set_columns);
    METHOD(int64_t, get_columns);
};
struct MarginContainer : public Container {
    using Container::Container;
};
struct PanelContainer : public Container {
    using Container::Container;
};
struct ScrollContainer : public Container {
    using Container::Container;
    PROPERTY(follow_focus, bool);
    PROPERTY(scroll_horizontal, int64_t);
    PROPERTY(scroll_vertical, int64_t);
    PROPERTY(scroll_horizontal_custom_step, double);
    PROPERTY(scroll_vertical_custom_step, double);
    PROPERTY(horizontal_scroll_mode, int64_t);
    PROPERTY(vertical_scroll_mode, int64_t);
    PROPERTY(scroll_deadzone, int64_t);
    METHOD(void, set_h_scroll);
    METHOD(int64_t, get_h_scroll);
    METHOD(void, set_v_scroll);
    METHOD(int64_t, get_v_scroll);
    METHOD(void, set_horizontal_custom_step);
    METHOD(double, get_horizontal_custom_step);
    METHOD(void, set_vertical_custom_step);
    METHOD(double, get_vertical_custom_step);
    METHOD(void, set_horizontal_scroll_mode);
    METHOD(int64_t, get_horizontal_scroll_mode);
    METHOD(void, set_vertical_scroll_mode);
    METHOD(int64_t, get_vertical_scroll_mode);
    METHOD(void, set_deadzone);
    METHOD(int64_t, get_deadzone);
    METHOD(void, set_follow_focus);
    METHOD(bool, is_following_focus);
    METHOD(Object, get_h_scroll_bar);
    METHOD(Object, get_v_scroll_bar);
    METHOD(Variant, ensure_control_visible);
    static constexpr int64_t SCROLL_MODE_DISABLED = 0;
    static constexpr int64_t SCROLL_MODE_AUTO = 1;
    static constexpr int64_t SCROLL_MODE_SHOW_ALWAYS = 2;
    static constexpr int64_t SCROLL_MODE_SHOW_NEVER = 3;
};
struct SplitContainer : public Container {
    using Container::Container;
    PROPERTY(split_offset, int64_t);
    PROPERTY(collapsed, bool);
    PROPERTY(dragger_visibility, int64_t);
    PROPERTY(vertical, bool);
    METHOD(void, set_split_offset);
    METHOD(int64_t, get_split_offset);
    METHOD(Variant, clamp_split_offset);
    METHOD(void, set_collapsed);
    METHOD(bool, is_collapsed);
    METHOD(void, set_dragger_visibility);
    METHOD(int64_t, get_dragger_visibility);
    METHOD(void, set_vertical);
    METHOD(bool, is_vertical);
    static constexpr int64_t DRAGGER_VISIBLE = 0;
    static constexpr int64_t DRAGGER_HIDDEN = 1;
    static constexpr int64_t DRAGGER_HIDDEN_COLLAPSED = 2;
};
struct SubViewportContainer : public Container {
    using Container::Container;
    PROPERTY(stretch, bool);
    PROPERTY(stretch_shrink, int64_t);
    METHOD(bool, _propagate_input_event);
    METHOD(void, set_stretch);
    METHOD(bool, is_stretch_enabled);
    METHOD(void, set_stretch_shrink);
    METHOD(int64_t, get_stretch_shrink);
};
struct TabContainer : public Container {
    using Container::Container;
    PROPERTY(tab_alignment, int64_t);
    PROPERTY(current_tab, int64_t);
    PROPERTY(tabs_position, int64_t);
    PROPERTY(clip_tabs, bool);
    PROPERTY(tabs_visible, bool);
    PROPERTY(all_tabs_in_front, bool);
    PROPERTY(drag_to_rearrange_enabled, bool);
    PROPERTY(tabs_rearrange_group, int64_t);
    PROPERTY(use_hidden_tabs_for_min_size, bool);
    PROPERTY(tab_focus_mode, int64_t);
    PROPERTY(deselect_enabled, bool);
    METHOD(int64_t, get_tab_count);
    METHOD(void, set_current_tab);
    METHOD(int64_t, get_current_tab);
    METHOD(int64_t, get_previous_tab);
    METHOD(bool, select_previous_available);
    METHOD(bool, select_next_available);
    METHOD(Object, get_current_tab_control);
    METHOD(Object, get_tab_bar);
    METHOD(Object, get_tab_control);
    METHOD(void, set_tab_alignment);
    METHOD(int64_t, get_tab_alignment);
    METHOD(void, set_tabs_position);
    METHOD(int64_t, get_tabs_position);
    METHOD(void, set_clip_tabs);
    METHOD(bool, get_clip_tabs);
    METHOD(void, set_tabs_visible);
    METHOD(bool, are_tabs_visible);
    METHOD(void, set_all_tabs_in_front);
    METHOD(bool, is_all_tabs_in_front);
    METHOD(void, set_tab_title);
    METHOD(String, get_tab_title);
    METHOD(void, set_tab_tooltip);
    METHOD(String, get_tab_tooltip);
    METHOD(void, set_tab_icon);
    METHOD(Object, get_tab_icon);
    METHOD(void, set_tab_icon_max_width);
    METHOD(int64_t, get_tab_icon_max_width);
    METHOD(void, set_tab_disabled);
    METHOD(bool, is_tab_disabled);
    METHOD(void, set_tab_hidden);
    METHOD(bool, is_tab_hidden);
    METHOD(void, set_tab_metadata);
    METHOD(Variant, get_tab_metadata);
    METHOD(void, set_tab_button_icon);
    METHOD(Object, get_tab_button_icon);
    METHOD(int64_t, get_tab_idx_at_point);
    METHOD(int64_t, get_tab_idx_from_control);
    METHOD(void, set_popup);
    METHOD(Object, get_popup);
    METHOD(void, set_drag_to_rearrange_enabled);
    METHOD(bool, get_drag_to_rearrange_enabled);
    METHOD(void, set_tabs_rearrange_group);
    METHOD(int64_t, get_tabs_rearrange_group);
    METHOD(void, set_use_hidden_tabs_for_min_size);
    METHOD(bool, get_use_hidden_tabs_for_min_size);
    METHOD(void, set_tab_focus_mode);
    METHOD(int64_t, get_tab_focus_mode);
    METHOD(void, set_deselect_enabled);
    METHOD(bool, get_deselect_enabled);
    static constexpr int64_t POSITION_TOP = 0;
    static constexpr int64_t POSITION_BOTTOM = 1;
    static constexpr int64_t POSITION_MAX = 2;
};
struct AudioEffectAmplify : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(volume_db, double);
    METHOD(void, set_volume_db);
    METHOD(double, get_volume_db);
};
struct AudioEffectCapture : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(buffer_length, double);
    METHOD(bool, can_get_buffer);
    METHOD(PackedArray<Vector2>, get_buffer);
    METHOD(Variant, clear_buffer);
    METHOD(void, set_buffer_length);
    METHOD(double, get_buffer_length);
    METHOD(int64_t, get_frames_available);
    METHOD(int64_t, get_discarded_frames);
    METHOD(int64_t, get_buffer_length_frames);
    METHOD(int64_t, get_pushed_frames);
};
struct AudioEffectChorus : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(voice_count, int64_t);
    PROPERTY(dry, double);
    PROPERTY(wet, double);
    METHOD(void, set_voice_count);
    METHOD(int64_t, get_voice_count);
    METHOD(void, set_voice_delay_ms);
    METHOD(double, get_voice_delay_ms);
    METHOD(void, set_voice_rate_hz);
    METHOD(double, get_voice_rate_hz);
    METHOD(void, set_voice_depth_ms);
    METHOD(double, get_voice_depth_ms);
    METHOD(void, set_voice_level_db);
    METHOD(double, get_voice_level_db);
    METHOD(void, set_voice_cutoff_hz);
    METHOD(double, get_voice_cutoff_hz);
    METHOD(void, set_voice_pan);
    METHOD(double, get_voice_pan);
    METHOD(void, set_wet);
    METHOD(double, get_wet);
    METHOD(void, set_dry);
    METHOD(double, get_dry);
};
struct AudioEffectCompressor : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(threshold, double);
    PROPERTY(ratio, double);
    PROPERTY(gain, double);
    PROPERTY(attack_us, double);
    PROPERTY(release_ms, double);
    PROPERTY(mix, double);
    PROPERTY(sidechain, String);
    METHOD(void, set_threshold);
    METHOD(double, get_threshold);
    METHOD(void, set_ratio);
    METHOD(double, get_ratio);
    METHOD(void, set_gain);
    METHOD(double, get_gain);
    METHOD(void, set_attack_us);
    METHOD(double, get_attack_us);
    METHOD(void, set_release_ms);
    METHOD(double, get_release_ms);
    METHOD(void, set_mix);
    METHOD(double, get_mix);
    METHOD(void, set_sidechain);
    METHOD(String, get_sidechain);
};
struct AudioEffectDelay : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(dry, double);
    PROPERTY(tap1_active, bool);
    PROPERTY(tap1_delay_ms, double);
    PROPERTY(tap1_level_db, double);
    PROPERTY(tap1_pan, double);
    PROPERTY(tap2_active, bool);
    PROPERTY(tap2_delay_ms, double);
    PROPERTY(tap2_level_db, double);
    PROPERTY(tap2_pan, double);
    PROPERTY(feedback_active, bool);
    PROPERTY(feedback_delay_ms, double);
    PROPERTY(feedback_level_db, double);
    PROPERTY(feedback_lowpass, double);
    METHOD(void, set_dry);
    METHOD(double, get_dry);
    METHOD(void, set_tap1_active);
    METHOD(bool, is_tap1_active);
    METHOD(void, set_tap1_delay_ms);
    METHOD(double, get_tap1_delay_ms);
    METHOD(void, set_tap1_level_db);
    METHOD(double, get_tap1_level_db);
    METHOD(void, set_tap1_pan);
    METHOD(double, get_tap1_pan);
    METHOD(void, set_tap2_active);
    METHOD(bool, is_tap2_active);
    METHOD(void, set_tap2_delay_ms);
    METHOD(double, get_tap2_delay_ms);
    METHOD(void, set_tap2_level_db);
    METHOD(double, get_tap2_level_db);
    METHOD(void, set_tap2_pan);
    METHOD(double, get_tap2_pan);
    METHOD(void, set_feedback_active);
    METHOD(bool, is_feedback_active);
    METHOD(void, set_feedback_delay_ms);
    METHOD(double, get_feedback_delay_ms);
    METHOD(void, set_feedback_level_db);
    METHOD(double, get_feedback_level_db);
    METHOD(void, set_feedback_lowpass);
    METHOD(double, get_feedback_lowpass);
};
struct AudioEffectDistortion : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(mode, int64_t);
    PROPERTY(pre_gain, double);
    PROPERTY(keep_hf_hz, double);
    PROPERTY(drive, double);
    PROPERTY(post_gain, double);
    METHOD(void, set_mode);
    METHOD(int64_t, get_mode);
    METHOD(void, set_pre_gain);
    METHOD(double, get_pre_gain);
    METHOD(void, set_keep_hf_hz);
    METHOD(double, get_keep_hf_hz);
    METHOD(void, set_drive);
    METHOD(double, get_drive);
    METHOD(void, set_post_gain);
    METHOD(double, get_post_gain);
    static constexpr int64_t MODE_CLIP = 0;
    static constexpr int64_t MODE_ATAN = 1;
    static constexpr int64_t MODE_LOFI = 2;
    static constexpr int64_t MODE_OVERDRIVE = 3;
    static constexpr int64_t MODE_WAVESHAPE = 4;
};
struct AudioEffectEQ : public AudioEffect {
    using AudioEffect::AudioEffect;
    METHOD(void, set_band_gain_db);
    METHOD(double, get_band_gain_db);
    METHOD(int64_t, get_band_count);
};
struct AudioEffectFilter : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(cutoff_hz, double);
    PROPERTY(resonance, double);
    PROPERTY(gain, double);
    PROPERTY(db, int64_t);
    METHOD(void, set_cutoff);
    METHOD(double, get_cutoff);
    METHOD(void, set_resonance);
    METHOD(double, get_resonance);
    METHOD(void, set_gain);
    METHOD(double, get_gain);
    METHOD(void, set_db);
    METHOD(int64_t, get_db);
    static constexpr int64_t FILTER_6DB = 0;
    static constexpr int64_t FILTER_12DB = 1;
    static constexpr int64_t FILTER_18DB = 2;
    static constexpr int64_t FILTER_24DB = 3;
};
struct AudioEffectHardLimiter : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(pre_gain_db, double);
    PROPERTY(ceiling_db, double);
    PROPERTY(release, double);
    METHOD(void, set_ceiling_db);
    METHOD(double, get_ceiling_db);
    METHOD(void, set_pre_gain_db);
    METHOD(double, get_pre_gain_db);
    METHOD(void, set_release);
    METHOD(double, get_release);
};
struct AudioEffectLimiter : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(ceiling_db, double);
    PROPERTY(threshold_db, double);
    PROPERTY(soft_clip_db, double);
    PROPERTY(soft_clip_ratio, double);
    METHOD(void, set_ceiling_db);
    METHOD(double, get_ceiling_db);
    METHOD(void, set_threshold_db);
    METHOD(double, get_threshold_db);
    METHOD(void, set_soft_clip_db);
    METHOD(double, get_soft_clip_db);
    METHOD(void, set_soft_clip_ratio);
    METHOD(double, get_soft_clip_ratio);
};
struct AudioEffectPanner : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(pan, double);
    METHOD(void, set_pan);
    METHOD(double, get_pan);
};
struct AudioEffectPhaser : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(range_min_hz, double);
    PROPERTY(range_max_hz, double);
    PROPERTY(rate_hz, double);
    PROPERTY(feedback, double);
    PROPERTY(depth, double);
    METHOD(void, set_range_min_hz);
    METHOD(double, get_range_min_hz);
    METHOD(void, set_range_max_hz);
    METHOD(double, get_range_max_hz);
    METHOD(void, set_rate_hz);
    METHOD(double, get_rate_hz);
    METHOD(void, set_feedback);
    METHOD(double, get_feedback);
    METHOD(void, set_depth);
    METHOD(double, get_depth);
};
struct AudioEffectPitchShift : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(pitch_scale, double);
    PROPERTY(oversampling, double);
    PROPERTY(fft_size, int64_t);
    METHOD(void, set_pitch_scale);
    METHOD(double, get_pitch_scale);
    METHOD(void, set_oversampling);
    METHOD(int64_t, get_oversampling);
    METHOD(void, set_fft_size);
    METHOD(int64_t, get_fft_size);
    static constexpr int64_t FFT_SIZE_256 = 0;
    static constexpr int64_t FFT_SIZE_512 = 1;
    static constexpr int64_t FFT_SIZE_1024 = 2;
    static constexpr int64_t FFT_SIZE_2048 = 3;
    static constexpr int64_t FFT_SIZE_4096 = 4;
    static constexpr int64_t FFT_SIZE_MAX = 5;
};
struct AudioEffectRecord : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(format, int64_t);
    METHOD(void, set_recording_active);
    METHOD(bool, is_recording_active);
    METHOD(void, set_format);
    METHOD(int64_t, get_format);
    METHOD(Object, get_recording);
};
struct AudioEffectReverb : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(predelay_msec, double);
    PROPERTY(predelay_feedback, double);
    PROPERTY(room_size, double);
    PROPERTY(damping, double);
    PROPERTY(spread, double);
    PROPERTY(hipass, double);
    PROPERTY(dry, double);
    PROPERTY(wet, double);
    METHOD(void, set_predelay_msec);
    METHOD(double, get_predelay_msec);
    METHOD(void, set_predelay_feedback);
    METHOD(double, get_predelay_feedback);
    METHOD(void, set_room_size);
    METHOD(double, get_room_size);
    METHOD(void, set_damping);
    METHOD(double, get_damping);
    METHOD(void, set_spread);
    METHOD(double, get_spread);
    METHOD(void, set_dry);
    METHOD(double, get_dry);
    METHOD(void, set_wet);
    METHOD(double, get_wet);
    METHOD(void, set_hpf);
    METHOD(double, get_hpf);
};
struct AudioEffectSpectrumAnalyzer : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(buffer_length, double);
    PROPERTY(tap_back_pos, double);
    PROPERTY(fft_size, int64_t);
    METHOD(void, set_buffer_length);
    METHOD(double, get_buffer_length);
    METHOD(void, set_tap_back_pos);
    METHOD(double, get_tap_back_pos);
    METHOD(void, set_fft_size);
    METHOD(int64_t, get_fft_size);
    static constexpr int64_t FFT_SIZE_256 = 0;
    static constexpr int64_t FFT_SIZE_512 = 1;
    static constexpr int64_t FFT_SIZE_1024 = 2;
    static constexpr int64_t FFT_SIZE_2048 = 3;
    static constexpr int64_t FFT_SIZE_4096 = 4;
    static constexpr int64_t FFT_SIZE_MAX = 5;
};
struct AudioEffectStereoEnhance : public AudioEffect {
    using AudioEffect::AudioEffect;
    PROPERTY(pan_pullout, double);
    PROPERTY(time_pullout_ms, double);
    PROPERTY(surround, double);
    METHOD(void, set_pan_pullout);
    METHOD(double, get_pan_pullout);
    METHOD(void, set_time_pullout);
    METHOD(double, get_time_pullout);
    METHOD(void, set_surround);
    METHOD(double, get_surround);
};
struct AudioEffectBandLimitFilter : public AudioEffectFilter {
    using AudioEffectFilter::AudioEffectFilter;
};
struct AudioEffectBandPassFilter : public AudioEffectFilter {
    using AudioEffectFilter::AudioEffectFilter;
};
struct AudioEffectHighPassFilter : public AudioEffectFilter {
    using AudioEffectFilter::AudioEffectFilter;
};
struct AudioEffectHighShelfFilter : public AudioEffectFilter {
    using AudioEffectFilter::AudioEffectFilter;
};
struct AudioEffectLowPassFilter : public AudioEffectFilter {
    using AudioEffectFilter::AudioEffectFilter;
};
struct AudioEffectLowShelfFilter : public AudioEffectFilter {
    using AudioEffectFilter::AudioEffectFilter;
};
struct AudioEffectNotchFilter : public AudioEffectFilter {
    using AudioEffectFilter::AudioEffectFilter;
};
struct AudioEffectEQ10 : public AudioEffectEQ {
    using AudioEffectEQ::AudioEffectEQ;
};
struct AudioEffectEQ21 : public AudioEffectEQ {
    using AudioEffectEQ::AudioEffectEQ;
};
struct AudioEffectEQ6 : public AudioEffectEQ {
    using AudioEffectEQ::AudioEffectEQ;
};
struct AudioEffectSpectrumAnalyzerInstance : public AudioEffectInstance {
    using AudioEffectInstance::AudioEffectInstance;
    METHOD(Vector2, get_magnitude_for_frequency_range);
    static constexpr int64_t MAGNITUDE_AVERAGE = 0;
    static constexpr int64_t MAGNITUDE_MAX = 1;
};
struct AudioStreamGenerator : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(mix_rate, double);
    PROPERTY(buffer_length, double);
    METHOD(void, set_mix_rate);
    METHOD(double, get_mix_rate);
    METHOD(void, set_buffer_length);
    METHOD(double, get_buffer_length);
};
struct AudioStreamInteractive : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(initial_clip, int64_t);
    PROPERTY(clip_count, int64_t);
    PROPERTY(_transitions, Dictionary);
    METHOD(PackedArray<std::string>, _get_linked_undo_properties);
    METHOD(Variant, _inspector_array_swap_clip);
    METHOD(void, set_clip_count);
    METHOD(int64_t, get_clip_count);
    METHOD(void, set_initial_clip);
    METHOD(int64_t, get_initial_clip);
    METHOD(void, set_clip_name);
    METHOD(String, get_clip_name);
    METHOD(void, set_clip_stream);
    METHOD(Object, get_clip_stream);
    METHOD(void, set_clip_auto_advance);
    METHOD(int64_t, get_clip_auto_advance);
    METHOD(void, set_clip_auto_advance_next_clip);
    METHOD(int64_t, get_clip_auto_advance_next_clip);
    METHOD(Variant, add_transition);
    METHOD(bool, has_transition);
    METHOD(Variant, erase_transition);
    METHOD(PackedArray<int32_t>, get_transition_list);
    METHOD(int64_t, get_transition_from_time);
    METHOD(int64_t, get_transition_to_time);
    METHOD(int64_t, get_transition_fade_mode);
    METHOD(double, get_transition_fade_beats);
    METHOD(bool, is_transition_using_filler_clip);
    METHOD(int64_t, get_transition_filler_clip);
    METHOD(bool, is_transition_holding_previous);
    METHOD(Variant, _set_transitions);
    METHOD(Dictionary, _get_transitions);
    static constexpr int64_t TRANSITION_FROM_TIME_IMMEDIATE = 0;
    static constexpr int64_t TRANSITION_FROM_TIME_NEXT_BEAT = 1;
    static constexpr int64_t TRANSITION_FROM_TIME_NEXT_BAR = 2;
    static constexpr int64_t TRANSITION_FROM_TIME_END = 3;
    static constexpr int64_t TRANSITION_TO_TIME_SAME_POSITION = 0;
    static constexpr int64_t TRANSITION_TO_TIME_START = 1;
    static constexpr int64_t FADE_DISABLED = 0;
    static constexpr int64_t FADE_IN = 1;
    static constexpr int64_t FADE_OUT = 2;
    static constexpr int64_t FADE_CROSS = 3;
    static constexpr int64_t FADE_AUTOMATIC = 4;
    static constexpr int64_t AUTO_ADVANCE_DISABLED = 0;
    static constexpr int64_t AUTO_ADVANCE_ENABLED = 1;
    static constexpr int64_t AUTO_ADVANCE_RETURN_TO_HOLD = 2;
    static constexpr int64_t CLIP_ANY = -1;
};
struct AudioStreamMP3 : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(data, PackedArray<uint8_t>);
    PROPERTY(bpm, double);
    PROPERTY(beat_count, int64_t);
    PROPERTY(bar_beats, int64_t);
    PROPERTY(loop, bool);
    PROPERTY(loop_offset, double);
    METHOD(void, set_data);
    METHOD(PackedArray<uint8_t>, get_data);
    METHOD(void, set_loop);
    METHOD(bool, has_loop);
    METHOD(void, set_loop_offset);
    METHOD(double, get_loop_offset);
    METHOD(void, set_bpm);
    METHOD(double, get_bpm);
    METHOD(void, set_beat_count);
    METHOD(int64_t, get_beat_count);
    METHOD(void, set_bar_beats);
    METHOD(int64_t, get_bar_beats);
};
struct AudioStreamMicrophone : public AudioStream {
    using AudioStream::AudioStream;
};
struct AudioStreamOggVorbis : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(packet_sequence, Object);
    PROPERTY(bpm, double);
    PROPERTY(beat_count, int64_t);
    PROPERTY(bar_beats, int64_t);
    PROPERTY(loop, bool);
    PROPERTY(loop_offset, double);
    METHOD(Object, load_from_buffer);
    METHOD(Object, load_from_file);
    METHOD(void, set_packet_sequence);
    METHOD(Object, get_packet_sequence);
    METHOD(void, set_loop);
    METHOD(bool, has_loop);
    METHOD(void, set_loop_offset);
    METHOD(double, get_loop_offset);
    METHOD(void, set_bpm);
    METHOD(double, get_bpm);
    METHOD(void, set_beat_count);
    METHOD(int64_t, get_beat_count);
    METHOD(void, set_bar_beats);
    METHOD(int64_t, get_bar_beats);
};
struct AudioStreamPlaylist : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(shuffle, bool);
    PROPERTY(loop, bool);
    PROPERTY(fade_time, double);
    PROPERTY(stream_count, int64_t);
    PROPERTY(stream_0, Object);
    PROPERTY(stream_1, Object);
    PROPERTY(stream_2, Object);
    PROPERTY(stream_3, Object);
    PROPERTY(stream_4, Object);
    PROPERTY(stream_5, Object);
    PROPERTY(stream_6, Object);
    PROPERTY(stream_7, Object);
    PROPERTY(stream_8, Object);
    PROPERTY(stream_9, Object);
    PROPERTY(stream_10, Object);
    PROPERTY(stream_11, Object);
    PROPERTY(stream_12, Object);
    PROPERTY(stream_13, Object);
    PROPERTY(stream_14, Object);
    PROPERTY(stream_15, Object);
    PROPERTY(stream_16, Object);
    PROPERTY(stream_17, Object);
    PROPERTY(stream_18, Object);
    PROPERTY(stream_19, Object);
    PROPERTY(stream_20, Object);
    PROPERTY(stream_21, Object);
    PROPERTY(stream_22, Object);
    PROPERTY(stream_23, Object);
    PROPERTY(stream_24, Object);
    PROPERTY(stream_25, Object);
    PROPERTY(stream_26, Object);
    PROPERTY(stream_27, Object);
    PROPERTY(stream_28, Object);
    PROPERTY(stream_29, Object);
    PROPERTY(stream_30, Object);
    PROPERTY(stream_31, Object);
    PROPERTY(stream_32, Object);
    PROPERTY(stream_33, Object);
    PROPERTY(stream_34, Object);
    PROPERTY(stream_35, Object);
    PROPERTY(stream_36, Object);
    PROPERTY(stream_37, Object);
    PROPERTY(stream_38, Object);
    PROPERTY(stream_39, Object);
    PROPERTY(stream_40, Object);
    PROPERTY(stream_41, Object);
    PROPERTY(stream_42, Object);
    PROPERTY(stream_43, Object);
    PROPERTY(stream_44, Object);
    PROPERTY(stream_45, Object);
    PROPERTY(stream_46, Object);
    PROPERTY(stream_47, Object);
    PROPERTY(stream_48, Object);
    PROPERTY(stream_49, Object);
    PROPERTY(stream_50, Object);
    PROPERTY(stream_51, Object);
    PROPERTY(stream_52, Object);
    PROPERTY(stream_53, Object);
    PROPERTY(stream_54, Object);
    PROPERTY(stream_55, Object);
    PROPERTY(stream_56, Object);
    PROPERTY(stream_57, Object);
    PROPERTY(stream_58, Object);
    PROPERTY(stream_59, Object);
    PROPERTY(stream_60, Object);
    PROPERTY(stream_61, Object);
    PROPERTY(stream_62, Object);
    PROPERTY(stream_63, Object);
    METHOD(void, set_stream_count);
    METHOD(int64_t, get_stream_count);
    METHOD(double, get_bpm);
    METHOD(void, set_list_stream);
    METHOD(Object, get_list_stream);
    METHOD(void, set_shuffle);
    METHOD(bool, get_shuffle);
    METHOD(void, set_fade_time);
    METHOD(double, get_fade_time);
    METHOD(void, set_loop);
    METHOD(bool, has_loop);
    static constexpr int64_t MAX_STREAMS = 64;
};
struct AudioStreamPolyphonic : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(polyphony, int64_t);
    METHOD(void, set_polyphony);
    METHOD(int64_t, get_polyphony);
};
struct AudioStreamRandomizer : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(playback_mode, int64_t);
    PROPERTY(random_pitch, double);
    PROPERTY(random_volume_offset_db, double);
    PROPERTY(streams_count, int64_t);
    METHOD(Variant, add_stream);
    METHOD(Variant, move_stream);
    METHOD(Variant, remove_stream);
    METHOD(void, set_stream);
    METHOD(Object, get_stream);
    METHOD(void, set_stream_probability_weight);
    METHOD(double, get_stream_probability_weight);
    METHOD(void, set_streams_count);
    METHOD(int64_t, get_streams_count);
    METHOD(void, set_random_pitch);
    METHOD(double, get_random_pitch);
    METHOD(void, set_random_volume_offset_db);
    METHOD(double, get_random_volume_offset_db);
    METHOD(void, set_playback_mode);
    METHOD(int64_t, get_playback_mode);
    static constexpr int64_t PLAYBACK_RANDOM_NO_REPEATS = 0;
    static constexpr int64_t PLAYBACK_RANDOM = 1;
    static constexpr int64_t PLAYBACK_SEQUENTIAL = 2;
};
struct AudioStreamSynchronized : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(stream_count, int64_t);
    METHOD(void, set_stream_count);
    METHOD(int64_t, get_stream_count);
    METHOD(void, set_sync_stream);
    METHOD(Object, get_sync_stream);
    METHOD(void, set_sync_stream_volume);
    METHOD(double, get_sync_stream_volume);
    static constexpr int64_t MAX_STREAMS = 32;
};
struct AudioStreamWAV : public AudioStream {
    using AudioStream::AudioStream;
    PROPERTY(data, PackedArray<uint8_t>);
    PROPERTY(format, int64_t);
    PROPERTY(loop_mode, int64_t);
    PROPERTY(loop_begin, int64_t);
    PROPERTY(loop_end, int64_t);
    PROPERTY(mix_rate, int64_t);
    PROPERTY(stereo, bool);
    METHOD(void, set_data);
    METHOD(PackedArray<uint8_t>, get_data);
    METHOD(void, set_format);
    METHOD(int64_t, get_format);
    METHOD(void, set_loop_mode);
    METHOD(int64_t, get_loop_mode);
    METHOD(void, set_loop_begin);
    METHOD(int64_t, get_loop_begin);
    METHOD(void, set_loop_end);
    METHOD(int64_t, get_loop_end);
    METHOD(void, set_mix_rate);
    METHOD(int64_t, get_mix_rate);
    METHOD(void, set_stereo);
    METHOD(bool, is_stereo);
    METHOD(int64_t, save_to_wav);
    static constexpr int64_t FORMAT_8_BITS = 0;
    static constexpr int64_t FORMAT_16_BITS = 1;
    static constexpr int64_t FORMAT_IMA_ADPCM = 2;
    static constexpr int64_t FORMAT_QOA = 3;
    static constexpr int64_t LOOP_DISABLED = 0;
    static constexpr int64_t LOOP_FORWARD = 1;
    static constexpr int64_t LOOP_PINGPONG = 2;
    static constexpr int64_t LOOP_BACKWARD = 3;
};
struct AudioStreamPlaybackInteractive : public AudioStreamPlayback {
    using AudioStreamPlayback::AudioStreamPlayback;
    METHOD(Variant, switch_to_clip_by_name);
    METHOD(Variant, switch_to_clip);
};
struct AudioStreamPlaybackPlaylist : public AudioStreamPlayback {
    using AudioStreamPlayback::AudioStreamPlayback;
};
struct AudioStreamPlaybackPolyphonic : public AudioStreamPlayback {
    using AudioStreamPlayback::AudioStreamPlayback;
    METHOD(int64_t, play_stream);
    METHOD(void, set_stream_volume);
    METHOD(void, set_stream_pitch_scale);
    METHOD(bool, is_stream_playing);
    METHOD(Variant, stop_stream);
    static constexpr int64_t INVALID_ID = -1;
};
struct AudioStreamPlaybackResampled : public AudioStreamPlayback {
    using AudioStreamPlayback::AudioStreamPlayback;
    METHOD(int64_t, _mix_resampled);
    METHOD(double, _get_stream_sampling_rate);
    METHOD(Variant, begin_resample);
};
struct AudioStreamPlaybackSynchronized : public AudioStreamPlayback {
    using AudioStreamPlayback::AudioStreamPlayback;
};
struct AudioStreamGeneratorPlayback : public AudioStreamPlaybackResampled {
    using AudioStreamPlaybackResampled::AudioStreamPlaybackResampled;
    METHOD(bool, push_frame);
    METHOD(bool, can_push_buffer);
    METHOD(bool, push_buffer);
    METHOD(int64_t, get_frames_available);
    METHOD(int64_t, get_skips);
    METHOD(Variant, clear_buffer);
};
struct AudioStreamPlaybackOggVorbis : public AudioStreamPlaybackResampled {
    using AudioStreamPlaybackResampled::AudioStreamPlaybackResampled;
};
struct BaseMaterial3D : public Material {
    using Material::Material;
    PROPERTY(transparency, int64_t);
    PROPERTY(alpha_scissor_threshold, double);
    PROPERTY(alpha_hash_scale, double);
    PROPERTY(alpha_antialiasing_mode, int64_t);
    PROPERTY(alpha_antialiasing_edge, double);
    PROPERTY(blend_mode, int64_t);
    PROPERTY(cull_mode, int64_t);
    PROPERTY(depth_draw_mode, int64_t);
    PROPERTY(no_depth_test, bool);
    PROPERTY(shading_mode, int64_t);
    PROPERTY(diffuse_mode, int64_t);
    PROPERTY(specular_mode, int64_t);
    PROPERTY(disable_ambient_light, bool);
    PROPERTY(disable_fog, bool);
    PROPERTY(vertex_color_use_as_albedo, bool);
    PROPERTY(vertex_color_is_srgb, bool);
    PROPERTY(albedo_color, Color);
    PROPERTY(albedo_texture, Object);
    PROPERTY(albedo_texture_force_srgb, bool);
    PROPERTY(albedo_texture_msdf, bool);
    PROPERTY(orm_texture, Object);
    PROPERTY(metallic, double);
    PROPERTY(metallic_specular, double);
    PROPERTY(metallic_texture, Object);
    PROPERTY(metallic_texture_channel, int64_t);
    PROPERTY(roughness, double);
    PROPERTY(roughness_texture, Object);
    PROPERTY(roughness_texture_channel, int64_t);
    PROPERTY(emission_enabled, bool);
    PROPERTY(emission, Color);
    PROPERTY(emission_energy_multiplier, double);
    PROPERTY(emission_intensity, double);
    PROPERTY(emission_operator, int64_t);
    PROPERTY(emission_on_uv2, bool);
    PROPERTY(emission_texture, Object);
    PROPERTY(normal_enabled, bool);
    PROPERTY(normal_scale, double);
    PROPERTY(normal_texture, Object);
    PROPERTY(rim_enabled, bool);
    PROPERTY(rim, double);
    PROPERTY(rim_tint, double);
    PROPERTY(rim_texture, Object);
    PROPERTY(clearcoat_enabled, bool);
    PROPERTY(clearcoat, double);
    PROPERTY(clearcoat_roughness, double);
    PROPERTY(clearcoat_texture, Object);
    PROPERTY(anisotropy_enabled, bool);
    PROPERTY(anisotropy, double);
    PROPERTY(anisotropy_flowmap, Object);
    PROPERTY(ao_enabled, bool);
    PROPERTY(ao_light_affect, double);
    PROPERTY(ao_texture, Object);
    PROPERTY(ao_on_uv2, bool);
    PROPERTY(ao_texture_channel, int64_t);
    PROPERTY(heightmap_enabled, bool);
    PROPERTY(heightmap_scale, double);
    PROPERTY(heightmap_deep_parallax, bool);
    PROPERTY(heightmap_min_layers, int64_t);
    PROPERTY(heightmap_max_layers, int64_t);
    PROPERTY(heightmap_flip_tangent, bool);
    PROPERTY(heightmap_flip_binormal, bool);
    PROPERTY(heightmap_texture, Object);
    PROPERTY(heightmap_flip_texture, bool);
    PROPERTY(subsurf_scatter_enabled, bool);
    PROPERTY(subsurf_scatter_strength, double);
    PROPERTY(subsurf_scatter_skin_mode, bool);
    PROPERTY(subsurf_scatter_texture, Object);
    PROPERTY(subsurf_scatter_transmittance_enabled, bool);
    PROPERTY(subsurf_scatter_transmittance_color, Color);
    PROPERTY(subsurf_scatter_transmittance_texture, Object);
    PROPERTY(subsurf_scatter_transmittance_depth, double);
    PROPERTY(subsurf_scatter_transmittance_boost, double);
    PROPERTY(backlight_enabled, bool);
    PROPERTY(backlight, Color);
    PROPERTY(backlight_texture, Object);
    PROPERTY(refraction_enabled, bool);
    PROPERTY(refraction_scale, double);
    PROPERTY(refraction_texture, Object);
    PROPERTY(refraction_texture_channel, int64_t);
    PROPERTY(detail_enabled, bool);
    PROPERTY(detail_mask, Object);
    PROPERTY(detail_blend_mode, int64_t);
    PROPERTY(detail_uv_layer, int64_t);
    PROPERTY(detail_albedo, Object);
    PROPERTY(detail_normal, Object);
    PROPERTY(uv1_scale, Vector3);
    PROPERTY(uv1_offset, Vector3);
    PROPERTY(uv1_triplanar, bool);
    PROPERTY(uv1_triplanar_sharpness, double);
    PROPERTY(uv1_world_triplanar, bool);
    PROPERTY(uv2_scale, Vector3);
    PROPERTY(uv2_offset, Vector3);
    PROPERTY(uv2_triplanar, bool);
    PROPERTY(uv2_triplanar_sharpness, double);
    PROPERTY(uv2_world_triplanar, bool);
    PROPERTY(texture_filter, int64_t);
    PROPERTY(texture_repeat, bool);
    PROPERTY(disable_receive_shadows, bool);
    PROPERTY(shadow_to_opacity, bool);
    PROPERTY(billboard_mode, int64_t);
    PROPERTY(billboard_keep_scale, bool);
    PROPERTY(particles_anim_h_frames, int64_t);
    PROPERTY(particles_anim_v_frames, int64_t);
    PROPERTY(particles_anim_loop, bool);
    PROPERTY(grow, bool);
    PROPERTY(grow_amount, double);
    PROPERTY(fixed_size, bool);
    PROPERTY(use_point_size, bool);
    PROPERTY(point_size, double);
    PROPERTY(use_particle_trails, bool);
    PROPERTY(proximity_fade_enabled, bool);
    PROPERTY(proximity_fade_distance, double);
    PROPERTY(msdf_pixel_range, double);
    PROPERTY(msdf_outline_size, double);
    PROPERTY(distance_fade_mode, int64_t);
    PROPERTY(distance_fade_min_distance, double);
    PROPERTY(distance_fade_max_distance, double);
    METHOD(void, set_albedo);
    METHOD(Color, get_albedo);
    METHOD(void, set_transparency);
    METHOD(int64_t, get_transparency);
    METHOD(void, set_alpha_antialiasing);
    METHOD(int64_t, get_alpha_antialiasing);
    METHOD(void, set_alpha_antialiasing_edge);
    METHOD(double, get_alpha_antialiasing_edge);
    METHOD(void, set_shading_mode);
    METHOD(int64_t, get_shading_mode);
    METHOD(void, set_specular);
    METHOD(double, get_specular);
    METHOD(void, set_metallic);
    METHOD(double, get_metallic);
    METHOD(void, set_roughness);
    METHOD(double, get_roughness);
    METHOD(void, set_emission);
    METHOD(Color, get_emission);
    METHOD(void, set_emission_energy_multiplier);
    METHOD(double, get_emission_energy_multiplier);
    METHOD(void, set_emission_intensity);
    METHOD(double, get_emission_intensity);
    METHOD(void, set_normal_scale);
    METHOD(double, get_normal_scale);
    METHOD(void, set_rim);
    METHOD(double, get_rim);
    METHOD(void, set_rim_tint);
    METHOD(double, get_rim_tint);
    METHOD(void, set_clearcoat);
    METHOD(double, get_clearcoat);
    METHOD(void, set_clearcoat_roughness);
    METHOD(double, get_clearcoat_roughness);
    METHOD(void, set_anisotropy);
    METHOD(double, get_anisotropy);
    METHOD(void, set_heightmap_scale);
    METHOD(double, get_heightmap_scale);
    METHOD(void, set_subsurface_scattering_strength);
    METHOD(double, get_subsurface_scattering_strength);
    METHOD(void, set_transmittance_color);
    METHOD(Color, get_transmittance_color);
    METHOD(void, set_transmittance_depth);
    METHOD(double, get_transmittance_depth);
    METHOD(void, set_transmittance_boost);
    METHOD(double, get_transmittance_boost);
    METHOD(void, set_backlight);
    METHOD(Color, get_backlight);
    METHOD(void, set_refraction);
    METHOD(double, get_refraction);
    METHOD(void, set_point_size);
    METHOD(double, get_point_size);
    METHOD(void, set_detail_uv);
    METHOD(int64_t, get_detail_uv);
    METHOD(void, set_blend_mode);
    METHOD(int64_t, get_blend_mode);
    METHOD(void, set_depth_draw_mode);
    METHOD(int64_t, get_depth_draw_mode);
    METHOD(void, set_cull_mode);
    METHOD(int64_t, get_cull_mode);
    METHOD(void, set_diffuse_mode);
    METHOD(int64_t, get_diffuse_mode);
    METHOD(void, set_specular_mode);
    METHOD(int64_t, get_specular_mode);
    METHOD(void, set_flag);
    METHOD(bool, get_flag);
    METHOD(void, set_texture_filter);
    METHOD(int64_t, get_texture_filter);
    METHOD(void, set_feature);
    METHOD(bool, get_feature);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_detail_blend_mode);
    METHOD(int64_t, get_detail_blend_mode);
    METHOD(void, set_uv1_scale);
    METHOD(Vector3, get_uv1_scale);
    METHOD(void, set_uv1_offset);
    METHOD(Vector3, get_uv1_offset);
    METHOD(void, set_uv1_triplanar_blend_sharpness);
    METHOD(double, get_uv1_triplanar_blend_sharpness);
    METHOD(void, set_uv2_scale);
    METHOD(Vector3, get_uv2_scale);
    METHOD(void, set_uv2_offset);
    METHOD(Vector3, get_uv2_offset);
    METHOD(void, set_uv2_triplanar_blend_sharpness);
    METHOD(double, get_uv2_triplanar_blend_sharpness);
    METHOD(void, set_billboard_mode);
    METHOD(int64_t, get_billboard_mode);
    METHOD(void, set_particles_anim_h_frames);
    METHOD(int64_t, get_particles_anim_h_frames);
    METHOD(void, set_particles_anim_v_frames);
    METHOD(int64_t, get_particles_anim_v_frames);
    METHOD(void, set_particles_anim_loop);
    METHOD(bool, get_particles_anim_loop);
    METHOD(void, set_heightmap_deep_parallax);
    METHOD(bool, is_heightmap_deep_parallax_enabled);
    METHOD(void, set_heightmap_deep_parallax_min_layers);
    METHOD(int64_t, get_heightmap_deep_parallax_min_layers);
    METHOD(void, set_heightmap_deep_parallax_max_layers);
    METHOD(int64_t, get_heightmap_deep_parallax_max_layers);
    METHOD(void, set_heightmap_deep_parallax_flip_tangent);
    METHOD(bool, get_heightmap_deep_parallax_flip_tangent);
    METHOD(void, set_heightmap_deep_parallax_flip_binormal);
    METHOD(bool, get_heightmap_deep_parallax_flip_binormal);
    METHOD(void, set_grow);
    METHOD(double, get_grow);
    METHOD(void, set_emission_operator);
    METHOD(int64_t, get_emission_operator);
    METHOD(void, set_ao_light_affect);
    METHOD(double, get_ao_light_affect);
    METHOD(void, set_alpha_scissor_threshold);
    METHOD(double, get_alpha_scissor_threshold);
    METHOD(void, set_alpha_hash_scale);
    METHOD(double, get_alpha_hash_scale);
    METHOD(void, set_grow_enabled);
    METHOD(bool, is_grow_enabled);
    METHOD(void, set_metallic_texture_channel);
    METHOD(int64_t, get_metallic_texture_channel);
    METHOD(void, set_roughness_texture_channel);
    METHOD(int64_t, get_roughness_texture_channel);
    METHOD(void, set_ao_texture_channel);
    METHOD(int64_t, get_ao_texture_channel);
    METHOD(void, set_refraction_texture_channel);
    METHOD(int64_t, get_refraction_texture_channel);
    METHOD(void, set_proximity_fade_enabled);
    METHOD(bool, is_proximity_fade_enabled);
    METHOD(void, set_proximity_fade_distance);
    METHOD(double, get_proximity_fade_distance);
    METHOD(void, set_msdf_pixel_range);
    METHOD(double, get_msdf_pixel_range);
    METHOD(void, set_msdf_outline_size);
    METHOD(double, get_msdf_outline_size);
    METHOD(void, set_distance_fade);
    METHOD(int64_t, get_distance_fade);
    METHOD(void, set_distance_fade_max_distance);
    METHOD(double, get_distance_fade_max_distance);
    METHOD(void, set_distance_fade_min_distance);
    METHOD(double, get_distance_fade_min_distance);
    static constexpr int64_t TEXTURE_ALBEDO = 0;
    static constexpr int64_t TEXTURE_METALLIC = 1;
    static constexpr int64_t TEXTURE_ROUGHNESS = 2;
    static constexpr int64_t TEXTURE_EMISSION = 3;
    static constexpr int64_t TEXTURE_NORMAL = 4;
    static constexpr int64_t TEXTURE_RIM = 5;
    static constexpr int64_t TEXTURE_CLEARCOAT = 6;
    static constexpr int64_t TEXTURE_FLOWMAP = 7;
    static constexpr int64_t TEXTURE_AMBIENT_OCCLUSION = 8;
    static constexpr int64_t TEXTURE_HEIGHTMAP = 9;
    static constexpr int64_t TEXTURE_SUBSURFACE_SCATTERING = 10;
    static constexpr int64_t TEXTURE_SUBSURFACE_TRANSMITTANCE = 11;
    static constexpr int64_t TEXTURE_BACKLIGHT = 12;
    static constexpr int64_t TEXTURE_REFRACTION = 13;
    static constexpr int64_t TEXTURE_DETAIL_MASK = 14;
    static constexpr int64_t TEXTURE_DETAIL_ALBEDO = 15;
    static constexpr int64_t TEXTURE_DETAIL_NORMAL = 16;
    static constexpr int64_t TEXTURE_ORM = 17;
    static constexpr int64_t TEXTURE_MAX = 18;
    static constexpr int64_t TEXTURE_FILTER_NEAREST = 0;
    static constexpr int64_t TEXTURE_FILTER_LINEAR = 1;
    static constexpr int64_t TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 2;
    static constexpr int64_t TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 3;
    static constexpr int64_t TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC = 4;
    static constexpr int64_t TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC = 5;
    static constexpr int64_t TEXTURE_FILTER_MAX = 6;
    static constexpr int64_t DETAIL_UV_1 = 0;
    static constexpr int64_t DETAIL_UV_2 = 1;
    static constexpr int64_t TRANSPARENCY_DISABLED = 0;
    static constexpr int64_t TRANSPARENCY_ALPHA = 1;
    static constexpr int64_t TRANSPARENCY_ALPHA_SCISSOR = 2;
    static constexpr int64_t TRANSPARENCY_ALPHA_HASH = 3;
    static constexpr int64_t TRANSPARENCY_ALPHA_DEPTH_PRE_PASS = 4;
    static constexpr int64_t TRANSPARENCY_MAX = 5;
    static constexpr int64_t SHADING_MODE_UNSHADED = 0;
    static constexpr int64_t SHADING_MODE_PER_PIXEL = 1;
    static constexpr int64_t SHADING_MODE_PER_VERTEX = 2;
    static constexpr int64_t SHADING_MODE_MAX = 3;
    static constexpr int64_t FEATURE_EMISSION = 0;
    static constexpr int64_t FEATURE_NORMAL_MAPPING = 1;
    static constexpr int64_t FEATURE_RIM = 2;
    static constexpr int64_t FEATURE_CLEARCOAT = 3;
    static constexpr int64_t FEATURE_ANISOTROPY = 4;
    static constexpr int64_t FEATURE_AMBIENT_OCCLUSION = 5;
    static constexpr int64_t FEATURE_HEIGHT_MAPPING = 6;
    static constexpr int64_t FEATURE_SUBSURFACE_SCATTERING = 7;
    static constexpr int64_t FEATURE_SUBSURFACE_TRANSMITTANCE = 8;
    static constexpr int64_t FEATURE_BACKLIGHT = 9;
    static constexpr int64_t FEATURE_REFRACTION = 10;
    static constexpr int64_t FEATURE_DETAIL = 11;
    static constexpr int64_t FEATURE_MAX = 12;
    static constexpr int64_t BLEND_MODE_MIX = 0;
    static constexpr int64_t BLEND_MODE_ADD = 1;
    static constexpr int64_t BLEND_MODE_SUB = 2;
    static constexpr int64_t BLEND_MODE_MUL = 3;
    static constexpr int64_t BLEND_MODE_PREMULT_ALPHA = 4;
    static constexpr int64_t ALPHA_ANTIALIASING_OFF = 0;
    static constexpr int64_t ALPHA_ANTIALIASING_ALPHA_TO_COVERAGE = 1;
    static constexpr int64_t ALPHA_ANTIALIASING_ALPHA_TO_COVERAGE_AND_TO_ONE = 2;
    static constexpr int64_t DEPTH_DRAW_OPAQUE_ONLY = 0;
    static constexpr int64_t DEPTH_DRAW_ALWAYS = 1;
    static constexpr int64_t DEPTH_DRAW_DISABLED = 2;
    static constexpr int64_t CULL_BACK = 0;
    static constexpr int64_t CULL_FRONT = 1;
    static constexpr int64_t CULL_DISABLED = 2;
    static constexpr int64_t FLAG_DISABLE_DEPTH_TEST = 0;
    static constexpr int64_t FLAG_ALBEDO_FROM_VERTEX_COLOR = 1;
    static constexpr int64_t FLAG_SRGB_VERTEX_COLOR = 2;
    static constexpr int64_t FLAG_USE_POINT_SIZE = 3;
    static constexpr int64_t FLAG_FIXED_SIZE = 4;
    static constexpr int64_t FLAG_BILLBOARD_KEEP_SCALE = 5;
    static constexpr int64_t FLAG_UV1_USE_TRIPLANAR = 6;
    static constexpr int64_t FLAG_UV2_USE_TRIPLANAR = 7;
    static constexpr int64_t FLAG_UV1_USE_WORLD_TRIPLANAR = 8;
    static constexpr int64_t FLAG_UV2_USE_WORLD_TRIPLANAR = 9;
    static constexpr int64_t FLAG_AO_ON_UV2 = 10;
    static constexpr int64_t FLAG_EMISSION_ON_UV2 = 11;
    static constexpr int64_t FLAG_ALBEDO_TEXTURE_FORCE_SRGB = 12;
    static constexpr int64_t FLAG_DONT_RECEIVE_SHADOWS = 13;
    static constexpr int64_t FLAG_DISABLE_AMBIENT_LIGHT = 14;
    static constexpr int64_t FLAG_USE_SHADOW_TO_OPACITY = 15;
    static constexpr int64_t FLAG_USE_TEXTURE_REPEAT = 16;
    static constexpr int64_t FLAG_INVERT_HEIGHTMAP = 17;
    static constexpr int64_t FLAG_SUBSURFACE_MODE_SKIN = 18;
    static constexpr int64_t FLAG_PARTICLE_TRAILS_MODE = 19;
    static constexpr int64_t FLAG_ALBEDO_TEXTURE_MSDF = 20;
    static constexpr int64_t FLAG_DISABLE_FOG = 21;
    static constexpr int64_t FLAG_MAX = 22;
    static constexpr int64_t DIFFUSE_BURLEY = 0;
    static constexpr int64_t DIFFUSE_LAMBERT = 1;
    static constexpr int64_t DIFFUSE_LAMBERT_WRAP = 2;
    static constexpr int64_t DIFFUSE_TOON = 3;
    static constexpr int64_t SPECULAR_SCHLICK_GGX = 0;
    static constexpr int64_t SPECULAR_TOON = 1;
    static constexpr int64_t SPECULAR_DISABLED = 2;
    static constexpr int64_t BILLBOARD_DISABLED = 0;
    static constexpr int64_t BILLBOARD_ENABLED = 1;
    static constexpr int64_t BILLBOARD_FIXED_Y = 2;
    static constexpr int64_t BILLBOARD_PARTICLES = 3;
    static constexpr int64_t TEXTURE_CHANNEL_RED = 0;
    static constexpr int64_t TEXTURE_CHANNEL_GREEN = 1;
    static constexpr int64_t TEXTURE_CHANNEL_BLUE = 2;
    static constexpr int64_t TEXTURE_CHANNEL_ALPHA = 3;
    static constexpr int64_t TEXTURE_CHANNEL_GRAYSCALE = 4;
    static constexpr int64_t EMISSION_OP_ADD = 0;
    static constexpr int64_t EMISSION_OP_MULTIPLY = 1;
    static constexpr int64_t DISTANCE_FADE_DISABLED = 0;
    static constexpr int64_t DISTANCE_FADE_PIXEL_ALPHA = 1;
    static constexpr int64_t DISTANCE_FADE_PIXEL_DITHER = 2;
    static constexpr int64_t DISTANCE_FADE_OBJECT_DITHER = 3;
};
struct CanvasItemMaterial : public Material {
    using Material::Material;
    PROPERTY(blend_mode, int64_t);
    PROPERTY(light_mode, int64_t);
    PROPERTY(particles_animation, bool);
    PROPERTY(particles_anim_h_frames, int64_t);
    PROPERTY(particles_anim_v_frames, int64_t);
    PROPERTY(particles_anim_loop, bool);
    METHOD(void, set_blend_mode);
    METHOD(int64_t, get_blend_mode);
    METHOD(void, set_light_mode);
    METHOD(int64_t, get_light_mode);
    METHOD(void, set_particles_animation);
    METHOD(bool, get_particles_animation);
    METHOD(void, set_particles_anim_h_frames);
    METHOD(int64_t, get_particles_anim_h_frames);
    METHOD(void, set_particles_anim_v_frames);
    METHOD(int64_t, get_particles_anim_v_frames);
    METHOD(void, set_particles_anim_loop);
    METHOD(bool, get_particles_anim_loop);
    static constexpr int64_t BLEND_MODE_MIX = 0;
    static constexpr int64_t BLEND_MODE_ADD = 1;
    static constexpr int64_t BLEND_MODE_SUB = 2;
    static constexpr int64_t BLEND_MODE_MUL = 3;
    static constexpr int64_t BLEND_MODE_PREMULT_ALPHA = 4;
    static constexpr int64_t LIGHT_MODE_NORMAL = 0;
    static constexpr int64_t LIGHT_MODE_UNSHADED = 1;
    static constexpr int64_t LIGHT_MODE_LIGHT_ONLY = 2;
};
struct FogMaterial : public Material {
    using Material::Material;
    PROPERTY(density, double);
    PROPERTY(albedo, Color);
    PROPERTY(emission, Color);
    PROPERTY(height_falloff, double);
    PROPERTY(edge_fade, double);
    PROPERTY(density_texture, Object);
    METHOD(void, set_density);
    METHOD(double, get_density);
    METHOD(void, set_albedo);
    METHOD(Color, get_albedo);
    METHOD(void, set_emission);
    METHOD(Color, get_emission);
    METHOD(void, set_height_falloff);
    METHOD(double, get_height_falloff);
    METHOD(void, set_edge_fade);
    METHOD(double, get_edge_fade);
    METHOD(void, set_density_texture);
    METHOD(Object, get_density_texture);
};
struct PanoramaSkyMaterial : public Material {
    using Material::Material;
    PROPERTY(panorama, Object);
    PROPERTY(filter, bool);
    PROPERTY(energy_multiplier, double);
    METHOD(void, set_panorama);
    METHOD(Object, get_panorama);
    METHOD(void, set_filtering_enabled);
    METHOD(bool, is_filtering_enabled);
    METHOD(void, set_energy_multiplier);
    METHOD(double, get_energy_multiplier);
};
struct ParticleProcessMaterial : public Material {
    using Material::Material;
    PROPERTY(lifetime_randomness, double);
    PROPERTY(particle_flag_align_y, bool);
    PROPERTY(particle_flag_rotate_y, bool);
    PROPERTY(particle_flag_disable_z, bool);
    PROPERTY(particle_flag_damping_as_friction, bool);
    PROPERTY(emission_shape_offset, Vector3);
    PROPERTY(emission_shape_scale, Vector3);
    PROPERTY(emission_shape, int64_t);
    PROPERTY(emission_sphere_radius, double);
    PROPERTY(emission_box_extents, Vector3);
    PROPERTY(emission_point_texture, Object);
    PROPERTY(emission_normal_texture, Object);
    PROPERTY(emission_color_texture, Object);
    PROPERTY(emission_point_count, int64_t);
    PROPERTY(emission_ring_axis, Vector3);
    PROPERTY(emission_ring_height, double);
    PROPERTY(emission_ring_radius, double);
    PROPERTY(emission_ring_inner_radius, double);
    PROPERTY(angle, Vector2);
    PROPERTY(angle_min, double);
    PROPERTY(angle_max, double);
    PROPERTY(angle_curve, Object);
    PROPERTY(inherit_velocity_ratio, double);
    PROPERTY(velocity_pivot, Vector3);
    PROPERTY(direction, Vector3);
    PROPERTY(spread, double);
    PROPERTY(flatness, double);
    PROPERTY(initial_velocity, Vector2);
    PROPERTY(initial_velocity_min, double);
    PROPERTY(initial_velocity_max, double);
    PROPERTY(angular_velocity, Vector2);
    PROPERTY(angular_velocity_min, double);
    PROPERTY(angular_velocity_max, double);
    PROPERTY(angular_velocity_curve, Object);
    PROPERTY(directional_velocity, Vector2);
    PROPERTY(directional_velocity_min, double);
    PROPERTY(directional_velocity_max, double);
    PROPERTY(directional_velocity_curve, Object);
    PROPERTY(orbit_velocity, Vector2);
    PROPERTY(orbit_velocity_min, double);
    PROPERTY(orbit_velocity_max, double);
    PROPERTY(orbit_velocity_curve, Object);
    PROPERTY(radial_velocity, Vector2);
    PROPERTY(radial_velocity_min, double);
    PROPERTY(radial_velocity_max, double);
    PROPERTY(radial_velocity_curve, Object);
    PROPERTY(velocity_limit_curve, Object);
    PROPERTY(gravity, Vector3);
    PROPERTY(linear_accel, Vector2);
    PROPERTY(linear_accel_min, double);
    PROPERTY(linear_accel_max, double);
    PROPERTY(linear_accel_curve, Object);
    PROPERTY(radial_accel, Vector2);
    PROPERTY(radial_accel_min, double);
    PROPERTY(radial_accel_max, double);
    PROPERTY(radial_accel_curve, Object);
    PROPERTY(tangential_accel, Vector2);
    PROPERTY(tangential_accel_min, double);
    PROPERTY(tangential_accel_max, double);
    PROPERTY(tangential_accel_curve, Object);
    PROPERTY(damping, Vector2);
    PROPERTY(damping_min, double);
    PROPERTY(damping_max, double);
    PROPERTY(damping_curve, Object);
    PROPERTY(attractor_interaction_enabled, bool);
    PROPERTY(scale, Vector2);
    PROPERTY(scale_min, double);
    PROPERTY(scale_max, double);
    PROPERTY(scale_curve, Object);
    PROPERTY(scale_over_velocity, Vector2);
    PROPERTY(scale_over_velocity_min, double);
    PROPERTY(scale_over_velocity_max, double);
    PROPERTY(scale_over_velocity_curve, Object);
    PROPERTY(color, Color);
    PROPERTY(color_ramp, Object);
    PROPERTY(color_initial_ramp, Object);
    PROPERTY(alpha_curve, Object);
    PROPERTY(emission_curve, Object);
    PROPERTY(hue_variation, Vector2);
    PROPERTY(hue_variation_min, double);
    PROPERTY(hue_variation_max, double);
    PROPERTY(hue_variation_curve, Object);
    PROPERTY(anim_speed, Vector2);
    PROPERTY(anim_speed_min, double);
    PROPERTY(anim_speed_max, double);
    PROPERTY(anim_speed_curve, Object);
    PROPERTY(anim_offset, Vector2);
    PROPERTY(anim_offset_min, double);
    PROPERTY(anim_offset_max, double);
    PROPERTY(anim_offset_curve, Object);
    PROPERTY(turbulence_enabled, bool);
    PROPERTY(turbulence_noise_strength, double);
    PROPERTY(turbulence_noise_scale, double);
    PROPERTY(turbulence_noise_speed, Vector3);
    PROPERTY(turbulence_noise_speed_random, double);
    PROPERTY(turbulence_influence, Vector2);
    PROPERTY(turbulence_influence_min, double);
    PROPERTY(turbulence_influence_max, double);
    PROPERTY(turbulence_initial_displacement, Vector2);
    PROPERTY(turbulence_initial_displacement_min, double);
    PROPERTY(turbulence_initial_displacement_max, double);
    PROPERTY(turbulence_influence_over_life, Object);
    PROPERTY(collision_mode, int64_t);
    PROPERTY(collision_friction, double);
    PROPERTY(collision_bounce, double);
    PROPERTY(collision_use_scale, bool);
    PROPERTY(sub_emitter_mode, int64_t);
    PROPERTY(sub_emitter_frequency, double);
    PROPERTY(sub_emitter_amount_at_end, int64_t);
    PROPERTY(sub_emitter_amount_at_collision, int64_t);
    PROPERTY(sub_emitter_keep_velocity, bool);
    METHOD(void, set_direction);
    METHOD(Vector3, get_direction);
    METHOD(void, set_inherit_velocity_ratio);
    METHOD(double, get_inherit_velocity_ratio);
    METHOD(void, set_spread);
    METHOD(double, get_spread);
    METHOD(void, set_flatness);
    METHOD(double, get_flatness);
    METHOD(void, set_param);
    METHOD(Vector2, get_param);
    METHOD(void, set_param_min);
    METHOD(double, get_param_min);
    METHOD(void, set_param_max);
    METHOD(double, get_param_max);
    METHOD(void, set_param_texture);
    METHOD(Object, get_param_texture);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_color_ramp);
    METHOD(Object, get_color_ramp);
    METHOD(void, set_alpha_curve);
    METHOD(Object, get_alpha_curve);
    METHOD(void, set_emission_curve);
    METHOD(Object, get_emission_curve);
    METHOD(void, set_color_initial_ramp);
    METHOD(Object, get_color_initial_ramp);
    METHOD(void, set_velocity_limit_curve);
    METHOD(Object, get_velocity_limit_curve);
    METHOD(void, set_particle_flag);
    METHOD(bool, get_particle_flag);
    METHOD(void, set_velocity_pivot);
    METHOD(Vector3, get_velocity_pivot);
    METHOD(void, set_emission_shape);
    METHOD(int64_t, get_emission_shape);
    METHOD(void, set_emission_sphere_radius);
    METHOD(double, get_emission_sphere_radius);
    METHOD(void, set_emission_box_extents);
    METHOD(Vector3, get_emission_box_extents);
    METHOD(void, set_emission_point_texture);
    METHOD(Object, get_emission_point_texture);
    METHOD(void, set_emission_normal_texture);
    METHOD(Object, get_emission_normal_texture);
    METHOD(void, set_emission_color_texture);
    METHOD(Object, get_emission_color_texture);
    METHOD(void, set_emission_point_count);
    METHOD(int64_t, get_emission_point_count);
    METHOD(void, set_emission_ring_axis);
    METHOD(Vector3, get_emission_ring_axis);
    METHOD(void, set_emission_ring_height);
    METHOD(double, get_emission_ring_height);
    METHOD(void, set_emission_ring_radius);
    METHOD(double, get_emission_ring_radius);
    METHOD(void, set_emission_ring_inner_radius);
    METHOD(double, get_emission_ring_inner_radius);
    METHOD(void, set_emission_shape_offset);
    METHOD(Vector3, get_emission_shape_offset);
    METHOD(void, set_emission_shape_scale);
    METHOD(Vector3, get_emission_shape_scale);
    METHOD(bool, get_turbulence_enabled);
    METHOD(void, set_turbulence_enabled);
    METHOD(double, get_turbulence_noise_strength);
    METHOD(void, set_turbulence_noise_strength);
    METHOD(double, get_turbulence_noise_scale);
    METHOD(void, set_turbulence_noise_scale);
    METHOD(double, get_turbulence_noise_speed_random);
    METHOD(void, set_turbulence_noise_speed_random);
    METHOD(Vector3, get_turbulence_noise_speed);
    METHOD(void, set_turbulence_noise_speed);
    METHOD(Vector3, get_gravity);
    METHOD(void, set_gravity);
    METHOD(void, set_lifetime_randomness);
    METHOD(double, get_lifetime_randomness);
    METHOD(int64_t, get_sub_emitter_mode);
    METHOD(void, set_sub_emitter_mode);
    METHOD(double, get_sub_emitter_frequency);
    METHOD(void, set_sub_emitter_frequency);
    METHOD(int64_t, get_sub_emitter_amount_at_end);
    METHOD(void, set_sub_emitter_amount_at_end);
    METHOD(int64_t, get_sub_emitter_amount_at_collision);
    METHOD(void, set_sub_emitter_amount_at_collision);
    METHOD(bool, get_sub_emitter_keep_velocity);
    METHOD(void, set_sub_emitter_keep_velocity);
    METHOD(void, set_attractor_interaction_enabled);
    METHOD(bool, is_attractor_interaction_enabled);
    METHOD(void, set_collision_mode);
    METHOD(int64_t, get_collision_mode);
    METHOD(void, set_collision_use_scale);
    METHOD(bool, is_collision_using_scale);
    METHOD(void, set_collision_friction);
    METHOD(double, get_collision_friction);
    METHOD(void, set_collision_bounce);
    METHOD(double, get_collision_bounce);
    static constexpr int64_t PARAM_INITIAL_LINEAR_VELOCITY = 0;
    static constexpr int64_t PARAM_ANGULAR_VELOCITY = 1;
    static constexpr int64_t PARAM_ORBIT_VELOCITY = 2;
    static constexpr int64_t PARAM_LINEAR_ACCEL = 3;
    static constexpr int64_t PARAM_RADIAL_ACCEL = 4;
    static constexpr int64_t PARAM_TANGENTIAL_ACCEL = 5;
    static constexpr int64_t PARAM_DAMPING = 6;
    static constexpr int64_t PARAM_ANGLE = 7;
    static constexpr int64_t PARAM_SCALE = 8;
    static constexpr int64_t PARAM_HUE_VARIATION = 9;
    static constexpr int64_t PARAM_ANIM_SPEED = 10;
    static constexpr int64_t PARAM_ANIM_OFFSET = 11;
    static constexpr int64_t PARAM_RADIAL_VELOCITY = 15;
    static constexpr int64_t PARAM_DIRECTIONAL_VELOCITY = 16;
    static constexpr int64_t PARAM_SCALE_OVER_VELOCITY = 17;
    static constexpr int64_t PARAM_MAX = 18;
    static constexpr int64_t PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY = 0;
    static constexpr int64_t PARTICLE_FLAG_ROTATE_Y = 1;
    static constexpr int64_t PARTICLE_FLAG_DISABLE_Z = 2;
    static constexpr int64_t PARTICLE_FLAG_DAMPING_AS_FRICTION = 3;
    static constexpr int64_t PARTICLE_FLAG_MAX = 4;
    static constexpr int64_t EMISSION_SHAPE_POINT = 0;
    static constexpr int64_t EMISSION_SHAPE_SPHERE = 1;
    static constexpr int64_t EMISSION_SHAPE_SPHERE_SURFACE = 2;
    static constexpr int64_t EMISSION_SHAPE_BOX = 3;
    static constexpr int64_t EMISSION_SHAPE_POINTS = 4;
    static constexpr int64_t EMISSION_SHAPE_DIRECTED_POINTS = 5;
    static constexpr int64_t EMISSION_SHAPE_RING = 6;
    static constexpr int64_t EMISSION_SHAPE_MAX = 7;
    static constexpr int64_t PARAM_TURB_VEL_INFLUENCE = 13;
    static constexpr int64_t PARAM_TURB_INIT_DISPLACEMENT = 14;
    static constexpr int64_t PARAM_TURB_INFLUENCE_OVER_LIFE = 12;
    static constexpr int64_t SUB_EMITTER_DISABLED = 0;
    static constexpr int64_t SUB_EMITTER_CONSTANT = 1;
    static constexpr int64_t SUB_EMITTER_AT_END = 2;
    static constexpr int64_t SUB_EMITTER_AT_COLLISION = 3;
    static constexpr int64_t SUB_EMITTER_MAX = 4;
    static constexpr int64_t COLLISION_DISABLED = 0;
    static constexpr int64_t COLLISION_RIGID = 1;
    static constexpr int64_t COLLISION_HIDE_ON_CONTACT = 2;
    static constexpr int64_t COLLISION_MAX = 3;
};
struct PhysicalSkyMaterial : public Material {
    using Material::Material;
    PROPERTY(rayleigh_coefficient, double);
    PROPERTY(rayleigh_color, Color);
    PROPERTY(mie_coefficient, double);
    PROPERTY(mie_eccentricity, double);
    PROPERTY(mie_color, Color);
    PROPERTY(turbidity, double);
    PROPERTY(sun_disk_scale, double);
    PROPERTY(ground_color, Color);
    PROPERTY(energy_multiplier, double);
    PROPERTY(use_debanding, bool);
    PROPERTY(night_sky, Object);
    METHOD(void, set_rayleigh_coefficient);
    METHOD(double, get_rayleigh_coefficient);
    METHOD(void, set_rayleigh_color);
    METHOD(Color, get_rayleigh_color);
    METHOD(void, set_mie_coefficient);
    METHOD(double, get_mie_coefficient);
    METHOD(void, set_mie_eccentricity);
    METHOD(double, get_mie_eccentricity);
    METHOD(void, set_mie_color);
    METHOD(Color, get_mie_color);
    METHOD(void, set_turbidity);
    METHOD(double, get_turbidity);
    METHOD(void, set_sun_disk_scale);
    METHOD(double, get_sun_disk_scale);
    METHOD(void, set_ground_color);
    METHOD(Color, get_ground_color);
    METHOD(void, set_energy_multiplier);
    METHOD(double, get_energy_multiplier);
    METHOD(void, set_use_debanding);
    METHOD(bool, get_use_debanding);
    METHOD(void, set_night_sky);
    METHOD(Object, get_night_sky);
};
struct PlaceholderMaterial : public Material {
    using Material::Material;
};
struct ProceduralSkyMaterial : public Material {
    using Material::Material;
    PROPERTY(sky_top_color, Color);
    PROPERTY(sky_horizon_color, Color);
    PROPERTY(sky_curve, double);
    PROPERTY(sky_energy_multiplier, double);
    PROPERTY(sky_cover, Object);
    PROPERTY(sky_cover_modulate, Color);
    PROPERTY(ground_bottom_color, Color);
    PROPERTY(ground_horizon_color, Color);
    PROPERTY(ground_curve, double);
    PROPERTY(ground_energy_multiplier, double);
    PROPERTY(sun_angle_max, double);
    PROPERTY(sun_curve, double);
    PROPERTY(use_debanding, bool);
    PROPERTY(energy_multiplier, double);
    METHOD(void, set_sky_top_color);
    METHOD(Color, get_sky_top_color);
    METHOD(void, set_sky_horizon_color);
    METHOD(Color, get_sky_horizon_color);
    METHOD(void, set_sky_curve);
    METHOD(double, get_sky_curve);
    METHOD(void, set_sky_energy_multiplier);
    METHOD(double, get_sky_energy_multiplier);
    METHOD(void, set_sky_cover);
    METHOD(Object, get_sky_cover);
    METHOD(void, set_sky_cover_modulate);
    METHOD(Color, get_sky_cover_modulate);
    METHOD(void, set_ground_bottom_color);
    METHOD(Color, get_ground_bottom_color);
    METHOD(void, set_ground_horizon_color);
    METHOD(Color, get_ground_horizon_color);
    METHOD(void, set_ground_curve);
    METHOD(double, get_ground_curve);
    METHOD(void, set_ground_energy_multiplier);
    METHOD(double, get_ground_energy_multiplier);
    METHOD(void, set_sun_angle_max);
    METHOD(double, get_sun_angle_max);
    METHOD(void, set_sun_curve);
    METHOD(double, get_sun_curve);
    METHOD(void, set_use_debanding);
    METHOD(bool, get_use_debanding);
    METHOD(void, set_energy_multiplier);
    METHOD(double, get_energy_multiplier);
};
struct ShaderMaterial : public Material {
    using Material::Material;
    PROPERTY(shader, Object);
    METHOD(void, set_shader);
    METHOD(Object, get_shader);
    METHOD(void, set_shader_parameter);
    METHOD(Variant, get_shader_parameter);
};
struct BoxMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(size, Vector3);
    PROPERTY(subdivide_width, int64_t);
    PROPERTY(subdivide_height, int64_t);
    PROPERTY(subdivide_depth, int64_t);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_subdivide_width);
    METHOD(int64_t, get_subdivide_width);
    METHOD(void, set_subdivide_height);
    METHOD(int64_t, get_subdivide_height);
    METHOD(void, set_subdivide_depth);
    METHOD(int64_t, get_subdivide_depth);
};
struct CapsuleMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(radius, double);
    PROPERTY(height, double);
    PROPERTY(radial_segments, int64_t);
    PROPERTY(rings, int64_t);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
    METHOD(void, set_radial_segments);
    METHOD(int64_t, get_radial_segments);
    METHOD(void, set_rings);
    METHOD(int64_t, get_rings);
};
struct CylinderMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(top_radius, double);
    PROPERTY(bottom_radius, double);
    PROPERTY(height, double);
    PROPERTY(radial_segments, int64_t);
    PROPERTY(rings, int64_t);
    PROPERTY(cap_top, bool);
    PROPERTY(cap_bottom, bool);
    METHOD(void, set_top_radius);
    METHOD(double, get_top_radius);
    METHOD(void, set_bottom_radius);
    METHOD(double, get_bottom_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
    METHOD(void, set_radial_segments);
    METHOD(int64_t, get_radial_segments);
    METHOD(void, set_rings);
    METHOD(int64_t, get_rings);
    METHOD(void, set_cap_top);
    METHOD(bool, is_cap_top);
    METHOD(void, set_cap_bottom);
    METHOD(bool, is_cap_bottom);
};
struct PlaneMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(size, Vector2);
    PROPERTY(subdivide_width, int64_t);
    PROPERTY(subdivide_depth, int64_t);
    PROPERTY(center_offset, Vector3);
    PROPERTY(orientation, int64_t);
    METHOD(void, set_size);
    METHOD(Vector2, get_size);
    METHOD(void, set_subdivide_width);
    METHOD(int64_t, get_subdivide_width);
    METHOD(void, set_subdivide_depth);
    METHOD(int64_t, get_subdivide_depth);
    METHOD(void, set_center_offset);
    METHOD(Vector3, get_center_offset);
    METHOD(void, set_orientation);
    METHOD(int64_t, get_orientation);
    static constexpr int64_t FACE_X = 0;
    static constexpr int64_t FACE_Y = 1;
    static constexpr int64_t FACE_Z = 2;
};
struct PointMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
};
struct PrismMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(left_to_right, double);
    PROPERTY(size, Vector3);
    PROPERTY(subdivide_width, int64_t);
    PROPERTY(subdivide_height, int64_t);
    PROPERTY(subdivide_depth, int64_t);
    METHOD(void, set_left_to_right);
    METHOD(double, get_left_to_right);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_subdivide_width);
    METHOD(int64_t, get_subdivide_width);
    METHOD(void, set_subdivide_height);
    METHOD(int64_t, get_subdivide_height);
    METHOD(void, set_subdivide_depth);
    METHOD(int64_t, get_subdivide_depth);
};
struct RibbonTrailMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(shape, int64_t);
    PROPERTY(size, double);
    PROPERTY(sections, int64_t);
    PROPERTY(section_length, double);
    PROPERTY(section_segments, int64_t);
    PROPERTY(curve, Object);
    METHOD(void, set_size);
    METHOD(double, get_size);
    METHOD(void, set_sections);
    METHOD(int64_t, get_sections);
    METHOD(void, set_section_length);
    METHOD(double, get_section_length);
    METHOD(void, set_section_segments);
    METHOD(int64_t, get_section_segments);
    METHOD(void, set_curve);
    METHOD(Object, get_curve);
    METHOD(void, set_shape);
    METHOD(int64_t, get_shape);
    static constexpr int64_t SHAPE_FLAT = 0;
    static constexpr int64_t SHAPE_CROSS = 1;
};
struct SphereMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(radius, double);
    PROPERTY(height, double);
    PROPERTY(radial_segments, int64_t);
    PROPERTY(rings, int64_t);
    PROPERTY(is_hemisphere, bool);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
    METHOD(void, set_radial_segments);
    METHOD(int64_t, get_radial_segments);
    METHOD(void, set_rings);
    METHOD(int64_t, get_rings);
    METHOD(void, set_is_hemisphere);
    METHOD(bool, get_is_hemisphere);
};
struct TextMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(text, String);
    PROPERTY(font, Object);
    PROPERTY(font_size, int64_t);
    PROPERTY(horizontal_alignment, int64_t);
    PROPERTY(vertical_alignment, int64_t);
    PROPERTY(uppercase, bool);
    PROPERTY(line_spacing, double);
    PROPERTY(autowrap_mode, int64_t);
    PROPERTY(justification_flags, int64_t);
    PROPERTY(pixel_size, double);
    PROPERTY(curve_step, double);
    PROPERTY(depth, double);
    PROPERTY(width, double);
    PROPERTY(offset, Vector2);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    PROPERTY(structured_text_bidi_override, int64_t);
    PROPERTY(structured_text_bidi_override_options, Array);
    METHOD(void, set_horizontal_alignment);
    METHOD(int64_t, get_horizontal_alignment);
    METHOD(void, set_vertical_alignment);
    METHOD(int64_t, get_vertical_alignment);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(void, set_font);
    METHOD(Object, get_font);
    METHOD(void, set_font_size);
    METHOD(int64_t, get_font_size);
    METHOD(void, set_line_spacing);
    METHOD(double, get_line_spacing);
    METHOD(void, set_autowrap_mode);
    METHOD(int64_t, get_autowrap_mode);
    METHOD(void, set_justification_flags);
    METHOD(int64_t, get_justification_flags);
    METHOD(void, set_depth);
    METHOD(double, get_depth);
    METHOD(void, set_width);
    METHOD(double, get_width);
    METHOD(void, set_pixel_size);
    METHOD(double, get_pixel_size);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_curve_step);
    METHOD(double, get_curve_step);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    METHOD(void, set_uppercase);
    METHOD(bool, is_uppercase);
};
struct TorusMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(inner_radius, double);
    PROPERTY(outer_radius, double);
    PROPERTY(rings, int64_t);
    PROPERTY(ring_segments, int64_t);
    METHOD(void, set_inner_radius);
    METHOD(double, get_inner_radius);
    METHOD(void, set_outer_radius);
    METHOD(double, get_outer_radius);
    METHOD(void, set_rings);
    METHOD(int64_t, get_rings);
    METHOD(void, set_ring_segments);
    METHOD(int64_t, get_ring_segments);
};
struct TubeTrailMesh : public PrimitiveMesh {
    using PrimitiveMesh::PrimitiveMesh;
    PROPERTY(radius, double);
    PROPERTY(radial_steps, int64_t);
    PROPERTY(sections, int64_t);
    PROPERTY(section_length, double);
    PROPERTY(section_rings, int64_t);
    PROPERTY(cap_top, bool);
    PROPERTY(cap_bottom, bool);
    PROPERTY(curve, Object);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_radial_steps);
    METHOD(int64_t, get_radial_steps);
    METHOD(void, set_sections);
    METHOD(int64_t, get_sections);
    METHOD(void, set_section_length);
    METHOD(double, get_section_length);
    METHOD(void, set_section_rings);
    METHOD(int64_t, get_section_rings);
    METHOD(void, set_cap_top);
    METHOD(bool, is_cap_top);
    METHOD(void, set_cap_bottom);
    METHOD(bool, is_cap_bottom);
    METHOD(void, set_curve);
    METHOD(Object, get_curve);
};
struct BoxShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(size, Vector3);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
};
struct CapsuleShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(radius, double);
    PROPERTY(height, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
};
struct ConcavePolygonShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(data, PackedArray<Vector3>);
    PROPERTY(backface_collision, bool);
    METHOD(void, set_faces);
    METHOD(PackedArray<Vector3>, get_faces);
    METHOD(void, set_backface_collision_enabled);
    METHOD(bool, is_backface_collision_enabled);
};
struct ConvexPolygonShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(points, Array);
    METHOD(void, set_points);
    METHOD(PackedArray<Vector3>, get_points);
};
struct CylinderShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(height, double);
    PROPERTY(radius, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
};
struct HeightMapShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(map_width, int64_t);
    PROPERTY(map_depth, int64_t);
    PROPERTY(map_data, PackedArray<float>);
    METHOD(void, set_map_width);
    METHOD(int64_t, get_map_width);
    METHOD(void, set_map_depth);
    METHOD(int64_t, get_map_depth);
    METHOD(void, set_map_data);
    METHOD(PackedArray<float>, get_map_data);
    METHOD(double, get_min_height);
    METHOD(double, get_max_height);
    METHOD(Variant, update_map_data_from_image);
};
struct SeparationRayShape3D : public Shape3D {
    using Shape3D::Shape3D;
    PROPERTY(length, double);
    PROPERTY(slide_on_slope, bool);
    METHOD(void, set_length);
    METHOD(double, get_length);
    METHOD(void, set_slide_on_slope);
    METHOD(bool, get_slide_on_slope);
};
struct Button : public BaseButton {
    using BaseButton::BaseButton;
    PROPERTY(text, String);
    PROPERTY(icon, Object);
    PROPERTY(flat, bool);
    PROPERTY(alignment, int64_t);
    PROPERTY(text_overrun_behavior, int64_t);
    PROPERTY(autowrap_mode, int64_t);
    PROPERTY(clip_text, bool);
    PROPERTY(icon_alignment, int64_t);
    PROPERTY(vertical_icon_alignment, int64_t);
    PROPERTY(expand_icon, bool);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(void, set_text_overrun_behavior);
    METHOD(int64_t, get_text_overrun_behavior);
    METHOD(void, set_autowrap_mode);
    METHOD(int64_t, get_autowrap_mode);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_button_icon);
    METHOD(Object, get_button_icon);
    METHOD(void, set_flat);
    METHOD(bool, is_flat);
    METHOD(void, set_clip_text);
    METHOD(bool, get_clip_text);
    METHOD(void, set_text_alignment);
    METHOD(int64_t, get_text_alignment);
    METHOD(void, set_icon_alignment);
    METHOD(int64_t, get_icon_alignment);
    METHOD(void, set_vertical_icon_alignment);
    METHOD(int64_t, get_vertical_icon_alignment);
    METHOD(void, set_expand_icon);
    METHOD(bool, is_expand_icon);
};
struct LinkButton : public BaseButton {
    using BaseButton::BaseButton;
    PROPERTY(text, String);
    PROPERTY(underline, int64_t);
    PROPERTY(uri, String);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    PROPERTY(structured_text_bidi_override, int64_t);
    PROPERTY(structured_text_bidi_override_options, Array);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_uri);
    METHOD(String, get_uri);
    METHOD(void, set_underline_mode);
    METHOD(int64_t, get_underline_mode);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    static constexpr int64_t UNDERLINE_MODE_ALWAYS = 0;
    static constexpr int64_t UNDERLINE_MODE_ON_HOVER = 1;
    static constexpr int64_t UNDERLINE_MODE_NEVER = 2;
};
struct TextureButton : public BaseButton {
    using BaseButton::BaseButton;
    PROPERTY(texture_normal, Object);
    PROPERTY(texture_pressed, Object);
    PROPERTY(texture_hover, Object);
    PROPERTY(texture_disabled, Object);
    PROPERTY(texture_focused, Object);
    PROPERTY(texture_click_mask, Object);
    PROPERTY(ignore_texture_size, bool);
    PROPERTY(stretch_mode, int64_t);
    PROPERTY(flip_h, bool);
    PROPERTY(flip_v, bool);
    METHOD(void, set_texture_normal);
    METHOD(void, set_texture_pressed);
    METHOD(void, set_texture_hover);
    METHOD(void, set_texture_disabled);
    METHOD(void, set_texture_focused);
    METHOD(void, set_click_mask);
    METHOD(void, set_ignore_texture_size);
    METHOD(void, set_stretch_mode);
    METHOD(void, set_flip_h);
    METHOD(bool, is_flipped_h);
    METHOD(void, set_flip_v);
    METHOD(bool, is_flipped_v);
    METHOD(Object, get_texture_normal);
    METHOD(Object, get_texture_pressed);
    METHOD(Object, get_texture_hover);
    METHOD(Object, get_texture_disabled);
    METHOD(Object, get_texture_focused);
    METHOD(Object, get_click_mask);
    METHOD(bool, get_ignore_texture_size);
    METHOD(int64_t, get_stretch_mode);
    static constexpr int64_t STRETCH_SCALE = 0;
    static constexpr int64_t STRETCH_TILE = 1;
    static constexpr int64_t STRETCH_KEEP = 2;
    static constexpr int64_t STRETCH_KEEP_CENTERED = 3;
    static constexpr int64_t STRETCH_KEEP_ASPECT = 4;
    static constexpr int64_t STRETCH_KEEP_ASPECT_CENTERED = 5;
    static constexpr int64_t STRETCH_KEEP_ASPECT_COVERED = 6;
};
struct CPPScript : public ScriptExtension {
    using ScriptExtension::ScriptExtension;
};
struct ELFScript : public ScriptExtension {
    using ScriptExtension::ScriptExtension;
    METHOD(Object, get_sandbox_for);
    METHOD(Array, get_sandboxes);
    METHOD(PackedArray<uint8_t>, get_content);
};
struct RustScript : public ScriptExtension {
    using ScriptExtension::ScriptExtension;
};
struct CPPScriptLanguage : public ScriptLanguageExtension {
    using ScriptLanguageExtension::ScriptLanguageExtension;
};
struct ELFScriptLanguage : public ScriptLanguageExtension {
    using ScriptLanguageExtension::ScriptLanguageExtension;
};
struct RustScriptLanguage : public ScriptLanguageExtension {
    using ScriptLanguageExtension::ScriptLanguageExtension;
};
struct CallbackTweener : public Tweener {
    using Tweener::Tweener;
    METHOD(Object, set_delay);
};
struct IntervalTweener : public Tweener {
    using Tweener::Tweener;
};
struct MethodTweener : public Tweener {
    using Tweener::Tweener;
    METHOD(Object, set_delay);
    METHOD(Object, set_trans);
    METHOD(Object, set_ease);
};
struct PropertyTweener : public Tweener {
    using Tweener::Tweener;
    METHOD(Object, from);
    METHOD(Object, from_current);
    METHOD(Object, as_relative);
    METHOD(Object, set_trans);
    METHOD(Object, set_ease);
    METHOD(Object, set_custom_interpolator);
    METHOD(Object, set_delay);
};
struct CameraAttributesPhysical : public CameraAttributes {
    using CameraAttributes::CameraAttributes;
    PROPERTY(frustum_focus_distance, double);
    PROPERTY(frustum_focal_length, double);
    PROPERTY(frustum_near, double);
    PROPERTY(frustum_far, double);
    PROPERTY(exposure_aperture, double);
    PROPERTY(exposure_shutter_speed, double);
    PROPERTY(auto_exposure_min_exposure_value, double);
    PROPERTY(auto_exposure_max_exposure_value, double);
    METHOD(void, set_aperture);
    METHOD(double, get_aperture);
    METHOD(void, set_shutter_speed);
    METHOD(double, get_shutter_speed);
    METHOD(void, set_focal_length);
    METHOD(double, get_focal_length);
    METHOD(void, set_focus_distance);
    METHOD(double, get_focus_distance);
    METHOD(void, set_near);
    METHOD(double, get_near);
    METHOD(void, set_far);
    METHOD(double, get_far);
    METHOD(double, get_fov);
    METHOD(void, set_auto_exposure_max_exposure_value);
    METHOD(double, get_auto_exposure_max_exposure_value);
    METHOD(void, set_auto_exposure_min_exposure_value);
    METHOD(double, get_auto_exposure_min_exposure_value);
};
struct CameraAttributesPractical : public CameraAttributes {
    using CameraAttributes::CameraAttributes;
    PROPERTY(dof_blur_far_enabled, bool);
    PROPERTY(dof_blur_far_distance, double);
    PROPERTY(dof_blur_far_transition, double);
    PROPERTY(dof_blur_near_enabled, bool);
    PROPERTY(dof_blur_near_distance, double);
    PROPERTY(dof_blur_near_transition, double);
    PROPERTY(dof_blur_amount, double);
    PROPERTY(auto_exposure_min_sensitivity, double);
    PROPERTY(auto_exposure_max_sensitivity, double);
    METHOD(void, set_dof_blur_far_enabled);
    METHOD(bool, is_dof_blur_far_enabled);
    METHOD(void, set_dof_blur_far_distance);
    METHOD(double, get_dof_blur_far_distance);
    METHOD(void, set_dof_blur_far_transition);
    METHOD(double, get_dof_blur_far_transition);
    METHOD(void, set_dof_blur_near_enabled);
    METHOD(bool, is_dof_blur_near_enabled);
    METHOD(void, set_dof_blur_near_distance);
    METHOD(double, get_dof_blur_near_distance);
    METHOD(void, set_dof_blur_near_transition);
    METHOD(double, get_dof_blur_near_transition);
    METHOD(void, set_dof_blur_amount);
    METHOD(double, get_dof_blur_amount);
    METHOD(void, set_auto_exposure_max_sensitivity);
    METHOD(double, get_auto_exposure_max_sensitivity);
    METHOD(void, set_auto_exposure_min_sensitivity);
    METHOD(double, get_auto_exposure_min_sensitivity);
};
struct CapsuleShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(radius, double);
    PROPERTY(height, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
};
struct CircleShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(radius, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
};
struct ConcavePolygonShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(segments, PackedArray<Vector2>);
    METHOD(void, set_segments);
    METHOD(PackedArray<Vector2>, get_segments);
};
struct ConvexPolygonShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(points, PackedArray<Vector2>);
    METHOD(void, set_point_cloud);
    METHOD(void, set_points);
    METHOD(PackedArray<Vector2>, get_points);
};
struct RectangleShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(size, Vector2);
    METHOD(void, set_size);
    METHOD(Vector2, get_size);
};
struct SegmentShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(a, Vector2);
    PROPERTY(b, Vector2);
    METHOD(void, set_a);
    METHOD(Vector2, get_a);
    METHOD(void, set_b);
    METHOD(Vector2, get_b);
};
struct SeparationRayShape2D : public Shape2D {
    using Shape2D::Shape2D;
    PROPERTY(length, double);
    PROPERTY(slide_on_slope, bool);
    METHOD(void, set_length);
    METHOD(double, get_length);
    METHOD(void, set_slide_on_slope);
    METHOD(bool, get_slide_on_slope);
};
struct CharacterBody2D : public PhysicsBody2D {
    using PhysicsBody2D::PhysicsBody2D;
    PROPERTY(motion_mode, int64_t);
    PROPERTY(up_direction, Vector2);
    PROPERTY(velocity, Vector2);
    PROPERTY(slide_on_ceiling, bool);
    PROPERTY(max_slides, int64_t);
    PROPERTY(wall_min_slide_angle, double);
    PROPERTY(floor_stop_on_slope, bool);
    PROPERTY(floor_constant_speed, bool);
    PROPERTY(floor_block_on_wall, bool);
    PROPERTY(floor_max_angle, double);
    PROPERTY(floor_snap_length, double);
    PROPERTY(platform_on_leave, int64_t);
    PROPERTY(platform_floor_layers, int64_t);
    PROPERTY(platform_wall_layers, int64_t);
    PROPERTY(safe_margin, double);
    METHOD(bool, move_and_slide);
    METHOD(Variant, apply_floor_snap);
    METHOD(void, set_velocity);
    METHOD(Vector2, get_velocity);
    METHOD(void, set_safe_margin);
    METHOD(double, get_safe_margin);
    METHOD(bool, is_floor_stop_on_slope_enabled);
    METHOD(void, set_floor_stop_on_slope_enabled);
    METHOD(void, set_floor_constant_speed_enabled);
    METHOD(bool, is_floor_constant_speed_enabled);
    METHOD(void, set_floor_block_on_wall_enabled);
    METHOD(bool, is_floor_block_on_wall_enabled);
    METHOD(void, set_slide_on_ceiling_enabled);
    METHOD(bool, is_slide_on_ceiling_enabled);
    METHOD(void, set_platform_floor_layers);
    METHOD(int64_t, get_platform_floor_layers);
    METHOD(void, set_platform_wall_layers);
    METHOD(int64_t, get_platform_wall_layers);
    METHOD(int64_t, get_max_slides);
    METHOD(void, set_max_slides);
    METHOD(double, get_floor_max_angle);
    METHOD(void, set_floor_max_angle);
    METHOD(double, get_floor_snap_length);
    METHOD(void, set_floor_snap_length);
    METHOD(double, get_wall_min_slide_angle);
    METHOD(void, set_wall_min_slide_angle);
    METHOD(Vector2, get_up_direction);
    METHOD(void, set_up_direction);
    METHOD(void, set_motion_mode);
    METHOD(int64_t, get_motion_mode);
    METHOD(void, set_platform_on_leave);
    METHOD(int64_t, get_platform_on_leave);
    METHOD(bool, is_on_floor);
    METHOD(bool, is_on_floor_only);
    METHOD(bool, is_on_ceiling);
    METHOD(bool, is_on_ceiling_only);
    METHOD(bool, is_on_wall);
    METHOD(bool, is_on_wall_only);
    METHOD(Vector2, get_floor_normal);
    METHOD(Vector2, get_wall_normal);
    METHOD(Vector2, get_last_motion);
    METHOD(Vector2, get_position_delta);
    METHOD(Vector2, get_real_velocity);
    METHOD(double, get_floor_angle);
    METHOD(Vector2, get_platform_velocity);
    METHOD(int64_t, get_slide_collision_count);
    METHOD(Object, get_slide_collision);
    METHOD(Object, get_last_slide_collision);
    static constexpr int64_t MOTION_MODE_GROUNDED = 0;
    static constexpr int64_t MOTION_MODE_FLOATING = 1;
    static constexpr int64_t PLATFORM_ON_LEAVE_ADD_VELOCITY = 0;
    static constexpr int64_t PLATFORM_ON_LEAVE_ADD_UPWARD_VELOCITY = 1;
    static constexpr int64_t PLATFORM_ON_LEAVE_DO_NOTHING = 2;
};
struct CharacterBody3D : public PhysicsBody3D {
    using PhysicsBody3D::PhysicsBody3D;
    PROPERTY(motion_mode, int64_t);
    PROPERTY(up_direction, Vector3);
    PROPERTY(slide_on_ceiling, bool);
    PROPERTY(velocity, Vector3);
    PROPERTY(max_slides, int64_t);
    PROPERTY(wall_min_slide_angle, double);
    PROPERTY(floor_stop_on_slope, bool);
    PROPERTY(floor_constant_speed, bool);
    PROPERTY(floor_block_on_wall, bool);
    PROPERTY(floor_max_angle, double);
    PROPERTY(floor_snap_length, double);
    PROPERTY(platform_on_leave, int64_t);
    PROPERTY(platform_floor_layers, int64_t);
    PROPERTY(platform_wall_layers, int64_t);
    PROPERTY(safe_margin, double);
    METHOD(bool, move_and_slide);
    METHOD(Variant, apply_floor_snap);
    METHOD(void, set_velocity);
    METHOD(Vector3, get_velocity);
    METHOD(void, set_safe_margin);
    METHOD(double, get_safe_margin);
    METHOD(bool, is_floor_stop_on_slope_enabled);
    METHOD(void, set_floor_stop_on_slope_enabled);
    METHOD(void, set_floor_constant_speed_enabled);
    METHOD(bool, is_floor_constant_speed_enabled);
    METHOD(void, set_floor_block_on_wall_enabled);
    METHOD(bool, is_floor_block_on_wall_enabled);
    METHOD(void, set_slide_on_ceiling_enabled);
    METHOD(bool, is_slide_on_ceiling_enabled);
    METHOD(void, set_platform_floor_layers);
    METHOD(int64_t, get_platform_floor_layers);
    METHOD(void, set_platform_wall_layers);
    METHOD(int64_t, get_platform_wall_layers);
    METHOD(int64_t, get_max_slides);
    METHOD(void, set_max_slides);
    METHOD(double, get_floor_max_angle);
    METHOD(void, set_floor_max_angle);
    METHOD(double, get_floor_snap_length);
    METHOD(void, set_floor_snap_length);
    METHOD(double, get_wall_min_slide_angle);
    METHOD(void, set_wall_min_slide_angle);
    METHOD(Vector3, get_up_direction);
    METHOD(void, set_up_direction);
    METHOD(void, set_motion_mode);
    METHOD(int64_t, get_motion_mode);
    METHOD(void, set_platform_on_leave);
    METHOD(int64_t, get_platform_on_leave);
    METHOD(bool, is_on_floor);
    METHOD(bool, is_on_floor_only);
    METHOD(bool, is_on_ceiling);
    METHOD(bool, is_on_ceiling_only);
    METHOD(bool, is_on_wall);
    METHOD(bool, is_on_wall_only);
    METHOD(Vector3, get_floor_normal);
    METHOD(Vector3, get_wall_normal);
    METHOD(Vector3, get_last_motion);
    METHOD(Vector3, get_position_delta);
    METHOD(Vector3, get_real_velocity);
    METHOD(double, get_floor_angle);
    METHOD(Vector3, get_platform_velocity);
    METHOD(Vector3, get_platform_angular_velocity);
    METHOD(int64_t, get_slide_collision_count);
    METHOD(Object, get_slide_collision);
    METHOD(Object, get_last_slide_collision);
    static constexpr int64_t MOTION_MODE_GROUNDED = 0;
    static constexpr int64_t MOTION_MODE_FLOATING = 1;
    static constexpr int64_t PLATFORM_ON_LEAVE_ADD_VELOCITY = 0;
    static constexpr int64_t PLATFORM_ON_LEAVE_ADD_UPWARD_VELOCITY = 1;
    static constexpr int64_t PLATFORM_ON_LEAVE_DO_NOTHING = 2;
};
struct PhysicalBone3D : public PhysicsBody3D {
    using PhysicsBody3D::PhysicsBody3D;
    PROPERTY(joint_type, int64_t);
    PROPERTY(joint_offset, Transform3D);
    PROPERTY(joint_rotation, Vector3);
    PROPERTY(body_offset, Transform3D);
    PROPERTY(mass, double);
    PROPERTY(friction, double);
    PROPERTY(bounce, double);
    PROPERTY(gravity_scale, double);
    PROPERTY(custom_integrator, bool);
    PROPERTY(linear_damp_mode, int64_t);
    PROPERTY(linear_damp, double);
    PROPERTY(angular_damp_mode, int64_t);
    PROPERTY(angular_damp, double);
    PROPERTY(linear_velocity, Vector3);
    PROPERTY(angular_velocity, Vector3);
    PROPERTY(can_sleep, bool);
    METHOD(Variant, _integrate_forces);
    METHOD(Variant, apply_central_impulse);
    METHOD(Variant, apply_impulse);
    METHOD(void, set_joint_type);
    METHOD(int64_t, get_joint_type);
    METHOD(void, set_joint_offset);
    METHOD(Transform3D, get_joint_offset);
    METHOD(void, set_joint_rotation);
    METHOD(Vector3, get_joint_rotation);
    METHOD(void, set_body_offset);
    METHOD(Transform3D, get_body_offset);
    METHOD(bool, get_simulate_physics);
    METHOD(bool, is_simulating_physics);
    METHOD(int64_t, get_bone_id);
    METHOD(void, set_mass);
    METHOD(double, get_mass);
    METHOD(void, set_friction);
    METHOD(double, get_friction);
    METHOD(void, set_bounce);
    METHOD(double, get_bounce);
    METHOD(void, set_gravity_scale);
    METHOD(double, get_gravity_scale);
    METHOD(void, set_linear_damp_mode);
    METHOD(int64_t, get_linear_damp_mode);
    METHOD(void, set_angular_damp_mode);
    METHOD(int64_t, get_angular_damp_mode);
    METHOD(void, set_linear_damp);
    METHOD(double, get_linear_damp);
    METHOD(void, set_angular_damp);
    METHOD(double, get_angular_damp);
    METHOD(void, set_linear_velocity);
    METHOD(Vector3, get_linear_velocity);
    METHOD(void, set_angular_velocity);
    METHOD(Vector3, get_angular_velocity);
    METHOD(void, set_use_custom_integrator);
    METHOD(bool, is_using_custom_integrator);
    METHOD(void, set_can_sleep);
    METHOD(bool, is_able_to_sleep);
    static constexpr int64_t DAMP_MODE_COMBINE = 0;
    static constexpr int64_t DAMP_MODE_REPLACE = 1;
    static constexpr int64_t JOINT_TYPE_NONE = 0;
    static constexpr int64_t JOINT_TYPE_PIN = 1;
    static constexpr int64_t JOINT_TYPE_CONE = 2;
    static constexpr int64_t JOINT_TYPE_HINGE = 3;
    static constexpr int64_t JOINT_TYPE_SLIDER = 4;
    static constexpr int64_t JOINT_TYPE_6DOF = 5;
};
struct CheckBox : public Button {
    using Button::Button;
};
struct CheckButton : public Button {
    using Button::Button;
};
struct ColorPickerButton : public Button {
    using Button::Button;
    PROPERTY(color, Color);
    PROPERTY(edit_alpha, bool);
    METHOD(void, set_pick_color);
    METHOD(Color, get_pick_color);
    METHOD(Object, get_picker);
    METHOD(Object, get_popup);
    METHOD(void, set_edit_alpha);
    METHOD(bool, is_editing_alpha);
    METHOD(Variant, _about_to_popup);
};
struct MenuButton : public Button {
    using Button::Button;
    PROPERTY(switch_on_hover, bool);
    PROPERTY(item_count, int64_t);
    METHOD(Object, get_popup);
    METHOD(Variant, show_popup);
    METHOD(void, set_switch_on_hover);
    METHOD(bool, is_switch_on_hover);
    METHOD(void, set_disable_shortcuts);
    METHOD(void, set_item_count);
    METHOD(int64_t, get_item_count);
};
struct OptionButton : public Button {
    using Button::Button;
    PROPERTY(selected, int64_t);
    PROPERTY(fit_to_longest_item, bool);
    PROPERTY(allow_reselect, bool);
    PROPERTY(item_count, int64_t);
    METHOD(Variant, add_item);
    METHOD(Variant, add_icon_item);
    METHOD(void, set_item_text);
    METHOD(void, set_item_icon);
    METHOD(void, set_item_disabled);
    METHOD(void, set_item_id);
    METHOD(void, set_item_metadata);
    METHOD(void, set_item_tooltip);
    METHOD(String, get_item_text);
    METHOD(Object, get_item_icon);
    METHOD(int64_t, get_item_id);
    METHOD(int64_t, get_item_index);
    METHOD(Variant, get_item_metadata);
    METHOD(String, get_item_tooltip);
    METHOD(bool, is_item_disabled);
    METHOD(bool, is_item_separator);
    METHOD(Variant, add_separator);
    METHOD(Variant, clear);
    METHOD(Variant, select);
    METHOD(int64_t, get_selected);
    METHOD(int64_t, get_selected_id);
    METHOD(Variant, get_selected_metadata);
    METHOD(Variant, remove_item);
    METHOD(Variant, _select_int);
    METHOD(Object, get_popup);
    METHOD(Variant, show_popup);
    METHOD(void, set_item_count);
    METHOD(int64_t, get_item_count);
    METHOD(bool, has_selectable_items);
    METHOD(int64_t, get_selectable_item);
    METHOD(void, set_fit_to_longest_item);
    METHOD(bool, is_fit_to_longest_item);
    METHOD(void, set_allow_reselect);
    METHOD(bool, get_allow_reselect);
    METHOD(void, set_disable_shortcuts);
};
struct ScreenSelect : public Button {
    using Button::Button;
};
struct CodeEdit : public TextEdit {
    using TextEdit::TextEdit;
    PROPERTY(symbol_lookup_on_click, bool);
    PROPERTY(line_folding, bool);
    PROPERTY(line_length_guidelines, PackedArray<int32_t>);
    PROPERTY(gutters_draw_breakpoints_gutter, bool);
    PROPERTY(gutters_draw_bookmarks, bool);
    PROPERTY(gutters_draw_executing_lines, bool);
    PROPERTY(gutters_draw_line_numbers, bool);
    PROPERTY(gutters_zero_pad_line_numbers, bool);
    PROPERTY(gutters_draw_fold_gutter, bool);
    PROPERTY(delimiter_strings, PackedArray<std::string>);
    PROPERTY(delimiter_comments, PackedArray<std::string>);
    PROPERTY(code_completion_enabled, bool);
    PROPERTY(code_completion_prefixes, PackedArray<std::string>);
    PROPERTY(indent_size, int64_t);
    PROPERTY(indent_use_spaces, bool);
    PROPERTY(indent_automatic, bool);
    PROPERTY(indent_automatic_prefixes, PackedArray<std::string>);
    PROPERTY(auto_brace_completion_enabled, bool);
    PROPERTY(auto_brace_completion_highlight_matching, bool);
    PROPERTY(auto_brace_completion_pairs, Dictionary);
    METHOD(Variant, _confirm_code_completion);
    METHOD(Variant, _request_code_completion);
    METHOD(Array, _filter_code_completion_candidates);
    METHOD(void, set_indent_size);
    METHOD(int64_t, get_indent_size);
    METHOD(void, set_indent_using_spaces);
    METHOD(bool, is_indent_using_spaces);
    METHOD(void, set_auto_indent_enabled);
    METHOD(bool, is_auto_indent_enabled);
    METHOD(void, set_auto_indent_prefixes);
    METHOD(Array, get_auto_indent_prefixes);
    METHOD(Variant, do_indent);
    METHOD(Variant, indent_lines);
    METHOD(Variant, unindent_lines);
    METHOD(Variant, convert_indent);
    METHOD(void, set_auto_brace_completion_enabled);
    METHOD(bool, is_auto_brace_completion_enabled);
    METHOD(void, set_highlight_matching_braces_enabled);
    METHOD(bool, is_highlight_matching_braces_enabled);
    METHOD(Variant, add_auto_brace_completion_pair);
    METHOD(void, set_auto_brace_completion_pairs);
    METHOD(Dictionary, get_auto_brace_completion_pairs);
    METHOD(bool, has_auto_brace_completion_open_key);
    METHOD(bool, has_auto_brace_completion_close_key);
    METHOD(String, get_auto_brace_completion_close_key);
    METHOD(void, set_draw_breakpoints_gutter);
    METHOD(bool, is_drawing_breakpoints_gutter);
    METHOD(void, set_draw_bookmarks_gutter);
    METHOD(bool, is_drawing_bookmarks_gutter);
    METHOD(void, set_draw_executing_lines_gutter);
    METHOD(bool, is_drawing_executing_lines_gutter);
    METHOD(void, set_line_as_breakpoint);
    METHOD(bool, is_line_breakpointed);
    METHOD(Variant, clear_breakpointed_lines);
    METHOD(PackedArray<int32_t>, get_breakpointed_lines);
    METHOD(void, set_line_as_bookmarked);
    METHOD(bool, is_line_bookmarked);
    METHOD(Variant, clear_bookmarked_lines);
    METHOD(PackedArray<int32_t>, get_bookmarked_lines);
    METHOD(void, set_line_as_executing);
    METHOD(bool, is_line_executing);
    METHOD(Variant, clear_executing_lines);
    METHOD(PackedArray<int32_t>, get_executing_lines);
    METHOD(void, set_draw_line_numbers);
    METHOD(bool, is_draw_line_numbers_enabled);
    METHOD(void, set_line_numbers_zero_padded);
    METHOD(bool, is_line_numbers_zero_padded);
    METHOD(void, set_draw_fold_gutter);
    METHOD(bool, is_drawing_fold_gutter);
    METHOD(void, set_line_folding_enabled);
    METHOD(bool, is_line_folding_enabled);
    METHOD(bool, can_fold_line);
    METHOD(Variant, fold_line);
    METHOD(Variant, unfold_line);
    METHOD(Variant, fold_all_lines);
    METHOD(Variant, unfold_all_lines);
    METHOD(Variant, toggle_foldable_line);
    METHOD(Variant, toggle_foldable_lines_at_carets);
    METHOD(bool, is_line_folded);
    METHOD(Array, get_folded_lines);
    METHOD(Variant, create_code_region);
    METHOD(String, get_code_region_start_tag);
    METHOD(String, get_code_region_end_tag);
    METHOD(void, set_code_region_tags);
    METHOD(bool, is_line_code_region_start);
    METHOD(bool, is_line_code_region_end);
    METHOD(Variant, add_string_delimiter);
    METHOD(Variant, remove_string_delimiter);
    METHOD(bool, has_string_delimiter);
    METHOD(void, set_string_delimiters);
    METHOD(Variant, clear_string_delimiters);
    METHOD(Array, get_string_delimiters);
    METHOD(int64_t, is_in_string);
    METHOD(Variant, add_comment_delimiter);
    METHOD(Variant, remove_comment_delimiter);
    METHOD(bool, has_comment_delimiter);
    METHOD(void, set_comment_delimiters);
    METHOD(Variant, clear_comment_delimiters);
    METHOD(Array, get_comment_delimiters);
    METHOD(int64_t, is_in_comment);
    METHOD(String, get_delimiter_start_key);
    METHOD(String, get_delimiter_end_key);
    METHOD(Vector2, get_delimiter_start_position);
    METHOD(Vector2, get_delimiter_end_position);
    METHOD(void, set_code_hint);
    METHOD(void, set_code_hint_draw_below);
    METHOD(String, get_text_for_code_completion);
    METHOD(Variant, request_code_completion);
    METHOD(Variant, add_code_completion_option);
    METHOD(Variant, update_code_completion_options);
    METHOD(Array, get_code_completion_options);
    METHOD(Dictionary, get_code_completion_option);
    METHOD(int64_t, get_code_completion_selected_index);
    METHOD(void, set_code_completion_selected_index);
    METHOD(Variant, confirm_code_completion);
    METHOD(Variant, cancel_code_completion);
    METHOD(void, set_code_completion_enabled);
    METHOD(bool, is_code_completion_enabled);
    METHOD(void, set_code_completion_prefixes);
    METHOD(Array, get_code_completion_prefixes);
    METHOD(void, set_line_length_guidelines);
    METHOD(Array, get_line_length_guidelines);
    METHOD(void, set_symbol_lookup_on_click_enabled);
    METHOD(bool, is_symbol_lookup_on_click_enabled);
    METHOD(String, get_text_for_symbol_lookup);
    METHOD(String, get_text_with_cursor_char);
    METHOD(void, set_symbol_lookup_word_as_valid);
    METHOD(Variant, move_lines_up);
    METHOD(Variant, move_lines_down);
    METHOD(Variant, delete_lines);
    METHOD(Variant, duplicate_selection);
    METHOD(Variant, duplicate_lines);
    static constexpr int64_t KIND_CLASS = 0;
    static constexpr int64_t KIND_FUNCTION = 1;
    static constexpr int64_t KIND_SIGNAL = 2;
    static constexpr int64_t KIND_VARIABLE = 3;
    static constexpr int64_t KIND_MEMBER = 4;
    static constexpr int64_t KIND_ENUM = 5;
    static constexpr int64_t KIND_CONSTANT = 6;
    static constexpr int64_t KIND_NODE_PATH = 7;
    static constexpr int64_t KIND_FILE_PATH = 8;
    static constexpr int64_t KIND_PLAIN_TEXT = 9;
    static constexpr int64_t LOCATION_LOCAL = 0;
    static constexpr int64_t LOCATION_PARENT_MASK = 256;
    static constexpr int64_t LOCATION_OTHER_USER_CODE = 512;
    static constexpr int64_t LOCATION_OTHER = 1024;
};
struct CodeHighlighter : public SyntaxHighlighter {
    using SyntaxHighlighter::SyntaxHighlighter;
    PROPERTY(number_color, Color);
    PROPERTY(symbol_color, Color);
    PROPERTY(function_color, Color);
    PROPERTY(member_variable_color, Color);
    PROPERTY(keyword_colors, Dictionary);
    PROPERTY(member_keyword_colors, Dictionary);
    PROPERTY(color_regions, Dictionary);
    METHOD(Variant, add_keyword_color);
    METHOD(Variant, remove_keyword_color);
    METHOD(bool, has_keyword_color);
    METHOD(Color, get_keyword_color);
    METHOD(void, set_keyword_colors);
    METHOD(Variant, clear_keyword_colors);
    METHOD(Dictionary, get_keyword_colors);
    METHOD(Variant, add_member_keyword_color);
    METHOD(Variant, remove_member_keyword_color);
    METHOD(bool, has_member_keyword_color);
    METHOD(Color, get_member_keyword_color);
    METHOD(void, set_member_keyword_colors);
    METHOD(Variant, clear_member_keyword_colors);
    METHOD(Dictionary, get_member_keyword_colors);
    METHOD(Variant, add_color_region);
    METHOD(Variant, remove_color_region);
    METHOD(bool, has_color_region);
    METHOD(void, set_color_regions);
    METHOD(Variant, clear_color_regions);
    METHOD(Dictionary, get_color_regions);
    METHOD(void, set_function_color);
    METHOD(Color, get_function_color);
    METHOD(void, set_number_color);
    METHOD(Color, get_number_color);
    METHOD(void, set_symbol_color);
    METHOD(Color, get_symbol_color);
    METHOD(void, set_member_variable_color);
    METHOD(Color, get_member_variable_color);
};
struct CompressedTexture3D : public Texture3D {
    using Texture3D::Texture3D;
    PROPERTY(load_path, String);
    METHOD(int64_t, load);
    METHOD(String, get_load_path);
};
struct ImageTexture3D : public Texture3D {
    using Texture3D::Texture3D;
    PROPERTY(_images, Array);
    METHOD(int64_t, create);
    METHOD(Variant, update);
    METHOD(Array, _get_images);
    METHOD(Variant, _set_images);
};
struct NoiseTexture3D : public Texture3D {
    using Texture3D::Texture3D;
    PROPERTY(width, int64_t);
    PROPERTY(height, int64_t);
    PROPERTY(depth, int64_t);
    PROPERTY(invert, bool);
    PROPERTY(seamless, bool);
    PROPERTY(seamless_blend_skirt, double);
    PROPERTY(normalize, bool);
    PROPERTY(color_ramp, Object);
    PROPERTY(noise, Object);
    METHOD(void, set_width);
    METHOD(void, set_height);
    METHOD(void, set_depth);
    METHOD(void, set_invert);
    METHOD(bool, get_invert);
    METHOD(void, set_seamless);
    METHOD(bool, get_seamless);
    METHOD(void, set_seamless_blend_skirt);
    METHOD(double, get_seamless_blend_skirt);
    METHOD(void, set_normalize);
    METHOD(bool, is_normalized);
    METHOD(void, set_color_ramp);
    METHOD(Object, get_color_ramp);
    METHOD(void, set_noise);
    METHOD(Object, get_noise);
};
struct PlaceholderTexture3D : public Texture3D {
    using Texture3D::Texture3D;
    PROPERTY(size, Vector3i);
    METHOD(void, set_size);
    METHOD(Vector3i, get_size);
};
struct CompressedTextureLayered : public TextureLayered {
    using TextureLayered::TextureLayered;
    PROPERTY(load_path, String);
    METHOD(int64_t, load);
    METHOD(String, get_load_path);
};
struct ImageTextureLayered : public TextureLayered {
    using TextureLayered::TextureLayered;
    PROPERTY(_images, Array);
    METHOD(int64_t, create_from_images);
    METHOD(Variant, update_layer);
    METHOD(Array, _get_images);
    METHOD(Variant, _set_images);
};
struct PlaceholderTextureLayered : public TextureLayered {
    using TextureLayered::TextureLayered;
    PROPERTY(size, Vector2i);
    PROPERTY(layers, int64_t);
    METHOD(void, set_size);
    METHOD(Vector2i, get_size);
    METHOD(void, set_layers);
};
struct CompressedCubemap : public CompressedTextureLayered {
    using CompressedTextureLayered::CompressedTextureLayered;
};
struct CompressedCubemapArray : public CompressedTextureLayered {
    using CompressedTextureLayered::CompressedTextureLayered;
};
struct CompressedTexture2DArray : public CompressedTextureLayered {
    using CompressedTextureLayered::CompressedTextureLayered;
};
struct ConeTwistJoint3D : public Joint3D {
    using Joint3D::Joint3D;
    PROPERTY(swing_span, double);
    PROPERTY(twist_span, double);
    PROPERTY(bias, double);
    PROPERTY(softness, double);
    PROPERTY(relaxation, double);
    METHOD(void, set_param);
    METHOD(double, get_param);
    static constexpr int64_t PARAM_SWING_SPAN = 0;
    static constexpr int64_t PARAM_TWIST_SPAN = 1;
    static constexpr int64_t PARAM_BIAS = 2;
    static constexpr int64_t PARAM_SOFTNESS = 3;
    static constexpr int64_t PARAM_RELAXATION = 4;
    static constexpr int64_t PARAM_MAX = 5;
};
struct Generic6DOFJoint3D : public Joint3D {
    using Joint3D::Joint3D;
    METHOD(void, set_param_x);
    METHOD(double, get_param_x);
    METHOD(void, set_param_y);
    METHOD(double, get_param_y);
    METHOD(void, set_param_z);
    METHOD(double, get_param_z);
    METHOD(void, set_flag_x);
    METHOD(bool, get_flag_x);
    METHOD(void, set_flag_y);
    METHOD(bool, get_flag_y);
    METHOD(void, set_flag_z);
    METHOD(bool, get_flag_z);
    static constexpr int64_t PARAM_LINEAR_LOWER_LIMIT = 0;
    static constexpr int64_t PARAM_LINEAR_UPPER_LIMIT = 1;
    static constexpr int64_t PARAM_LINEAR_LIMIT_SOFTNESS = 2;
    static constexpr int64_t PARAM_LINEAR_RESTITUTION = 3;
    static constexpr int64_t PARAM_LINEAR_DAMPING = 4;
    static constexpr int64_t PARAM_LINEAR_MOTOR_TARGET_VELOCITY = 5;
    static constexpr int64_t PARAM_LINEAR_MOTOR_FORCE_LIMIT = 6;
    static constexpr int64_t PARAM_LINEAR_SPRING_STIFFNESS = 7;
    static constexpr int64_t PARAM_LINEAR_SPRING_DAMPING = 8;
    static constexpr int64_t PARAM_LINEAR_SPRING_EQUILIBRIUM_POINT = 9;
    static constexpr int64_t PARAM_ANGULAR_LOWER_LIMIT = 10;
    static constexpr int64_t PARAM_ANGULAR_UPPER_LIMIT = 11;
    static constexpr int64_t PARAM_ANGULAR_LIMIT_SOFTNESS = 12;
    static constexpr int64_t PARAM_ANGULAR_DAMPING = 13;
    static constexpr int64_t PARAM_ANGULAR_RESTITUTION = 14;
    static constexpr int64_t PARAM_ANGULAR_FORCE_LIMIT = 15;
    static constexpr int64_t PARAM_ANGULAR_ERP = 16;
    static constexpr int64_t PARAM_ANGULAR_MOTOR_TARGET_VELOCITY = 17;
    static constexpr int64_t PARAM_ANGULAR_MOTOR_FORCE_LIMIT = 18;
    static constexpr int64_t PARAM_ANGULAR_SPRING_STIFFNESS = 19;
    static constexpr int64_t PARAM_ANGULAR_SPRING_DAMPING = 20;
    static constexpr int64_t PARAM_ANGULAR_SPRING_EQUILIBRIUM_POINT = 21;
    static constexpr int64_t PARAM_MAX = 22;
    static constexpr int64_t FLAG_ENABLE_LINEAR_LIMIT = 0;
    static constexpr int64_t FLAG_ENABLE_ANGULAR_LIMIT = 1;
    static constexpr int64_t FLAG_ENABLE_LINEAR_SPRING = 3;
    static constexpr int64_t FLAG_ENABLE_ANGULAR_SPRING = 2;
    static constexpr int64_t FLAG_ENABLE_MOTOR = 4;
    static constexpr int64_t FLAG_ENABLE_LINEAR_MOTOR = 5;
    static constexpr int64_t FLAG_MAX = 6;
};
struct HingeJoint3D : public Joint3D {
    using Joint3D::Joint3D;
    METHOD(void, set_param);
    METHOD(double, get_param);
    METHOD(void, set_flag);
    METHOD(bool, get_flag);
    static constexpr int64_t PARAM_BIAS = 0;
    static constexpr int64_t PARAM_LIMIT_UPPER = 1;
    static constexpr int64_t PARAM_LIMIT_LOWER = 2;
    static constexpr int64_t PARAM_LIMIT_BIAS = 3;
    static constexpr int64_t PARAM_LIMIT_SOFTNESS = 4;
    static constexpr int64_t PARAM_LIMIT_RELAXATION = 5;
    static constexpr int64_t PARAM_MOTOR_TARGET_VELOCITY = 6;
    static constexpr int64_t PARAM_MOTOR_MAX_IMPULSE = 7;
    static constexpr int64_t PARAM_MAX = 8;
    static constexpr int64_t FLAG_USE_LIMIT = 0;
    static constexpr int64_t FLAG_ENABLE_MOTOR = 1;
    static constexpr int64_t FLAG_MAX = 2;
};
struct ConfirmationDialog : public AcceptDialog {
    using AcceptDialog::AcceptDialog;
    PROPERTY(cancel_button_text, String);
    METHOD(Object, get_cancel_button);
    METHOD(void, set_cancel_button_text);
    METHOD(String, get_cancel_button_text);
};
struct ConnectionInfoDialog : public AcceptDialog {
    using AcceptDialog::AcceptDialog;
};
struct ExportTemplateManager : public AcceptDialog {
    using AcceptDialog::AcceptDialog;
};
struct FindInFilesDialog : public AcceptDialog {
    using AcceptDialog::AcceptDialog;
};
struct RunInstancesDialog : public AcceptDialog {
    using AcceptDialog::AcceptDialog;
};
struct UVEditDialog : public AcceptDialog {
    using AcceptDialog::AcceptDialog;
};
struct AtlasMergingDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct AudioStreamImportSettingsDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct ConnectDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct CreateDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct DependencyErrorDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct DependencyRemoveDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct DirectoryCreateDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct DynamicFontImportSettingsDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct FBXImporterManager : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct FileDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    PROPERTY(mode_overrides_title, bool);
    PROPERTY(file_mode, int64_t);
    PROPERTY(access, int64_t);
    PROPERTY(root_subfolder, String);
    PROPERTY(filters, PackedArray<std::string>);
    PROPERTY(option_count, int64_t);
    PROPERTY(show_hidden_files, bool);
    PROPERTY(use_native_dialog, bool);
    PROPERTY(current_dir, String);
    PROPERTY(current_file, String);
    PROPERTY(current_path, String);
    METHOD(Variant, _cancel_pressed);
    METHOD(Variant, clear_filters);
    METHOD(Variant, add_filter);
    METHOD(void, set_filters);
    METHOD(PackedArray<std::string>, get_filters);
    METHOD(String, get_option_name);
    METHOD(PackedArray<std::string>, get_option_values);
    METHOD(int64_t, get_option_default);
    METHOD(void, set_option_name);
    METHOD(void, set_option_values);
    METHOD(void, set_option_default);
    METHOD(void, set_option_count);
    METHOD(int64_t, get_option_count);
    METHOD(Variant, add_option);
    METHOD(Dictionary, get_selected_options);
    METHOD(String, get_current_dir);
    METHOD(String, get_current_file);
    METHOD(String, get_current_path);
    METHOD(void, set_current_dir);
    METHOD(void, set_current_file);
    METHOD(void, set_current_path);
    METHOD(void, set_mode_overrides_title);
    METHOD(bool, is_mode_overriding_title);
    METHOD(void, set_file_mode);
    METHOD(int64_t, get_file_mode);
    METHOD(Object, get_vbox);
    METHOD(Object, get_line_edit);
    METHOD(void, set_access);
    METHOD(int64_t, get_access);
    METHOD(void, set_root_subfolder);
    METHOD(String, get_root_subfolder);
    METHOD(void, set_show_hidden_files);
    METHOD(bool, is_showing_hidden_files);
    METHOD(void, set_use_native_dialog);
    METHOD(bool, get_use_native_dialog);
    METHOD(Variant, deselect_all);
    METHOD(Variant, invalidate);
    static constexpr int64_t FILE_MODE_OPEN_FILE = 0;
    static constexpr int64_t FILE_MODE_OPEN_FILES = 1;
    static constexpr int64_t FILE_MODE_OPEN_DIR = 2;
    static constexpr int64_t FILE_MODE_OPEN_ANY = 3;
    static constexpr int64_t FILE_MODE_SAVE_FILE = 4;
    static constexpr int64_t ACCESS_RESOURCES = 0;
    static constexpr int64_t ACCESS_USERDATA = 1;
    static constexpr int64_t ACCESS_FILESYSTEM = 2;
};
struct GotoLineDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct InputEventConfigurationDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct OrphanResourcesDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct PluginConfigDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct ProjectExportDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    PROPERTY(export_path, String);
    METHOD(void, set_export_path);
    METHOD(String, get_export_path);
    METHOD(Object, get_current_preset);
};
struct PropertySelector : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct RenameDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    METHOD(Variant, rename);
};
struct ReparentDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    METHOD(Variant, _cancel);
};
struct SceneCreateDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct SceneImportSettingsDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct SceneTreeDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    METHOD(Variant, _cancel);
};
struct ScriptCreateDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    METHOD(Variant, config);
};
struct ShaderCreateDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    METHOD(Variant, config);
};
struct SnapDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct SurfaceUpgradeDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct ThemeTypeDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
};
struct TileProxiesManagerDialog : public ConfirmationDialog {
    using ConfirmationDialog::ConfirmationDialog;
    METHOD(Variant, _update_lists);
    METHOD(Variant, _unhandled_key_input);
};
struct Cubemap : public ImageTextureLayered {
    using ImageTextureLayered::ImageTextureLayered;
    METHOD(Object, create_placeholder);
};
struct CubemapArray : public ImageTextureLayered {
    using ImageTextureLayered::ImageTextureLayered;
    METHOD(Object, create_placeholder);
};
struct Texture2DArray : public ImageTextureLayered {
    using ImageTextureLayered::ImageTextureLayered;
    METHOD(Object, create_placeholder);
};
struct DampedSpringJoint2D : public Joint2D {
    using Joint2D::Joint2D;
    PROPERTY(length, double);
    PROPERTY(rest_length, double);
    PROPERTY(stiffness, double);
    PROPERTY(damping, double);
    METHOD(void, set_length);
    METHOD(double, get_length);
    METHOD(void, set_rest_length);
    METHOD(double, get_rest_length);
    METHOD(void, set_stiffness);
    METHOD(double, get_stiffness);
    METHOD(void, set_damping);
    METHOD(double, get_damping);
};
struct GrooveJoint2D : public Joint2D {
    using Joint2D::Joint2D;
    PROPERTY(length, double);
    PROPERTY(initial_offset, double);
    METHOD(void, set_length);
    METHOD(double, get_length);
    METHOD(void, set_initial_offset);
    METHOD(double, get_initial_offset);
};
struct Decal : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(size, Vector3);
    PROPERTY(texture_albedo, Object);
    PROPERTY(texture_normal, Object);
    PROPERTY(texture_orm, Object);
    PROPERTY(texture_emission, Object);
    PROPERTY(emission_energy, double);
    PROPERTY(modulate, Color);
    PROPERTY(albedo_mix, double);
    PROPERTY(normal_fade, double);
    PROPERTY(upper_fade, double);
    PROPERTY(lower_fade, double);
    PROPERTY(distance_fade_enabled, bool);
    PROPERTY(distance_fade_begin, double);
    PROPERTY(distance_fade_length, double);
    PROPERTY(cull_mask, int64_t);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_emission_energy);
    METHOD(double, get_emission_energy);
    METHOD(void, set_albedo_mix);
    METHOD(double, get_albedo_mix);
    METHOD(void, set_modulate);
    METHOD(Color, get_modulate);
    METHOD(void, set_upper_fade);
    METHOD(double, get_upper_fade);
    METHOD(void, set_lower_fade);
    METHOD(double, get_lower_fade);
    METHOD(void, set_normal_fade);
    METHOD(double, get_normal_fade);
    METHOD(void, set_enable_distance_fade);
    METHOD(bool, is_distance_fade_enabled);
    METHOD(void, set_distance_fade_begin);
    METHOD(double, get_distance_fade_begin);
    METHOD(void, set_distance_fade_length);
    METHOD(double, get_distance_fade_length);
    METHOD(void, set_cull_mask);
    METHOD(int64_t, get_cull_mask);
    static constexpr int64_t TEXTURE_ALBEDO = 0;
    static constexpr int64_t TEXTURE_NORMAL = 1;
    static constexpr int64_t TEXTURE_ORM = 2;
    static constexpr int64_t TEXTURE_EMISSION = 3;
    static constexpr int64_t TEXTURE_MAX = 4;
};
struct FogVolume : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(size, Vector3);
    PROPERTY(shape, int64_t);
    PROPERTY(material, Object);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_shape);
    METHOD(int64_t, get_shape);
    METHOD(void, set_material);
    METHOD(Object, get_material);
};
struct GPUParticlesAttractor3D : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(strength, double);
    PROPERTY(attenuation, double);
    PROPERTY(directionality, double);
    PROPERTY(cull_mask, int64_t);
    METHOD(void, set_cull_mask);
    METHOD(int64_t, get_cull_mask);
    METHOD(void, set_strength);
    METHOD(double, get_strength);
    METHOD(void, set_attenuation);
    METHOD(double, get_attenuation);
    METHOD(void, set_directionality);
    METHOD(double, get_directionality);
};
struct GPUParticlesCollision3D : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(cull_mask, int64_t);
    METHOD(void, set_cull_mask);
    METHOD(int64_t, get_cull_mask);
};
struct GeometryInstance3D : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(material_override, Object);
    PROPERTY(material_overlay, Object);
    PROPERTY(transparency, double);
    PROPERTY(cast_shadow, int64_t);
    PROPERTY(extra_cull_margin, double);
    PROPERTY(custom_aabb, Variant);
    PROPERTY(lod_bias, double);
    PROPERTY(ignore_occlusion_culling, bool);
    PROPERTY(gi_mode, int64_t);
    PROPERTY(gi_lightmap_scale, int64_t);
    PROPERTY(visibility_range_begin, double);
    PROPERTY(visibility_range_begin_margin, double);
    PROPERTY(visibility_range_end, double);
    PROPERTY(visibility_range_end_margin, double);
    PROPERTY(visibility_range_fade_mode, int64_t);
    METHOD(void, set_material_override);
    METHOD(Object, get_material_override);
    METHOD(void, set_material_overlay);
    METHOD(Object, get_material_overlay);
    METHOD(void, set_cast_shadows_setting);
    METHOD(int64_t, get_cast_shadows_setting);
    METHOD(void, set_lod_bias);
    METHOD(double, get_lod_bias);
    METHOD(void, set_transparency);
    METHOD(double, get_transparency);
    METHOD(void, set_visibility_range_end_margin);
    METHOD(double, get_visibility_range_end_margin);
    METHOD(void, set_visibility_range_end);
    METHOD(double, get_visibility_range_end);
    METHOD(void, set_visibility_range_begin_margin);
    METHOD(double, get_visibility_range_begin_margin);
    METHOD(void, set_visibility_range_begin);
    METHOD(double, get_visibility_range_begin);
    METHOD(void, set_visibility_range_fade_mode);
    METHOD(int64_t, get_visibility_range_fade_mode);
    METHOD(void, set_instance_shader_parameter);
    METHOD(Variant, get_instance_shader_parameter);
    METHOD(void, set_extra_cull_margin);
    METHOD(double, get_extra_cull_margin);
    METHOD(void, set_lightmap_scale);
    METHOD(int64_t, get_lightmap_scale);
    METHOD(void, set_gi_mode);
    METHOD(int64_t, get_gi_mode);
    METHOD(void, set_ignore_occlusion_culling);
    METHOD(bool, is_ignoring_occlusion_culling);
    METHOD(void, set_custom_aabb);
    METHOD(Variant, get_custom_aabb);
    static constexpr int64_t SHADOW_CASTING_SETTING_OFF = 0;
    static constexpr int64_t SHADOW_CASTING_SETTING_ON = 1;
    static constexpr int64_t SHADOW_CASTING_SETTING_DOUBLE_SIDED = 2;
    static constexpr int64_t SHADOW_CASTING_SETTING_SHADOWS_ONLY = 3;
    static constexpr int64_t GI_MODE_DISABLED = 0;
    static constexpr int64_t GI_MODE_STATIC = 1;
    static constexpr int64_t GI_MODE_DYNAMIC = 2;
    static constexpr int64_t LIGHTMAP_SCALE_1X = 0;
    static constexpr int64_t LIGHTMAP_SCALE_2X = 1;
    static constexpr int64_t LIGHTMAP_SCALE_4X = 2;
    static constexpr int64_t LIGHTMAP_SCALE_8X = 3;
    static constexpr int64_t LIGHTMAP_SCALE_MAX = 4;
    static constexpr int64_t VISIBILITY_RANGE_FADE_DISABLED = 0;
    static constexpr int64_t VISIBILITY_RANGE_FADE_SELF = 1;
    static constexpr int64_t VISIBILITY_RANGE_FADE_DEPENDENCIES = 2;
};
struct Light3D : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(light_intensity_lumens, double);
    PROPERTY(light_intensity_lux, double);
    PROPERTY(light_temperature, double);
    PROPERTY(light_color, Color);
    PROPERTY(light_energy, double);
    PROPERTY(light_indirect_energy, double);
    PROPERTY(light_volumetric_fog_energy, double);
    PROPERTY(light_projector, Object);
    PROPERTY(light_size, double);
    PROPERTY(light_angular_distance, double);
    PROPERTY(light_negative, bool);
    PROPERTY(light_specular, double);
    PROPERTY(light_bake_mode, int64_t);
    PROPERTY(light_cull_mask, int64_t);
    PROPERTY(shadow_enabled, bool);
    PROPERTY(shadow_bias, double);
    PROPERTY(shadow_normal_bias, double);
    PROPERTY(shadow_reverse_cull_face, bool);
    PROPERTY(shadow_transmittance_bias, double);
    PROPERTY(shadow_opacity, double);
    PROPERTY(shadow_blur, double);
    PROPERTY(distance_fade_enabled, bool);
    PROPERTY(distance_fade_begin, double);
    PROPERTY(distance_fade_shadow, double);
    PROPERTY(distance_fade_length, double);
    PROPERTY(editor_only, bool);
    METHOD(void, set_editor_only);
    METHOD(bool, is_editor_only);
    METHOD(void, set_param);
    METHOD(double, get_param);
    METHOD(void, set_shadow);
    METHOD(bool, has_shadow);
    METHOD(void, set_negative);
    METHOD(bool, is_negative);
    METHOD(void, set_cull_mask);
    METHOD(int64_t, get_cull_mask);
    METHOD(void, set_enable_distance_fade);
    METHOD(bool, is_distance_fade_enabled);
    METHOD(void, set_distance_fade_begin);
    METHOD(double, get_distance_fade_begin);
    METHOD(void, set_distance_fade_shadow);
    METHOD(double, get_distance_fade_shadow);
    METHOD(void, set_distance_fade_length);
    METHOD(double, get_distance_fade_length);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_shadow_reverse_cull_face);
    METHOD(bool, get_shadow_reverse_cull_face);
    METHOD(void, set_bake_mode);
    METHOD(int64_t, get_bake_mode);
    METHOD(void, set_projector);
    METHOD(Object, get_projector);
    METHOD(void, set_temperature);
    METHOD(double, get_temperature);
    METHOD(Color, get_correlated_color);
    static constexpr int64_t PARAM_ENERGY = 0;
    static constexpr int64_t PARAM_INDIRECT_ENERGY = 1;
    static constexpr int64_t PARAM_VOLUMETRIC_FOG_ENERGY = 2;
    static constexpr int64_t PARAM_SPECULAR = 3;
    static constexpr int64_t PARAM_RANGE = 4;
    static constexpr int64_t PARAM_SIZE = 5;
    static constexpr int64_t PARAM_ATTENUATION = 6;
    static constexpr int64_t PARAM_SPOT_ANGLE = 7;
    static constexpr int64_t PARAM_SPOT_ATTENUATION = 8;
    static constexpr int64_t PARAM_SHADOW_MAX_DISTANCE = 9;
    static constexpr int64_t PARAM_SHADOW_SPLIT_1_OFFSET = 10;
    static constexpr int64_t PARAM_SHADOW_SPLIT_2_OFFSET = 11;
    static constexpr int64_t PARAM_SHADOW_SPLIT_3_OFFSET = 12;
    static constexpr int64_t PARAM_SHADOW_FADE_START = 13;
    static constexpr int64_t PARAM_SHADOW_NORMAL_BIAS = 14;
    static constexpr int64_t PARAM_SHADOW_BIAS = 15;
    static constexpr int64_t PARAM_SHADOW_PANCAKE_SIZE = 16;
    static constexpr int64_t PARAM_SHADOW_OPACITY = 17;
    static constexpr int64_t PARAM_SHADOW_BLUR = 18;
    static constexpr int64_t PARAM_TRANSMITTANCE_BIAS = 19;
    static constexpr int64_t PARAM_INTENSITY = 20;
    static constexpr int64_t PARAM_MAX = 21;
    static constexpr int64_t BAKE_DISABLED = 0;
    static constexpr int64_t BAKE_STATIC = 1;
    static constexpr int64_t BAKE_DYNAMIC = 2;
};
struct LightmapGI : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(quality, int64_t);
    PROPERTY(bounces, int64_t);
    PROPERTY(bounce_indirect_energy, double);
    PROPERTY(directional, bool);
    PROPERTY(use_texture_for_bounces, bool);
    PROPERTY(interior, bool);
    PROPERTY(use_denoiser, bool);
    PROPERTY(denoiser_strength, double);
    PROPERTY(denoiser_range, int64_t);
    PROPERTY(bias, double);
    PROPERTY(texel_scale, double);
    PROPERTY(max_texture_size, int64_t);
    PROPERTY(environment_mode, int64_t);
    PROPERTY(environment_custom_sky, Object);
    PROPERTY(environment_custom_color, Color);
    PROPERTY(environment_custom_energy, double);
    PROPERTY(camera_attributes, Object);
    PROPERTY(generate_probes_subdiv, int64_t);
    PROPERTY(light_data, Object);
    METHOD(void, set_light_data);
    METHOD(Object, get_light_data);
    METHOD(void, set_bake_quality);
    METHOD(int64_t, get_bake_quality);
    METHOD(void, set_bounces);
    METHOD(int64_t, get_bounces);
    METHOD(void, set_bounce_indirect_energy);
    METHOD(double, get_bounce_indirect_energy);
    METHOD(void, set_generate_probes);
    METHOD(int64_t, get_generate_probes);
    METHOD(void, set_bias);
    METHOD(double, get_bias);
    METHOD(void, set_environment_mode);
    METHOD(int64_t, get_environment_mode);
    METHOD(void, set_environment_custom_sky);
    METHOD(Object, get_environment_custom_sky);
    METHOD(void, set_environment_custom_color);
    METHOD(Color, get_environment_custom_color);
    METHOD(void, set_environment_custom_energy);
    METHOD(double, get_environment_custom_energy);
    METHOD(void, set_texel_scale);
    METHOD(double, get_texel_scale);
    METHOD(void, set_max_texture_size);
    METHOD(int64_t, get_max_texture_size);
    METHOD(void, set_use_denoiser);
    METHOD(bool, is_using_denoiser);
    METHOD(void, set_denoiser_strength);
    METHOD(double, get_denoiser_strength);
    METHOD(void, set_denoiser_range);
    METHOD(int64_t, get_denoiser_range);
    METHOD(void, set_interior);
    METHOD(bool, is_interior);
    METHOD(void, set_directional);
    METHOD(bool, is_directional);
    METHOD(void, set_use_texture_for_bounces);
    METHOD(bool, is_using_texture_for_bounces);
    METHOD(void, set_camera_attributes);
    METHOD(Object, get_camera_attributes);
    static constexpr int64_t BAKE_QUALITY_LOW = 0;
    static constexpr int64_t BAKE_QUALITY_MEDIUM = 1;
    static constexpr int64_t BAKE_QUALITY_HIGH = 2;
    static constexpr int64_t BAKE_QUALITY_ULTRA = 3;
    static constexpr int64_t GENERATE_PROBES_DISABLED = 0;
    static constexpr int64_t GENERATE_PROBES_SUBDIV_4 = 1;
    static constexpr int64_t GENERATE_PROBES_SUBDIV_8 = 2;
    static constexpr int64_t GENERATE_PROBES_SUBDIV_16 = 3;
    static constexpr int64_t GENERATE_PROBES_SUBDIV_32 = 4;
    static constexpr int64_t BAKE_ERROR_OK = 0;
    static constexpr int64_t BAKE_ERROR_NO_SCENE_ROOT = 1;
    static constexpr int64_t BAKE_ERROR_FOREIGN_DATA = 2;
    static constexpr int64_t BAKE_ERROR_NO_LIGHTMAPPER = 3;
    static constexpr int64_t BAKE_ERROR_NO_SAVE_PATH = 4;
    static constexpr int64_t BAKE_ERROR_NO_MESHES = 5;
    static constexpr int64_t BAKE_ERROR_MESHES_INVALID = 6;
    static constexpr int64_t BAKE_ERROR_CANT_CREATE_IMAGE = 7;
    static constexpr int64_t BAKE_ERROR_USER_ABORTED = 8;
    static constexpr int64_t BAKE_ERROR_TEXTURE_SIZE_TOO_SMALL = 9;
    static constexpr int64_t BAKE_ERROR_LIGHTMAP_TOO_SMALL = 10;
    static constexpr int64_t BAKE_ERROR_ATLAS_TOO_SMALL = 11;
    static constexpr int64_t ENVIRONMENT_MODE_DISABLED = 0;
    static constexpr int64_t ENVIRONMENT_MODE_SCENE = 1;
    static constexpr int64_t ENVIRONMENT_MODE_CUSTOM_SKY = 2;
    static constexpr int64_t ENVIRONMENT_MODE_CUSTOM_COLOR = 3;
};
struct OccluderInstance3D : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(occluder, Object);
    PROPERTY(bake_mask, int64_t);
    PROPERTY(bake_simplification_distance, double);
    METHOD(void, set_bake_mask);
    METHOD(int64_t, get_bake_mask);
    METHOD(void, set_bake_mask_value);
    METHOD(bool, get_bake_mask_value);
    METHOD(void, set_bake_simplification_distance);
    METHOD(double, get_bake_simplification_distance);
    METHOD(void, set_occluder);
    METHOD(Object, get_occluder);
    METHOD(bool, _is_editable_3d_polygon);
    METHOD(Object, _get_editable_3d_polygon_resource);
};
struct ReflectionProbe : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(update_mode, int64_t);
    PROPERTY(intensity, double);
    PROPERTY(max_distance, double);
    PROPERTY(size, Vector3);
    PROPERTY(origin_offset, Vector3);
    PROPERTY(box_projection, bool);
    PROPERTY(interior, bool);
    PROPERTY(enable_shadows, bool);
    PROPERTY(cull_mask, int64_t);
    PROPERTY(reflection_mask, int64_t);
    PROPERTY(mesh_lod_threshold, double);
    PROPERTY(ambient_mode, int64_t);
    PROPERTY(ambient_color, Color);
    PROPERTY(ambient_color_energy, double);
    METHOD(void, set_intensity);
    METHOD(double, get_intensity);
    METHOD(void, set_ambient_mode);
    METHOD(int64_t, get_ambient_mode);
    METHOD(void, set_ambient_color);
    METHOD(Color, get_ambient_color);
    METHOD(void, set_ambient_color_energy);
    METHOD(double, get_ambient_color_energy);
    METHOD(void, set_max_distance);
    METHOD(double, get_max_distance);
    METHOD(void, set_mesh_lod_threshold);
    METHOD(double, get_mesh_lod_threshold);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_origin_offset);
    METHOD(Vector3, get_origin_offset);
    METHOD(void, set_as_interior);
    METHOD(bool, is_set_as_interior);
    METHOD(void, set_enable_box_projection);
    METHOD(bool, is_box_projection_enabled);
    METHOD(void, set_enable_shadows);
    METHOD(bool, are_shadows_enabled);
    METHOD(void, set_cull_mask);
    METHOD(int64_t, get_cull_mask);
    METHOD(void, set_reflection_mask);
    METHOD(int64_t, get_reflection_mask);
    METHOD(void, set_update_mode);
    METHOD(int64_t, get_update_mode);
    static constexpr int64_t UPDATE_ONCE = 0;
    static constexpr int64_t UPDATE_ALWAYS = 1;
    static constexpr int64_t AMBIENT_DISABLED = 0;
    static constexpr int64_t AMBIENT_ENVIRONMENT = 1;
    static constexpr int64_t AMBIENT_COLOR = 2;
};
struct RootMotionView : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(animation_path, String);
    PROPERTY(color, Color);
    PROPERTY(cell_size, double);
    PROPERTY(radius, double);
    PROPERTY(zero_y, bool);
    METHOD(void, set_animation_path);
    METHOD(String, get_animation_path);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_cell_size);
    METHOD(double, get_cell_size);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_zero_y);
    METHOD(bool, get_zero_y);
};
struct VisibleOnScreenNotifier3D : public VisualInstance3D {
    using VisualInstance3D::VisualInstance3D;
    PROPERTY(aabb, Variant);
    METHOD(void, set_aabb);
    METHOD(bool, is_on_screen);
};
struct CPUParticles3D : public GeometryInstance3D {
    using GeometryInstance3D::GeometryInstance3D;
    PROPERTY(emitting, bool);
    PROPERTY(amount, int64_t);
    PROPERTY(lifetime, double);
    PROPERTY(one_shot, bool);
    PROPERTY(preprocess, double);
    PROPERTY(speed_scale, double);
    PROPERTY(explosiveness, double);
    PROPERTY(randomness, double);
    PROPERTY(lifetime_randomness, double);
    PROPERTY(fixed_fps, int64_t);
    PROPERTY(fract_delta, bool);
    PROPERTY(visibility_aabb, Variant);
    PROPERTY(local_coords, bool);
    PROPERTY(draw_order, int64_t);
    PROPERTY(mesh, Object);
    PROPERTY(emission_shape, int64_t);
    PROPERTY(emission_sphere_radius, double);
    PROPERTY(emission_box_extents, Vector3);
    PROPERTY(emission_points, PackedArray<Vector3>);
    PROPERTY(emission_normals, PackedArray<Vector3>);
    PROPERTY(emission_colors, PackedArray<Color>);
    PROPERTY(emission_ring_axis, Vector3);
    PROPERTY(emission_ring_height, double);
    PROPERTY(emission_ring_radius, double);
    PROPERTY(emission_ring_inner_radius, double);
    PROPERTY(particle_flag_align_y, bool);
    PROPERTY(particle_flag_rotate_y, bool);
    PROPERTY(particle_flag_disable_z, bool);
    PROPERTY(direction, Vector3);
    PROPERTY(spread, double);
    PROPERTY(flatness, double);
    PROPERTY(gravity, Vector3);
    PROPERTY(initial_velocity_min, double);
    PROPERTY(initial_velocity_max, double);
    PROPERTY(angular_velocity_min, double);
    PROPERTY(angular_velocity_max, double);
    PROPERTY(angular_velocity_curve, Object);
    PROPERTY(orbit_velocity_min, double);
    PROPERTY(orbit_velocity_max, double);
    PROPERTY(orbit_velocity_curve, Object);
    PROPERTY(linear_accel_min, double);
    PROPERTY(linear_accel_max, double);
    PROPERTY(linear_accel_curve, Object);
    PROPERTY(radial_accel_min, double);
    PROPERTY(radial_accel_max, double);
    PROPERTY(radial_accel_curve, Object);
    PROPERTY(tangential_accel_min, double);
    PROPERTY(tangential_accel_max, double);
    PROPERTY(tangential_accel_curve, Object);
    PROPERTY(damping_min, double);
    PROPERTY(damping_max, double);
    PROPERTY(damping_curve, Object);
    PROPERTY(angle_min, double);
    PROPERTY(angle_max, double);
    PROPERTY(angle_curve, Object);
    PROPERTY(scale_amount_min, double);
    PROPERTY(scale_amount_max, double);
    PROPERTY(scale_amount_curve, Object);
    PROPERTY(split_scale, bool);
    PROPERTY(scale_curve_x, Object);
    PROPERTY(scale_curve_y, Object);
    PROPERTY(scale_curve_z, Object);
    PROPERTY(color, Color);
    PROPERTY(color_ramp, Object);
    PROPERTY(color_initial_ramp, Object);
    PROPERTY(hue_variation_min, double);
    PROPERTY(hue_variation_max, double);
    PROPERTY(hue_variation_curve, Object);
    PROPERTY(anim_speed_min, double);
    PROPERTY(anim_speed_max, double);
    PROPERTY(anim_speed_curve, Object);
    PROPERTY(anim_offset_min, double);
    PROPERTY(anim_offset_max, double);
    PROPERTY(anim_offset_curve, Object);
    METHOD(void, set_emitting);
    METHOD(void, set_amount);
    METHOD(void, set_lifetime);
    METHOD(void, set_one_shot);
    METHOD(void, set_pre_process_time);
    METHOD(void, set_explosiveness_ratio);
    METHOD(void, set_randomness_ratio);
    METHOD(void, set_visibility_aabb);
    METHOD(void, set_lifetime_randomness);
    METHOD(void, set_use_local_coordinates);
    METHOD(void, set_fixed_fps);
    METHOD(void, set_fractional_delta);
    METHOD(void, set_speed_scale);
    METHOD(bool, is_emitting);
    METHOD(int64_t, get_amount);
    METHOD(double, get_lifetime);
    METHOD(bool, get_one_shot);
    METHOD(double, get_pre_process_time);
    METHOD(double, get_explosiveness_ratio);
    METHOD(double, get_randomness_ratio);
    METHOD(Variant, get_visibility_aabb);
    METHOD(double, get_lifetime_randomness);
    METHOD(bool, get_use_local_coordinates);
    METHOD(int64_t, get_fixed_fps);
    METHOD(bool, get_fractional_delta);
    METHOD(double, get_speed_scale);
    METHOD(void, set_draw_order);
    METHOD(int64_t, get_draw_order);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(Variant, restart);
    METHOD(void, set_direction);
    METHOD(Vector3, get_direction);
    METHOD(void, set_spread);
    METHOD(double, get_spread);
    METHOD(void, set_flatness);
    METHOD(double, get_flatness);
    METHOD(void, set_param_min);
    METHOD(double, get_param_min);
    METHOD(void, set_param_max);
    METHOD(double, get_param_max);
    METHOD(void, set_param_curve);
    METHOD(Object, get_param_curve);
    METHOD(void, set_color);
    METHOD(Color, get_color);
    METHOD(void, set_color_ramp);
    METHOD(Object, get_color_ramp);
    METHOD(void, set_color_initial_ramp);
    METHOD(Object, get_color_initial_ramp);
    METHOD(void, set_particle_flag);
    METHOD(bool, get_particle_flag);
    METHOD(void, set_emission_shape);
    METHOD(int64_t, get_emission_shape);
    METHOD(void, set_emission_sphere_radius);
    METHOD(double, get_emission_sphere_radius);
    METHOD(void, set_emission_box_extents);
    METHOD(Vector3, get_emission_box_extents);
    METHOD(void, set_emission_points);
    METHOD(PackedArray<Vector3>, get_emission_points);
    METHOD(void, set_emission_normals);
    METHOD(PackedArray<Vector3>, get_emission_normals);
    METHOD(void, set_emission_colors);
    METHOD(PackedArray<Color>, get_emission_colors);
    METHOD(void, set_emission_ring_axis);
    METHOD(Vector3, get_emission_ring_axis);
    METHOD(void, set_emission_ring_height);
    METHOD(double, get_emission_ring_height);
    METHOD(void, set_emission_ring_radius);
    METHOD(double, get_emission_ring_radius);
    METHOD(void, set_emission_ring_inner_radius);
    METHOD(double, get_emission_ring_inner_radius);
    METHOD(Vector3, get_gravity);
    METHOD(void, set_gravity);
    METHOD(bool, get_split_scale);
    METHOD(void, set_split_scale);
    METHOD(Object, get_scale_curve_x);
    METHOD(void, set_scale_curve_x);
    METHOD(Object, get_scale_curve_y);
    METHOD(void, set_scale_curve_y);
    METHOD(Object, get_scale_curve_z);
    METHOD(void, set_scale_curve_z);
    METHOD(Variant, convert_from_particles);
    static constexpr int64_t DRAW_ORDER_INDEX = 0;
    static constexpr int64_t DRAW_ORDER_LIFETIME = 1;
    static constexpr int64_t DRAW_ORDER_VIEW_DEPTH = 2;
    static constexpr int64_t PARAM_INITIAL_LINEAR_VELOCITY = 0;
    static constexpr int64_t PARAM_ANGULAR_VELOCITY = 1;
    static constexpr int64_t PARAM_ORBIT_VELOCITY = 2;
    static constexpr int64_t PARAM_LINEAR_ACCEL = 3;
    static constexpr int64_t PARAM_RADIAL_ACCEL = 4;
    static constexpr int64_t PARAM_TANGENTIAL_ACCEL = 5;
    static constexpr int64_t PARAM_DAMPING = 6;
    static constexpr int64_t PARAM_ANGLE = 7;
    static constexpr int64_t PARAM_SCALE = 8;
    static constexpr int64_t PARAM_HUE_VARIATION = 9;
    static constexpr int64_t PARAM_ANIM_SPEED = 10;
    static constexpr int64_t PARAM_ANIM_OFFSET = 11;
    static constexpr int64_t PARAM_MAX = 12;
    static constexpr int64_t PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY = 0;
    static constexpr int64_t PARTICLE_FLAG_ROTATE_Y = 1;
    static constexpr int64_t PARTICLE_FLAG_DISABLE_Z = 2;
    static constexpr int64_t PARTICLE_FLAG_MAX = 3;
    static constexpr int64_t EMISSION_SHAPE_POINT = 0;
    static constexpr int64_t EMISSION_SHAPE_SPHERE = 1;
    static constexpr int64_t EMISSION_SHAPE_SPHERE_SURFACE = 2;
    static constexpr int64_t EMISSION_SHAPE_BOX = 3;
    static constexpr int64_t EMISSION_SHAPE_POINTS = 4;
    static constexpr int64_t EMISSION_SHAPE_DIRECTED_POINTS = 5;
    static constexpr int64_t EMISSION_SHAPE_RING = 6;
    static constexpr int64_t EMISSION_SHAPE_MAX = 7;
};
struct CSGShape3D : public GeometryInstance3D {
    using GeometryInstance3D::GeometryInstance3D;
    PROPERTY(operation, int64_t);
    PROPERTY(snap, double);
    PROPERTY(calculate_tangents, bool);
    PROPERTY(use_collision, bool);
    PROPERTY(collision_layer, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(collision_priority, double);
    METHOD(Variant, _update_shape);
    METHOD(bool, is_root_shape);
    METHOD(void, set_operation);
    METHOD(int64_t, get_operation);
    METHOD(void, set_snap);
    METHOD(double, get_snap);
    METHOD(void, set_use_collision);
    METHOD(bool, is_using_collision);
    METHOD(void, set_collision_layer);
    METHOD(int64_t, get_collision_layer);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_collision_layer_value);
    METHOD(bool, get_collision_layer_value);
    METHOD(void, set_collision_priority);
    METHOD(double, get_collision_priority);
    METHOD(void, set_calculate_tangents);
    METHOD(bool, is_calculating_tangents);
    METHOD(Array, get_meshes);
    static constexpr int64_t OPERATION_UNION = 0;
    static constexpr int64_t OPERATION_INTERSECTION = 1;
    static constexpr int64_t OPERATION_SUBTRACTION = 2;
};
struct GPUParticles3D : public GeometryInstance3D {
    using GeometryInstance3D::GeometryInstance3D;
    PROPERTY(emitting, bool);
    PROPERTY(amount, int64_t);
    PROPERTY(amount_ratio, double);
    PROPERTY(sub_emitter, String);
    PROPERTY(lifetime, double);
    PROPERTY(interp_to_end, double);
    PROPERTY(one_shot, bool);
    PROPERTY(preprocess, double);
    PROPERTY(speed_scale, double);
    PROPERTY(explosiveness, double);
    PROPERTY(randomness, double);
    PROPERTY(fixed_fps, int64_t);
    PROPERTY(interpolate, bool);
    PROPERTY(fract_delta, bool);
    PROPERTY(collision_base_size, double);
    PROPERTY(visibility_aabb, Variant);
    PROPERTY(local_coords, bool);
    PROPERTY(draw_order, int64_t);
    PROPERTY(transform_align, int64_t);
    PROPERTY(trail_enabled, bool);
    PROPERTY(trail_lifetime, double);
    PROPERTY(process_material, Object);
    PROPERTY(draw_passes, int64_t);
    PROPERTY(draw_pass_1, Object);
    PROPERTY(draw_pass_2, Object);
    PROPERTY(draw_pass_3, Object);
    PROPERTY(draw_pass_4, Object);
    PROPERTY(draw_skin, Object);
    METHOD(void, set_emitting);
    METHOD(void, set_amount);
    METHOD(void, set_lifetime);
    METHOD(void, set_one_shot);
    METHOD(void, set_pre_process_time);
    METHOD(void, set_explosiveness_ratio);
    METHOD(void, set_randomness_ratio);
    METHOD(void, set_visibility_aabb);
    METHOD(void, set_use_local_coordinates);
    METHOD(void, set_fixed_fps);
    METHOD(void, set_fractional_delta);
    METHOD(void, set_interpolate);
    METHOD(void, set_process_material);
    METHOD(void, set_speed_scale);
    METHOD(void, set_collision_base_size);
    METHOD(void, set_interp_to_end);
    METHOD(bool, is_emitting);
    METHOD(int64_t, get_amount);
    METHOD(double, get_lifetime);
    METHOD(bool, get_one_shot);
    METHOD(double, get_pre_process_time);
    METHOD(double, get_explosiveness_ratio);
    METHOD(double, get_randomness_ratio);
    METHOD(Variant, get_visibility_aabb);
    METHOD(bool, get_use_local_coordinates);
    METHOD(int64_t, get_fixed_fps);
    METHOD(bool, get_fractional_delta);
    METHOD(bool, get_interpolate);
    METHOD(Object, get_process_material);
    METHOD(double, get_speed_scale);
    METHOD(double, get_collision_base_size);
    METHOD(double, get_interp_to_end);
    METHOD(void, set_draw_order);
    METHOD(int64_t, get_draw_order);
    METHOD(void, set_draw_passes);
    METHOD(void, set_draw_pass_mesh);
    METHOD(int64_t, get_draw_passes);
    METHOD(Object, get_draw_pass_mesh);
    METHOD(void, set_skin);
    METHOD(Object, get_skin);
    METHOD(Variant, restart);
    METHOD(Variant, capture_aabb);
    METHOD(void, set_sub_emitter);
    METHOD(String, get_sub_emitter);
    METHOD(Variant, emit_particle);
    METHOD(void, set_trail_enabled);
    METHOD(void, set_trail_lifetime);
    METHOD(bool, is_trail_enabled);
    METHOD(double, get_trail_lifetime);
    METHOD(void, set_transform_align);
    METHOD(int64_t, get_transform_align);
    METHOD(Variant, convert_from_particles);
    METHOD(void, set_amount_ratio);
    METHOD(double, get_amount_ratio);
    static constexpr int64_t DRAW_ORDER_INDEX = 0;
    static constexpr int64_t DRAW_ORDER_LIFETIME = 1;
    static constexpr int64_t DRAW_ORDER_REVERSE_LIFETIME = 2;
    static constexpr int64_t DRAW_ORDER_VIEW_DEPTH = 3;
    static constexpr int64_t EMIT_FLAG_POSITION = 1;
    static constexpr int64_t EMIT_FLAG_ROTATION_SCALE = 2;
    static constexpr int64_t EMIT_FLAG_VELOCITY = 4;
    static constexpr int64_t EMIT_FLAG_COLOR = 8;
    static constexpr int64_t EMIT_FLAG_CUSTOM = 16;
    static constexpr int64_t MAX_DRAW_PASSES = 4;
    static constexpr int64_t TRANSFORM_ALIGN_DISABLED = 0;
    static constexpr int64_t TRANSFORM_ALIGN_Z_BILLBOARD = 1;
    static constexpr int64_t TRANSFORM_ALIGN_Y_TO_VELOCITY = 2;
    static constexpr int64_t TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY = 3;
};
struct Label3D : public GeometryInstance3D {
    using GeometryInstance3D::GeometryInstance3D;
    PROPERTY(pixel_size, double);
    PROPERTY(offset, Vector2);
    PROPERTY(billboard, int64_t);
    PROPERTY(shaded, bool);
    PROPERTY(double_sided, bool);
    PROPERTY(no_depth_test, bool);
    PROPERTY(fixed_size, bool);
    PROPERTY(alpha_cut, int64_t);
    PROPERTY(alpha_scissor_threshold, double);
    PROPERTY(alpha_hash_scale, double);
    PROPERTY(alpha_antialiasing_mode, int64_t);
    PROPERTY(alpha_antialiasing_edge, double);
    PROPERTY(texture_filter, int64_t);
    PROPERTY(render_priority, int64_t);
    PROPERTY(outline_render_priority, int64_t);
    PROPERTY(modulate, Color);
    PROPERTY(outline_modulate, Color);
    PROPERTY(text, String);
    PROPERTY(font, Object);
    PROPERTY(font_size, int64_t);
    PROPERTY(outline_size, int64_t);
    PROPERTY(horizontal_alignment, int64_t);
    PROPERTY(vertical_alignment, int64_t);
    PROPERTY(uppercase, bool);
    PROPERTY(line_spacing, double);
    PROPERTY(autowrap_mode, int64_t);
    PROPERTY(justification_flags, int64_t);
    PROPERTY(width, double);
    PROPERTY(text_direction, int64_t);
    PROPERTY(language, String);
    PROPERTY(structured_text_bidi_override, int64_t);
    PROPERTY(structured_text_bidi_override_options, Array);
    METHOD(void, set_horizontal_alignment);
    METHOD(int64_t, get_horizontal_alignment);
    METHOD(void, set_vertical_alignment);
    METHOD(int64_t, get_vertical_alignment);
    METHOD(void, set_modulate);
    METHOD(Color, get_modulate);
    METHOD(void, set_outline_modulate);
    METHOD(Color, get_outline_modulate);
    METHOD(void, set_text);
    METHOD(String, get_text);
    METHOD(void, set_text_direction);
    METHOD(int64_t, get_text_direction);
    METHOD(void, set_language);
    METHOD(String, get_language);
    METHOD(void, set_structured_text_bidi_override);
    METHOD(int64_t, get_structured_text_bidi_override);
    METHOD(void, set_structured_text_bidi_override_options);
    METHOD(Array, get_structured_text_bidi_override_options);
    METHOD(void, set_uppercase);
    METHOD(bool, is_uppercase);
    METHOD(void, set_render_priority);
    METHOD(int64_t, get_render_priority);
    METHOD(void, set_outline_render_priority);
    METHOD(int64_t, get_outline_render_priority);
    METHOD(void, set_font);
    METHOD(Object, get_font);
    METHOD(void, set_font_size);
    METHOD(int64_t, get_font_size);
    METHOD(void, set_outline_size);
    METHOD(int64_t, get_outline_size);
    METHOD(void, set_line_spacing);
    METHOD(double, get_line_spacing);
    METHOD(void, set_autowrap_mode);
    METHOD(int64_t, get_autowrap_mode);
    METHOD(void, set_justification_flags);
    METHOD(int64_t, get_justification_flags);
    METHOD(void, set_width);
    METHOD(double, get_width);
    METHOD(void, set_pixel_size);
    METHOD(double, get_pixel_size);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_draw_flag);
    METHOD(bool, get_draw_flag);
    METHOD(void, set_billboard_mode);
    METHOD(int64_t, get_billboard_mode);
    METHOD(void, set_alpha_cut_mode);
    METHOD(int64_t, get_alpha_cut_mode);
    METHOD(void, set_alpha_scissor_threshold);
    METHOD(double, get_alpha_scissor_threshold);
    METHOD(void, set_alpha_hash_scale);
    METHOD(double, get_alpha_hash_scale);
    METHOD(void, set_alpha_antialiasing);
    METHOD(int64_t, get_alpha_antialiasing);
    METHOD(void, set_alpha_antialiasing_edge);
    METHOD(double, get_alpha_antialiasing_edge);
    METHOD(void, set_texture_filter);
    METHOD(int64_t, get_texture_filter);
    METHOD(Object, generate_triangle_mesh);
    static constexpr int64_t FLAG_SHADED = 0;
    static constexpr int64_t FLAG_DOUBLE_SIDED = 1;
    static constexpr int64_t FLAG_DISABLE_DEPTH_TEST = 2;
    static constexpr int64_t FLAG_FIXED_SIZE = 3;
    static constexpr int64_t FLAG_MAX = 4;
    static constexpr int64_t ALPHA_CUT_DISABLED = 0;
    static constexpr int64_t ALPHA_CUT_DISCARD = 1;
    static constexpr int64_t ALPHA_CUT_OPAQUE_PREPASS = 2;
    static constexpr int64_t ALPHA_CUT_HASH = 3;
};
struct MeshInstance3D : public GeometryInstance3D {
    using GeometryInstance3D::GeometryInstance3D;
    PROPERTY(mesh, Object);
    PROPERTY(skin, Object);
    PROPERTY(skeleton, String);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(void, set_skeleton_path);
    METHOD(String, get_skeleton_path);
    METHOD(void, set_skin);
    METHOD(Object, get_skin);
    METHOD(Object, get_skin_reference);
    METHOD(int64_t, get_surface_override_material_count);
    METHOD(void, set_surface_override_material);
    METHOD(Object, get_surface_override_material);
    METHOD(Object, get_active_material);
    METHOD(Variant, create_trimesh_collision);
    METHOD(Variant, create_convex_collision);
    METHOD(Variant, create_multiple_convex_collisions);
    METHOD(int64_t, get_blend_shape_count);
    METHOD(int64_t, find_blend_shape_by_name);
    METHOD(double, get_blend_shape_value);
    METHOD(void, set_blend_shape_value);
    METHOD(Variant, create_debug_tangents);
    METHOD(Object, bake_mesh_from_current_blend_shape_mix);
};
struct MultiMeshInstance3D : public GeometryInstance3D {
    using GeometryInstance3D::GeometryInstance3D;
    PROPERTY(multimesh, Object);
    METHOD(void, set_multimesh);
    METHOD(Object, get_multimesh);
};
struct SpriteBase3D : public GeometryInstance3D {
    using GeometryInstance3D::GeometryInstance3D;
    PROPERTY(centered, bool);
    PROPERTY(offset, Vector2);
    PROPERTY(flip_h, bool);
    PROPERTY(flip_v, bool);
    PROPERTY(modulate, Color);
    PROPERTY(pixel_size, double);
    PROPERTY(axis, int64_t);
    PROPERTY(billboard, int64_t);
    PROPERTY(transparent, bool);
    PROPERTY(shaded, bool);
    PROPERTY(double_sided, bool);
    PROPERTY(no_depth_test, bool);
    PROPERTY(fixed_size, bool);
    PROPERTY(alpha_cut, int64_t);
    PROPERTY(alpha_scissor_threshold, double);
    PROPERTY(alpha_hash_scale, double);
    PROPERTY(alpha_antialiasing_mode, int64_t);
    PROPERTY(alpha_antialiasing_edge, double);
    PROPERTY(texture_filter, int64_t);
    PROPERTY(render_priority, int64_t);
    METHOD(void, set_centered);
    METHOD(bool, is_centered);
    METHOD(void, set_offset);
    METHOD(Vector2, get_offset);
    METHOD(void, set_flip_h);
    METHOD(bool, is_flipped_h);
    METHOD(void, set_flip_v);
    METHOD(bool, is_flipped_v);
    METHOD(void, set_modulate);
    METHOD(Color, get_modulate);
    METHOD(void, set_render_priority);
    METHOD(int64_t, get_render_priority);
    METHOD(void, set_pixel_size);
    METHOD(double, get_pixel_size);
    METHOD(void, set_axis);
    METHOD(int64_t, get_axis);
    METHOD(void, set_draw_flag);
    METHOD(bool, get_draw_flag);
    METHOD(void, set_alpha_cut_mode);
    METHOD(int64_t, get_alpha_cut_mode);
    METHOD(void, set_alpha_scissor_threshold);
    METHOD(double, get_alpha_scissor_threshold);
    METHOD(void, set_alpha_hash_scale);
    METHOD(double, get_alpha_hash_scale);
    METHOD(void, set_alpha_antialiasing);
    METHOD(int64_t, get_alpha_antialiasing);
    METHOD(void, set_alpha_antialiasing_edge);
    METHOD(double, get_alpha_antialiasing_edge);
    METHOD(void, set_billboard_mode);
    METHOD(int64_t, get_billboard_mode);
    METHOD(void, set_texture_filter);
    METHOD(int64_t, get_texture_filter);
    METHOD(Rect2, get_item_rect);
    METHOD(Object, generate_triangle_mesh);
    static constexpr int64_t FLAG_TRANSPARENT = 0;
    static constexpr int64_t FLAG_SHADED = 1;
    static constexpr int64_t FLAG_DOUBLE_SIDED = 2;
    static constexpr int64_t FLAG_DISABLE_DEPTH_TEST = 3;
    static constexpr int64_t FLAG_FIXED_SIZE = 4;
    static constexpr int64_t FLAG_MAX = 5;
    static constexpr int64_t ALPHA_CUT_DISABLED = 0;
    static constexpr int64_t ALPHA_CUT_DISCARD = 1;
    static constexpr int64_t ALPHA_CUT_OPAQUE_PREPASS = 2;
    static constexpr int64_t ALPHA_CUT_HASH = 3;
};
struct AnimatedSprite3D : public SpriteBase3D {
    using SpriteBase3D::SpriteBase3D;
    PROPERTY(sprite_frames, Object);
    PROPERTY(animation, String);
    PROPERTY(autoplay, String);
    PROPERTY(frame, int64_t);
    PROPERTY(frame_progress, double);
    PROPERTY(speed_scale, double);
    METHOD(void, set_sprite_frames);
    METHOD(Object, get_sprite_frames);
    METHOD(void, set_animation);
    METHOD(String, get_animation);
    METHOD(void, set_autoplay);
    METHOD(String, get_autoplay);
    METHOD(bool, is_playing);
    METHOD(Variant, play);
    METHOD(Variant, play_backwards);
    METHOD(Variant, pause);
    METHOD(Variant, stop);
    METHOD(void, set_frame);
    METHOD(int64_t, get_frame);
    METHOD(void, set_frame_progress);
    METHOD(double, get_frame_progress);
    METHOD(void, set_frame_and_progress);
    METHOD(void, set_speed_scale);
    METHOD(double, get_speed_scale);
    METHOD(double, get_playing_speed);
    METHOD(Variant, _res_changed);
};
struct Sprite3D : public SpriteBase3D {
    using SpriteBase3D::SpriteBase3D;
    PROPERTY(texture, Object);
    PROPERTY(hframes, int64_t);
    PROPERTY(vframes, int64_t);
    PROPERTY(frame, int64_t);
    PROPERTY(frame_coords, Vector2i);
    PROPERTY(region_enabled, bool);
    PROPERTY(region_rect, Rect2);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_region_enabled);
    METHOD(bool, is_region_enabled);
    METHOD(void, set_region_rect);
    METHOD(Rect2, get_region_rect);
    METHOD(void, set_frame);
    METHOD(int64_t, get_frame);
    METHOD(void, set_frame_coords);
    METHOD(Vector2i, get_frame_coords);
    METHOD(void, set_vframes);
    METHOD(int64_t, get_vframes);
    METHOD(void, set_hframes);
    METHOD(int64_t, get_hframes);
};
struct CSGCombiner3D : public CSGShape3D {
    using CSGShape3D::CSGShape3D;
};
struct CSGPrimitive3D : public CSGShape3D {
    using CSGShape3D::CSGShape3D;
    PROPERTY(flip_faces, bool);
    METHOD(void, set_flip_faces);
    METHOD(bool, get_flip_faces);
};
struct CSGBox3D : public CSGPrimitive3D {
    using CSGPrimitive3D::CSGPrimitive3D;
    PROPERTY(size, Vector3);
    PROPERTY(material, Object);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_material);
    METHOD(Object, get_material);
};
struct CSGCylinder3D : public CSGPrimitive3D {
    using CSGPrimitive3D::CSGPrimitive3D;
    PROPERTY(radius, double);
    PROPERTY(height, double);
    PROPERTY(sides, int64_t);
    PROPERTY(cone, bool);
    PROPERTY(smooth_faces, bool);
    PROPERTY(material, Object);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_height);
    METHOD(double, get_height);
    METHOD(void, set_sides);
    METHOD(int64_t, get_sides);
    METHOD(void, set_cone);
    METHOD(bool, is_cone);
    METHOD(void, set_material);
    METHOD(Object, get_material);
    METHOD(void, set_smooth_faces);
    METHOD(bool, get_smooth_faces);
};
struct CSGMesh3D : public CSGPrimitive3D {
    using CSGPrimitive3D::CSGPrimitive3D;
    PROPERTY(mesh, Object);
    PROPERTY(material, Object);
    METHOD(void, set_mesh);
    METHOD(Object, get_mesh);
    METHOD(void, set_material);
    METHOD(Object, get_material);
};
struct CSGPolygon3D : public CSGPrimitive3D {
    using CSGPrimitive3D::CSGPrimitive3D;
    PROPERTY(polygon, PackedArray<Vector2>);
    PROPERTY(mode, int64_t);
    PROPERTY(depth, double);
    PROPERTY(spin_degrees, double);
    PROPERTY(spin_sides, int64_t);
    PROPERTY(path_node, String);
    PROPERTY(path_interval_type, int64_t);
    PROPERTY(path_interval, double);
    PROPERTY(path_simplify_angle, double);
    PROPERTY(path_rotation, int64_t);
    PROPERTY(path_local, bool);
    PROPERTY(path_continuous_u, bool);
    PROPERTY(path_u_distance, double);
    PROPERTY(path_joined, bool);
    PROPERTY(smooth_faces, bool);
    PROPERTY(material, Object);
    METHOD(void, set_polygon);
    METHOD(PackedArray<Vector2>, get_polygon);
    METHOD(void, set_mode);
    METHOD(int64_t, get_mode);
    METHOD(void, set_depth);
    METHOD(double, get_depth);
    METHOD(void, set_spin_degrees);
    METHOD(double, get_spin_degrees);
    METHOD(void, set_spin_sides);
    METHOD(int64_t, get_spin_sides);
    METHOD(void, set_path_node);
    METHOD(String, get_path_node);
    METHOD(void, set_path_interval_type);
    METHOD(int64_t, get_path_interval_type);
    METHOD(void, set_path_interval);
    METHOD(double, get_path_interval);
    METHOD(void, set_path_simplify_angle);
    METHOD(double, get_path_simplify_angle);
    METHOD(void, set_path_rotation);
    METHOD(int64_t, get_path_rotation);
    METHOD(void, set_path_local);
    METHOD(bool, is_path_local);
    METHOD(void, set_path_continuous_u);
    METHOD(bool, is_path_continuous_u);
    METHOD(void, set_path_u_distance);
    METHOD(double, get_path_u_distance);
    METHOD(void, set_path_joined);
    METHOD(bool, is_path_joined);
    METHOD(void, set_material);
    METHOD(Object, get_material);
    METHOD(void, set_smooth_faces);
    METHOD(bool, get_smooth_faces);
    METHOD(bool, _is_editable_3d_polygon);
    METHOD(bool, _has_editable_3d_polygon_no_depth);
    static constexpr int64_t MODE_DEPTH = 0;
    static constexpr int64_t MODE_SPIN = 1;
    static constexpr int64_t MODE_PATH = 2;
    static constexpr int64_t PATH_ROTATION_POLYGON = 0;
    static constexpr int64_t PATH_ROTATION_PATH = 1;
    static constexpr int64_t PATH_ROTATION_PATH_FOLLOW = 2;
    static constexpr int64_t PATH_INTERVAL_DISTANCE = 0;
    static constexpr int64_t PATH_INTERVAL_SUBDIVIDE = 1;
};
struct CSGSphere3D : public CSGPrimitive3D {
    using CSGPrimitive3D::CSGPrimitive3D;
    PROPERTY(radius, double);
    PROPERTY(radial_segments, int64_t);
    PROPERTY(rings, int64_t);
    PROPERTY(smooth_faces, bool);
    PROPERTY(material, Object);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
    METHOD(void, set_radial_segments);
    METHOD(int64_t, get_radial_segments);
    METHOD(void, set_rings);
    METHOD(int64_t, get_rings);
    METHOD(void, set_smooth_faces);
    METHOD(bool, get_smooth_faces);
    METHOD(void, set_material);
    METHOD(Object, get_material);
};
struct CSGTorus3D : public CSGPrimitive3D {
    using CSGPrimitive3D::CSGPrimitive3D;
    PROPERTY(inner_radius, double);
    PROPERTY(outer_radius, double);
    PROPERTY(sides, int64_t);
    PROPERTY(ring_sides, int64_t);
    PROPERTY(smooth_faces, bool);
    PROPERTY(material, Object);
    METHOD(void, set_inner_radius);
    METHOD(double, get_inner_radius);
    METHOD(void, set_outer_radius);
    METHOD(double, get_outer_radius);
    METHOD(void, set_sides);
    METHOD(int64_t, get_sides);
    METHOD(void, set_ring_sides);
    METHOD(int64_t, get_ring_sides);
    METHOD(void, set_material);
    METHOD(Object, get_material);
    METHOD(void, set_smooth_faces);
    METHOD(bool, get_smooth_faces);
};
struct DirectionalLight2D : public Light2D {
    using Light2D::Light2D;
    PROPERTY(height, double);
    PROPERTY(max_distance, double);
    METHOD(void, set_max_distance);
    METHOD(double, get_max_distance);
};
struct DirectionalLight3D : public Light3D {
    using Light3D::Light3D;
    PROPERTY(directional_shadow_mode, int64_t);
    PROPERTY(directional_shadow_split_1, double);
    PROPERTY(directional_shadow_split_2, double);
    PROPERTY(directional_shadow_split_3, double);
    PROPERTY(directional_shadow_blend_splits, bool);
    PROPERTY(directional_shadow_fade_start, double);
    PROPERTY(directional_shadow_max_distance, double);
    PROPERTY(directional_shadow_pancake_size, double);
    PROPERTY(sky_mode, int64_t);
    METHOD(void, set_shadow_mode);
    METHOD(int64_t, get_shadow_mode);
    METHOD(void, set_blend_splits);
    METHOD(bool, is_blend_splits_enabled);
    METHOD(void, set_sky_mode);
    METHOD(int64_t, get_sky_mode);
    static constexpr int64_t SHADOW_ORTHOGONAL = 0;
    static constexpr int64_t SHADOW_PARALLEL_2_SPLITS = 1;
    static constexpr int64_t SHADOW_PARALLEL_4_SPLITS = 2;
    static constexpr int64_t SKY_MODE_LIGHT_AND_SKY = 0;
    static constexpr int64_t SKY_MODE_LIGHT_ONLY = 1;
    static constexpr int64_t SKY_MODE_SKY_ONLY = 2;
};
struct OmniLight3D : public Light3D {
    using Light3D::Light3D;
    PROPERTY(omni_range, double);
    PROPERTY(omni_attenuation, double);
    PROPERTY(omni_shadow_mode, int64_t);
    METHOD(void, set_shadow_mode);
    METHOD(int64_t, get_shadow_mode);
    static constexpr int64_t SHADOW_DUAL_PARABOLOID = 0;
    static constexpr int64_t SHADOW_CUBE = 1;
};
struct SpotLight3D : public Light3D {
    using Light3D::Light3D;
    PROPERTY(spot_range, double);
    PROPERTY(spot_attenuation, double);
    PROPERTY(spot_angle, double);
    PROPERTY(spot_angle_attenuation, double);
};
struct DockSplitContainer : public SplitContainer {
    using SplitContainer::SplitContainer;
};
struct HSplitContainer : public SplitContainer {
    using SplitContainer::SplitContainer;
};
struct VSplitContainer : public SplitContainer {
    using SplitContainer::SplitContainer;
};
struct EventListenerLineEdit : public LineEdit {
    using LineEdit::LineEdit;
};
struct FBXDocument : public GLTFDocument {
    using GLTFDocument::GLTFDocument;
};
struct FBXState : public GLTFState {
    using GLTFState::GLTFState;
    PROPERTY(allow_geometry_helper_nodes, bool);
    METHOD(bool, get_allow_geometry_helper_nodes);
    METHOD(void, set_allow_geometry_helper_nodes);
};
struct FastNoiseLite : public Noise {
    using Noise::Noise;
    PROPERTY(noise_type, int64_t);
    PROPERTY(seed, int64_t);
    PROPERTY(frequency, double);
    PROPERTY(offset, Vector3);
    PROPERTY(fractal_type, int64_t);
    PROPERTY(fractal_octaves, int64_t);
    PROPERTY(fractal_lacunarity, double);
    PROPERTY(fractal_gain, double);
    PROPERTY(fractal_weighted_strength, double);
    PROPERTY(fractal_ping_pong_strength, double);
    PROPERTY(cellular_distance_function, int64_t);
    PROPERTY(cellular_jitter, double);
    PROPERTY(cellular_return_type, int64_t);
    PROPERTY(domain_warp_enabled, bool);
    PROPERTY(domain_warp_type, int64_t);
    PROPERTY(domain_warp_amplitude, double);
    PROPERTY(domain_warp_frequency, double);
    PROPERTY(domain_warp_fractal_type, int64_t);
    PROPERTY(domain_warp_fractal_octaves, int64_t);
    PROPERTY(domain_warp_fractal_lacunarity, double);
    PROPERTY(domain_warp_fractal_gain, double);
    METHOD(void, set_noise_type);
    METHOD(int64_t, get_noise_type);
    METHOD(void, set_seed);
    METHOD(int64_t, get_seed);
    METHOD(void, set_frequency);
    METHOD(double, get_frequency);
    METHOD(void, set_offset);
    METHOD(Vector3, get_offset);
    METHOD(void, set_fractal_type);
    METHOD(int64_t, get_fractal_type);
    METHOD(void, set_fractal_octaves);
    METHOD(int64_t, get_fractal_octaves);
    METHOD(void, set_fractal_lacunarity);
    METHOD(double, get_fractal_lacunarity);
    METHOD(void, set_fractal_gain);
    METHOD(double, get_fractal_gain);
    METHOD(void, set_fractal_weighted_strength);
    METHOD(double, get_fractal_weighted_strength);
    METHOD(void, set_fractal_ping_pong_strength);
    METHOD(double, get_fractal_ping_pong_strength);
    METHOD(void, set_cellular_distance_function);
    METHOD(int64_t, get_cellular_distance_function);
    METHOD(void, set_cellular_jitter);
    METHOD(double, get_cellular_jitter);
    METHOD(void, set_cellular_return_type);
    METHOD(int64_t, get_cellular_return_type);
    METHOD(void, set_domain_warp_enabled);
    METHOD(bool, is_domain_warp_enabled);
    METHOD(void, set_domain_warp_type);
    METHOD(int64_t, get_domain_warp_type);
    METHOD(void, set_domain_warp_amplitude);
    METHOD(double, get_domain_warp_amplitude);
    METHOD(void, set_domain_warp_frequency);
    METHOD(double, get_domain_warp_frequency);
    METHOD(void, set_domain_warp_fractal_type);
    METHOD(int64_t, get_domain_warp_fractal_type);
    METHOD(void, set_domain_warp_fractal_octaves);
    METHOD(int64_t, get_domain_warp_fractal_octaves);
    METHOD(void, set_domain_warp_fractal_lacunarity);
    METHOD(double, get_domain_warp_fractal_lacunarity);
    METHOD(void, set_domain_warp_fractal_gain);
    METHOD(double, get_domain_warp_fractal_gain);
    METHOD(Variant, _changed);
    static constexpr int64_t TYPE_VALUE = 5;
    static constexpr int64_t TYPE_VALUE_CUBIC = 4;
    static constexpr int64_t TYPE_PERLIN = 3;
    static constexpr int64_t TYPE_CELLULAR = 2;
    static constexpr int64_t TYPE_SIMPLEX = 0;
    static constexpr int64_t TYPE_SIMPLEX_SMOOTH = 1;
    static constexpr int64_t FRACTAL_NONE = 0;
    static constexpr int64_t FRACTAL_FBM = 1;
    static constexpr int64_t FRACTAL_RIDGED = 2;
    static constexpr int64_t FRACTAL_PING_PONG = 3;
    static constexpr int64_t DISTANCE_EUCLIDEAN = 0;
    static constexpr int64_t DISTANCE_EUCLIDEAN_SQUARED = 1;
    static constexpr int64_t DISTANCE_MANHATTAN = 2;
    static constexpr int64_t DISTANCE_HYBRID = 3;
    static constexpr int64_t RETURN_CELL_VALUE = 0;
    static constexpr int64_t RETURN_DISTANCE = 1;
    static constexpr int64_t RETURN_DISTANCE2 = 2;
    static constexpr int64_t RETURN_DISTANCE2_ADD = 3;
    static constexpr int64_t RETURN_DISTANCE2_SUB = 4;
    static constexpr int64_t RETURN_DISTANCE2_MUL = 5;
    static constexpr int64_t RETURN_DISTANCE2_DIV = 6;
    static constexpr int64_t DOMAIN_WARP_SIMPLEX = 0;
    static constexpr int64_t DOMAIN_WARP_SIMPLEX_REDUCED = 1;
    static constexpr int64_t DOMAIN_WARP_BASIC_GRID = 2;
    static constexpr int64_t DOMAIN_WARP_FRACTAL_NONE = 0;
    static constexpr int64_t DOMAIN_WARP_FRACTAL_PROGRESSIVE = 1;
    static constexpr int64_t DOMAIN_WARP_FRACTAL_INDEPENDENT = 2;
};
struct FileSystemList : public ItemList {
    using ItemList::ItemList;
};
struct FontFile : public Font {
    using Font::Font;
    PROPERTY(data, PackedArray<uint8_t>);
    PROPERTY(generate_mipmaps, bool);
    PROPERTY(disable_embedded_bitmaps, bool);
    PROPERTY(antialiasing, int64_t);
    PROPERTY(font_name, String);
    PROPERTY(style_name, String);
    PROPERTY(font_style, int64_t);
    PROPERTY(font_weight, int64_t);
    PROPERTY(font_stretch, int64_t);
    PROPERTY(subpixel_positioning, int64_t);
    PROPERTY(multichannel_signed_distance_field, bool);
    PROPERTY(msdf_pixel_range, int64_t);
    PROPERTY(msdf_size, int64_t);
    PROPERTY(allow_system_fallback, bool);
    PROPERTY(force_autohinter, bool);
    PROPERTY(hinting, int64_t);
    PROPERTY(oversampling, double);
    PROPERTY(fixed_size, int64_t);
    PROPERTY(fixed_size_scale_mode, int64_t);
    PROPERTY(opentype_feature_overrides, Dictionary);
    METHOD(int64_t, load_bitmap_font);
    METHOD(int64_t, load_dynamic_font);
    METHOD(void, set_data);
    METHOD(PackedArray<uint8_t>, get_data);
    METHOD(void, set_font_name);
    METHOD(void, set_font_style_name);
    METHOD(void, set_font_style);
    METHOD(void, set_font_weight);
    METHOD(void, set_font_stretch);
    METHOD(void, set_antialiasing);
    METHOD(int64_t, get_antialiasing);
    METHOD(void, set_disable_embedded_bitmaps);
    METHOD(bool, get_disable_embedded_bitmaps);
    METHOD(void, set_generate_mipmaps);
    METHOD(bool, get_generate_mipmaps);
    METHOD(void, set_multichannel_signed_distance_field);
    METHOD(bool, is_multichannel_signed_distance_field);
    METHOD(void, set_msdf_pixel_range);
    METHOD(int64_t, get_msdf_pixel_range);
    METHOD(void, set_msdf_size);
    METHOD(int64_t, get_msdf_size);
    METHOD(void, set_fixed_size);
    METHOD(int64_t, get_fixed_size);
    METHOD(void, set_fixed_size_scale_mode);
    METHOD(int64_t, get_fixed_size_scale_mode);
    METHOD(void, set_allow_system_fallback);
    METHOD(bool, is_allow_system_fallback);
    METHOD(void, set_force_autohinter);
    METHOD(bool, is_force_autohinter);
    METHOD(void, set_hinting);
    METHOD(int64_t, get_hinting);
    METHOD(void, set_subpixel_positioning);
    METHOD(int64_t, get_subpixel_positioning);
    METHOD(void, set_oversampling);
    METHOD(double, get_oversampling);
    METHOD(int64_t, get_cache_count);
    METHOD(Variant, clear_cache);
    METHOD(Variant, remove_cache);
    METHOD(Array, get_size_cache_list);
    METHOD(Variant, clear_size_cache);
    METHOD(Variant, remove_size_cache);
    METHOD(void, set_variation_coordinates);
    METHOD(Dictionary, get_variation_coordinates);
    METHOD(void, set_embolden);
    METHOD(double, get_embolden);
    METHOD(void, set_transform);
    METHOD(Transform2D, get_transform);
    METHOD(void, set_extra_spacing);
    METHOD(int64_t, get_extra_spacing);
    METHOD(void, set_extra_baseline_offset);
    METHOD(double, get_extra_baseline_offset);
    METHOD(void, set_face_index);
    METHOD(int64_t, get_face_index);
    METHOD(void, set_cache_ascent);
    METHOD(double, get_cache_ascent);
    METHOD(void, set_cache_descent);
    METHOD(double, get_cache_descent);
    METHOD(void, set_cache_underline_position);
    METHOD(double, get_cache_underline_position);
    METHOD(void, set_cache_underline_thickness);
    METHOD(double, get_cache_underline_thickness);
    METHOD(void, set_cache_scale);
    METHOD(double, get_cache_scale);
    METHOD(int64_t, get_texture_count);
    METHOD(Variant, clear_textures);
    METHOD(Variant, remove_texture);
    METHOD(void, set_texture_image);
    METHOD(Object, get_texture_image);
    METHOD(void, set_texture_offsets);
    METHOD(PackedArray<int32_t>, get_texture_offsets);
    METHOD(PackedArray<int32_t>, get_glyph_list);
    METHOD(Variant, clear_glyphs);
    METHOD(Variant, remove_glyph);
    METHOD(void, set_glyph_advance);
    METHOD(Vector2, get_glyph_advance);
    METHOD(void, set_glyph_offset);
    METHOD(Vector2, get_glyph_offset);
    METHOD(void, set_glyph_size);
    METHOD(Vector2, get_glyph_size);
    METHOD(void, set_glyph_uv_rect);
    METHOD(Rect2, get_glyph_uv_rect);
    METHOD(void, set_glyph_texture_idx);
    METHOD(int64_t, get_glyph_texture_idx);
    METHOD(Array, get_kerning_list);
    METHOD(Variant, clear_kerning_map);
    METHOD(Variant, remove_kerning);
    METHOD(void, set_kerning);
    METHOD(Vector2, get_kerning);
    METHOD(Variant, render_range);
    METHOD(Variant, render_glyph);
    METHOD(void, set_language_support_override);
    METHOD(bool, get_language_support_override);
    METHOD(Variant, remove_language_support_override);
    METHOD(PackedArray<std::string>, get_language_support_overrides);
    METHOD(void, set_script_support_override);
    METHOD(bool, get_script_support_override);
    METHOD(Variant, remove_script_support_override);
    METHOD(PackedArray<std::string>, get_script_support_overrides);
    METHOD(void, set_opentype_feature_overrides);
    METHOD(Dictionary, get_opentype_feature_overrides);
    METHOD(int64_t, get_glyph_index);
    METHOD(int64_t, get_char_from_glyph_index);
};
struct FontVariation : public Font {
    using Font::Font;
    PROPERTY(base_font, Object);
    PROPERTY(variation_opentype, Dictionary);
    PROPERTY(variation_face_index, int64_t);
    PROPERTY(variation_embolden, double);
    PROPERTY(variation_transform, Transform2D);
    PROPERTY(opentype_features, Dictionary);
    PROPERTY(spacing_glyph, int64_t);
    PROPERTY(spacing_space, int64_t);
    PROPERTY(spacing_top, int64_t);
    PROPERTY(spacing_bottom, int64_t);
    PROPERTY(baseline_offset, double);
    METHOD(void, set_base_font);
    METHOD(Object, get_base_font);
    METHOD(void, set_variation_opentype);
    METHOD(Dictionary, get_variation_opentype);
    METHOD(void, set_variation_embolden);
    METHOD(double, get_variation_embolden);
    METHOD(void, set_variation_face_index);
    METHOD(int64_t, get_variation_face_index);
    METHOD(void, set_variation_transform);
    METHOD(Transform2D, get_variation_transform);
    METHOD(void, set_opentype_features);
    METHOD(void, set_spacing);
    METHOD(void, set_baseline_offset);
    METHOD(double, get_baseline_offset);
};
struct SystemFont : public Font {
    using Font::Font;
    PROPERTY(font_names, PackedArray<std::string>);
    PROPERTY(font_italic, bool);
    PROPERTY(font_weight, int64_t);
    PROPERTY(font_stretch, int64_t);
    PROPERTY(antialiasing, int64_t);
    PROPERTY(generate_mipmaps, bool);
    PROPERTY(disable_embedded_bitmaps, bool);
    PROPERTY(allow_system_fallback, bool);
    PROPERTY(force_autohinter, bool);
    PROPERTY(hinting, int64_t);
    PROPERTY(subpixel_positioning, int64_t);
    PROPERTY(multichannel_signed_distance_field, bool);
    PROPERTY(msdf_pixel_range, int64_t);
    PROPERTY(msdf_size, int64_t);
    PROPERTY(oversampling, double);
    METHOD(void, set_antialiasing);
    METHOD(int64_t, get_antialiasing);
    METHOD(void, set_disable_embedded_bitmaps);
    METHOD(bool, get_disable_embedded_bitmaps);
    METHOD(void, set_generate_mipmaps);
    METHOD(bool, get_generate_mipmaps);
    METHOD(void, set_allow_system_fallback);
    METHOD(bool, is_allow_system_fallback);
    METHOD(void, set_force_autohinter);
    METHOD(bool, is_force_autohinter);
    METHOD(void, set_hinting);
    METHOD(int64_t, get_hinting);
    METHOD(void, set_subpixel_positioning);
    METHOD(int64_t, get_subpixel_positioning);
    METHOD(void, set_multichannel_signed_distance_field);
    METHOD(bool, is_multichannel_signed_distance_field);
    METHOD(void, set_msdf_pixel_range);
    METHOD(int64_t, get_msdf_pixel_range);
    METHOD(void, set_msdf_size);
    METHOD(int64_t, get_msdf_size);
    METHOD(void, set_oversampling);
    METHOD(double, get_oversampling);
    METHOD(PackedArray<std::string>, get_font_names);
    METHOD(void, set_font_names);
    METHOD(bool, get_font_italic);
    METHOD(void, set_font_italic);
    METHOD(void, set_font_weight);
    METHOD(void, set_font_stretch);
};
struct GDScript : public Script {
    using Script::Script;
    METHOD(Variant, New);
};
struct GDScriptLanguageProtocol : public JSONRPC {
    using JSONRPC::JSONRPC;
    METHOD(Dictionary, initialize);
    METHOD(Variant, initialized);
    METHOD(int64_t, on_client_connected);
    METHOD(Variant, on_client_disconnected);
    METHOD(Variant, notify_client);
    METHOD(bool, is_smart_resolve_enabled);
    METHOD(Object, get_text_document);
    METHOD(Object, get_workspace);
    METHOD(bool, is_initialized);
    static GDScriptLanguageProtocol get_singleton() { return GDScriptLanguageProtocol(Object("GDScriptLanguageProtocol").address()); }
};
struct GLTFDocumentExtensionConvertImporterMesh : public GLTFDocumentExtension {
    using GLTFDocumentExtension::GLTFDocumentExtension;
};
struct GLTFDocumentExtensionPhysics : public GLTFDocumentExtension {
    using GLTFDocumentExtension::GLTFDocumentExtension;
};
struct GLTFDocumentExtensionTextureKTX : public GLTFDocumentExtension {
    using GLTFDocumentExtension::GLTFDocumentExtension;
};
struct GLTFDocumentExtensionTextureWebP : public GLTFDocumentExtension {
    using GLTFDocumentExtension::GLTFDocumentExtension;
};
struct GPUParticlesAttractorBox3D : public GPUParticlesAttractor3D {
    using GPUParticlesAttractor3D::GPUParticlesAttractor3D;
    PROPERTY(size, Vector3);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
};
struct GPUParticlesAttractorSphere3D : public GPUParticlesAttractor3D {
    using GPUParticlesAttractor3D::GPUParticlesAttractor3D;
    PROPERTY(radius, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
};
struct GPUParticlesAttractorVectorField3D : public GPUParticlesAttractor3D {
    using GPUParticlesAttractor3D::GPUParticlesAttractor3D;
    PROPERTY(size, Vector3);
    PROPERTY(texture, Object);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
};
struct GPUParticlesCollisionBox3D : public GPUParticlesCollision3D {
    using GPUParticlesCollision3D::GPUParticlesCollision3D;
    PROPERTY(size, Vector3);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
};
struct GPUParticlesCollisionHeightField3D : public GPUParticlesCollision3D {
    using GPUParticlesCollision3D::GPUParticlesCollision3D;
    PROPERTY(size, Vector3);
    PROPERTY(resolution, int64_t);
    PROPERTY(update_mode, int64_t);
    PROPERTY(follow_camera_enabled, bool);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_resolution);
    METHOD(int64_t, get_resolution);
    METHOD(void, set_update_mode);
    METHOD(int64_t, get_update_mode);
    METHOD(void, set_follow_camera_enabled);
    METHOD(bool, is_follow_camera_enabled);
    static constexpr int64_t RESOLUTION_256 = 0;
    static constexpr int64_t RESOLUTION_512 = 1;
    static constexpr int64_t RESOLUTION_1024 = 2;
    static constexpr int64_t RESOLUTION_2048 = 3;
    static constexpr int64_t RESOLUTION_4096 = 4;
    static constexpr int64_t RESOLUTION_8192 = 5;
    static constexpr int64_t RESOLUTION_MAX = 6;
    static constexpr int64_t UPDATE_MODE_WHEN_MOVED = 0;
    static constexpr int64_t UPDATE_MODE_ALWAYS = 1;
};
struct GPUParticlesCollisionSDF3D : public GPUParticlesCollision3D {
    using GPUParticlesCollision3D::GPUParticlesCollision3D;
    PROPERTY(size, Vector3);
    PROPERTY(resolution, int64_t);
    PROPERTY(thickness, double);
    PROPERTY(bake_mask, int64_t);
    PROPERTY(texture, Object);
    METHOD(void, set_size);
    METHOD(Vector3, get_size);
    METHOD(void, set_resolution);
    METHOD(int64_t, get_resolution);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_thickness);
    METHOD(double, get_thickness);
    METHOD(void, set_bake_mask);
    METHOD(int64_t, get_bake_mask);
    METHOD(void, set_bake_mask_value);
    METHOD(bool, get_bake_mask_value);
    static constexpr int64_t RESOLUTION_16 = 0;
    static constexpr int64_t RESOLUTION_32 = 1;
    static constexpr int64_t RESOLUTION_64 = 2;
    static constexpr int64_t RESOLUTION_128 = 3;
    static constexpr int64_t RESOLUTION_256 = 4;
    static constexpr int64_t RESOLUTION_512 = 5;
    static constexpr int64_t RESOLUTION_MAX = 6;
};
struct GPUParticlesCollisionSphere3D : public GPUParticlesCollision3D {
    using GPUParticlesCollision3D::GPUParticlesCollision3D;
    PROPERTY(radius, double);
    METHOD(void, set_radius);
    METHOD(double, get_radius);
};
struct GodotNavigationServer2D : public NavigationServer2D {
    using NavigationServer2D::NavigationServer2D;
};
struct GodotPhysicsDirectSpaceState2D : public PhysicsDirectSpaceState2D {
    using PhysicsDirectSpaceState2D::PhysicsDirectSpaceState2D;
};
struct GodotPhysicsServer2D : public PhysicsServer2D {
    using PhysicsServer2D::PhysicsServer2D;
};
struct GodotPhysicsServer3D : public PhysicsServer3D {
    using PhysicsServer3D::PhysicsServer3D;
};
struct GraphFrame : public GraphElement {
    using GraphElement::GraphElement;
    PROPERTY(title, String);
    PROPERTY(autoshrink_enabled, bool);
    PROPERTY(autoshrink_margin, int64_t);
    PROPERTY(drag_margin, int64_t);
    PROPERTY(tint_color_enabled, bool);
    PROPERTY(tint_color, Color);
    METHOD(void, set_title);
    METHOD(String, get_title);
    METHOD(Object, get_titlebar_hbox);
    METHOD(void, set_autoshrink_enabled);
    METHOD(bool, is_autoshrink_enabled);
    METHOD(void, set_autoshrink_margin);
    METHOD(int64_t, get_autoshrink_margin);
    METHOD(void, set_drag_margin);
    METHOD(int64_t, get_drag_margin);
    METHOD(void, set_tint_color_enabled);
    METHOD(bool, is_tint_color_enabled);
    METHOD(void, set_tint_color);
    METHOD(Color, get_tint_color);
};
struct GraphNode : public GraphElement {
    using GraphElement::GraphElement;
    PROPERTY(title, String);
    PROPERTY(ignore_invalid_connection_type, bool);
    METHOD(Variant, _draw_port);
    METHOD(void, set_title);
    METHOD(String, get_title);
    METHOD(Object, get_titlebar_hbox);
    METHOD(void, set_slot);
    METHOD(Variant, clear_slot);
    METHOD(Variant, clear_all_slots);
    METHOD(bool, is_slot_enabled_left);
    METHOD(void, set_slot_enabled_left);
    METHOD(void, set_slot_type_left);
    METHOD(int64_t, get_slot_type_left);
    METHOD(void, set_slot_color_left);
    METHOD(Color, get_slot_color_left);
    METHOD(void, set_slot_custom_icon_left);
    METHOD(Object, get_slot_custom_icon_left);
    METHOD(bool, is_slot_enabled_right);
    METHOD(void, set_slot_enabled_right);
    METHOD(void, set_slot_type_right);
    METHOD(int64_t, get_slot_type_right);
    METHOD(void, set_slot_color_right);
    METHOD(Color, get_slot_color_right);
    METHOD(void, set_slot_custom_icon_right);
    METHOD(Object, get_slot_custom_icon_right);
    METHOD(bool, is_slot_draw_stylebox);
    METHOD(void, set_slot_draw_stylebox);
    METHOD(void, set_ignore_invalid_connection_type);
    METHOD(bool, is_ignoring_valid_connection_type);
    METHOD(int64_t, get_input_port_count);
    METHOD(Vector2, get_input_port_position);
    METHOD(int64_t, get_input_port_type);
    METHOD(Color, get_input_port_color);
    METHOD(int64_t, get_input_port_slot);
    METHOD(int64_t, get_output_port_count);
    METHOD(Vector2, get_output_port_position);
    METHOD(int64_t, get_output_port_type);
    METHOD(Color, get_output_port_color);
    METHOD(int64_t, get_output_port_slot);
};
struct HBoxContainer : public BoxContainer {
    using BoxContainer::BoxContainer;
};
struct VBoxContainer : public BoxContainer {
    using BoxContainer::BoxContainer;
};
struct BackgroundProgress : public HBoxContainer {
    using HBoxContainer::HBoxContainer;
};
struct FindReplaceBar : public HBoxContainer {
    using HBoxContainer::HBoxContainer;
    METHOD(bool, _search_current);
};
struct ProjectExportTextureFormatError : public HBoxContainer {
    using HBoxContainer::HBoxContainer;
};
struct ColorPicker : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
    PROPERTY(color, Color);
    PROPERTY(edit_alpha, bool);
    PROPERTY(color_mode, int64_t);
    PROPERTY(deferred_mode, bool);
    PROPERTY(picker_shape, int64_t);
    PROPERTY(can_add_swatches, bool);
    PROPERTY(sampler_visible, bool);
    PROPERTY(color_modes_visible, bool);
    PROPERTY(sliders_visible, bool);
    PROPERTY(hex_visible, bool);
    PROPERTY(presets_visible, bool);
    METHOD(void, set_pick_color);
    METHOD(Color, get_pick_color);
    METHOD(void, set_deferred_mode);
    METHOD(bool, is_deferred_mode);
    METHOD(void, set_color_mode);
    METHOD(int64_t, get_color_mode);
    METHOD(void, set_edit_alpha);
    METHOD(bool, is_editing_alpha);
    METHOD(void, set_can_add_swatches);
    METHOD(bool, are_swatches_enabled);
    METHOD(void, set_presets_visible);
    METHOD(bool, are_presets_visible);
    METHOD(void, set_modes_visible);
    METHOD(bool, are_modes_visible);
    METHOD(void, set_sampler_visible);
    METHOD(bool, is_sampler_visible);
    METHOD(void, set_sliders_visible);
    METHOD(bool, are_sliders_visible);
    METHOD(void, set_hex_visible);
    METHOD(bool, is_hex_visible);
    METHOD(Variant, add_preset);
    METHOD(Variant, erase_preset);
    METHOD(PackedArray<Color>, get_presets);
    METHOD(Variant, add_recent_preset);
    METHOD(Variant, erase_recent_preset);
    METHOD(PackedArray<Color>, get_recent_presets);
    METHOD(void, set_picker_shape);
    METHOD(int64_t, get_picker_shape);
    static constexpr int64_t MODE_RGB = 0;
    static constexpr int64_t MODE_HSV = 1;
    static constexpr int64_t MODE_RAW = 2;
    static constexpr int64_t MODE_OKHSL = 3;
    static constexpr int64_t SHAPE_HSV_RECTANGLE = 0;
    static constexpr int64_t SHAPE_HSV_WHEEL = 1;
    static constexpr int64_t SHAPE_VHS_CIRCLE = 2;
    static constexpr int64_t SHAPE_OKHSL_CIRCLE = 3;
    static constexpr int64_t SHAPE_NONE = 4;
};
struct ConnectionsDock : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
    METHOD(Variant, update_tree);
};
struct FileSystemDock : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
    METHOD(Variant, _file_list_thumbnail_done);
    METHOD(Variant, _tree_thumbnail_done);
    METHOD(Variant, navigate_to_path);
    METHOD(Variant, add_resource_tooltip_plugin);
    METHOD(Variant, remove_resource_tooltip_plugin);
    METHOD(Variant, _set_dock_horizontal);
    METHOD(bool, _can_dock_horizontal);
};
struct HistoryDock : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
};
struct ImportDock : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
    METHOD(Variant, _reimport);
};
struct InspectorDock : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
    METHOD(Variant, store_script_properties);
    METHOD(Variant, apply_script_properties);
};
struct NodeDock : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
};
struct SceneTreeDock : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
    METHOD(Variant, _set_owners);
    METHOD(Variant, _reparent_nodes_to_root);
    METHOD(Variant, _reparent_nodes_to_paths_with_transform_and_name);
    METHOD(Variant, _update_script_button);
    METHOD(Variant, instantiate);
    METHOD(Object, get_tree_editor);
    METHOD(Variant, replace_node);
};
struct ThemeItemImportTree : public VBoxContainer {
    using VBoxContainer::VBoxContainer;
};
struct HFlowContainer : public FlowContainer {
    using FlowContainer::FlowContainer;
};
struct VFlowContainer : public FlowContainer {
    using FlowContainer::FlowContainer;
};
struct HScrollBar : public ScrollBar {
    using ScrollBar::ScrollBar;
};
struct HSeparator : public Separator {
    using Separator::Separator;
};
struct HSlider : public Slider {
    using Slider::Slider;
};
struct InputEventAction : public InputEvent {
    using InputEvent::InputEvent;
    PROPERTY(action, String);
    PROPERTY(pressed, bool);
    PROPERTY(strength, double);
    PROPERTY(event_index, int64_t);
    METHOD(void, set_action);
    METHOD(String, get_action);
    METHOD(void, set_pressed);
    METHOD(void, set_strength);
    METHOD(double, get_strength);
    METHOD(void, set_event_index);
    METHOD(int64_t, get_event_index);
};
struct InputEventFromWindow : public InputEvent {
    using InputEvent::InputEvent;
    PROPERTY(window_id, int64_t);
    METHOD(void, set_window_id);
    METHOD(int64_t, get_window_id);
};
struct InputEventJoypadButton : public InputEvent {
    using InputEvent::InputEvent;
    PROPERTY(button_index, int64_t);
    PROPERTY(pressure, double);
    PROPERTY(pressed, bool);
    METHOD(void, set_button_index);
    METHOD(int64_t, get_button_index);
    METHOD(void, set_pressure);
    METHOD(double, get_pressure);
    METHOD(void, set_pressed);
};
struct InputEventJoypadMotion : public InputEvent {
    using InputEvent::InputEvent;
    PROPERTY(axis, int64_t);
    PROPERTY(axis_value, double);
    METHOD(void, set_axis);
    METHOD(int64_t, get_axis);
    METHOD(void, set_axis_value);
    METHOD(double, get_axis_value);
};
struct InputEventMIDI : public InputEvent {
    using InputEvent::InputEvent;
    PROPERTY(channel, int64_t);
    PROPERTY(message, int64_t);
    PROPERTY(pitch, int64_t);
    PROPERTY(velocity, int64_t);
    PROPERTY(instrument, int64_t);
    PROPERTY(pressure, int64_t);
    PROPERTY(controller_number, int64_t);
    PROPERTY(controller_value, int64_t);
    METHOD(void, set_channel);
    METHOD(int64_t, get_channel);
    METHOD(void, set_message);
    METHOD(int64_t, get_message);
    METHOD(void, set_pitch);
    METHOD(int64_t, get_pitch);
    METHOD(void, set_velocity);
    METHOD(int64_t, get_velocity);
    METHOD(void, set_instrument);
    METHOD(int64_t, get_instrument);
    METHOD(void, set_pressure);
    METHOD(int64_t, get_pressure);
    METHOD(void, set_controller_number);
    METHOD(int64_t, get_controller_number);
    METHOD(void, set_controller_value);
    METHOD(int64_t, get_controller_value);
};
struct InputEventShortcut : public InputEvent {
    using InputEvent::InputEvent;
    PROPERTY(shortcut, Object);
    METHOD(void, set_shortcut);
    METHOD(Object, get_shortcut);
};
struct InputEventScreenDrag : public InputEventFromWindow {
    using InputEventFromWindow::InputEventFromWindow;
    PROPERTY(index, int64_t);
    PROPERTY(tilt, Vector2);
    PROPERTY(pressure, double);
    PROPERTY(pen_inverted, bool);
    PROPERTY(position, Vector2);
    PROPERTY(relative, Vector2);
    PROPERTY(screen_relative, Vector2);
    PROPERTY(velocity, Vector2);
    PROPERTY(screen_velocity, Vector2);
    METHOD(void, set_index);
    METHOD(int64_t, get_index);
    METHOD(void, set_tilt);
    METHOD(Vector2, get_tilt);
    METHOD(void, set_pressure);
    METHOD(double, get_pressure);
    METHOD(void, set_pen_inverted);
    METHOD(bool, get_pen_inverted);
    METHOD(void, set_position);
    METHOD(Vector2, get_position);
    METHOD(void, set_relative);
    METHOD(Vector2, get_relative);
    METHOD(void, set_screen_relative);
    METHOD(Vector2, get_screen_relative);
    METHOD(void, set_velocity);
    METHOD(Vector2, get_velocity);
    METHOD(void, set_screen_velocity);
    METHOD(Vector2, get_screen_velocity);
};
struct InputEventScreenTouch : public InputEventFromWindow {
    using InputEventFromWindow::InputEventFromWindow;
    PROPERTY(index, int64_t);
    PROPERTY(position, Vector2);
    PROPERTY(canceled, bool);
    PROPERTY(pressed, bool);
    PROPERTY(double_tap, bool);
    METHOD(void, set_index);
    METHOD(int64_t, get_index);
    METHOD(void, set_position);
    METHOD(Vector2, get_position);
    METHOD(void, set_pressed);
    METHOD(void, set_canceled);
    METHOD(void, set_double_tap);
    METHOD(bool, is_double_tap);
};
struct InputEventWithModifiers : public InputEventFromWindow {
    using InputEventFromWindow::InputEventFromWindow;
    PROPERTY(command_or_control_autoremap, bool);
    PROPERTY(alt_pressed, bool);
    PROPERTY(shift_pressed, bool);
    PROPERTY(ctrl_pressed, bool);
    PROPERTY(meta_pressed, bool);
    METHOD(void, set_command_or_control_autoremap);
    METHOD(bool, is_command_or_control_autoremap);
    METHOD(bool, is_command_or_control_pressed);
    METHOD(void, set_alt_pressed);
    METHOD(bool, is_alt_pressed);
    METHOD(void, set_shift_pressed);
    METHOD(bool, is_shift_pressed);
    METHOD(void, set_ctrl_pressed);
    METHOD(bool, is_ctrl_pressed);
    METHOD(void, set_meta_pressed);
    METHOD(bool, is_meta_pressed);
    METHOD(int64_t, get_modifiers_mask);
};
struct InputEventGesture : public InputEventWithModifiers {
    using InputEventWithModifiers::InputEventWithModifiers;
    PROPERTY(position, Vector2);
    METHOD(void, set_position);
    METHOD(Vector2, get_position);
};
struct InputEventKey : public InputEventWithModifiers {
    using InputEventWithModifiers::InputEventWithModifiers;
    PROPERTY(pressed, bool);
    PROPERTY(keycode, int64_t);
    PROPERTY(physical_keycode, int64_t);
    PROPERTY(key_label, int64_t);
    PROPERTY(unicode, int64_t);
    PROPERTY(location, int64_t);
    PROPERTY(echo, bool);
    METHOD(void, set_pressed);
    METHOD(void, set_keycode);
    METHOD(int64_t, get_keycode);
    METHOD(void, set_physical_keycode);
    METHOD(int64_t, get_physical_keycode);
    METHOD(void, set_key_label);
    METHOD(int64_t, get_key_label);
    METHOD(void, set_unicode);
    METHOD(int64_t, get_unicode);
    METHOD(void, set_location);
    METHOD(int64_t, get_location);
    METHOD(void, set_echo);
    METHOD(int64_t, get_keycode_with_modifiers);
    METHOD(int64_t, get_physical_keycode_with_modifiers);
    METHOD(int64_t, get_key_label_with_modifiers);
    METHOD(String, as_text_keycode);
    METHOD(String, as_text_physical_keycode);
    METHOD(String, as_text_key_label);
    METHOD(String, as_text_location);
};
struct InputEventMouse : public InputEventWithModifiers {
    using InputEventWithModifiers::InputEventWithModifiers;
    PROPERTY(button_mask, int64_t);
    PROPERTY(position, Vector2);
    PROPERTY(global_position, Vector2);
    METHOD(void, set_button_mask);
    METHOD(int64_t, get_button_mask);
    METHOD(void, set_position);
    METHOD(Vector2, get_position);
    METHOD(void, set_global_position);
    METHOD(Vector2, get_global_position);
};
struct InputEventMagnifyGesture : public InputEventGesture {
    using InputEventGesture::InputEventGesture;
    PROPERTY(factor, double);
    METHOD(void, set_factor);
    METHOD(double, get_factor);
};
struct InputEventPanGesture : public InputEventGesture {
    using InputEventGesture::InputEventGesture;
    PROPERTY(delta, Vector2);
    METHOD(void, set_delta);
    METHOD(Vector2, get_delta);
};
struct InputEventMouseButton : public InputEventMouse {
    using InputEventMouse::InputEventMouse;
    PROPERTY(factor, double);
    PROPERTY(button_index, int64_t);
    PROPERTY(canceled, bool);
    PROPERTY(pressed, bool);
    PROPERTY(double_click, bool);
    METHOD(void, set_factor);
    METHOD(double, get_factor);
    METHOD(void, set_button_index);
    METHOD(int64_t, get_button_index);
    METHOD(void, set_pressed);
    METHOD(void, set_canceled);
    METHOD(void, set_double_click);
    METHOD(bool, is_double_click);
};
struct InputEventMouseMotion : public InputEventMouse {
    using InputEventMouse::InputEventMouse;
    PROPERTY(tilt, Vector2);
    PROPERTY(pressure, double);
    PROPERTY(pen_inverted, bool);
    PROPERTY(relative, Vector2);
    PROPERTY(screen_relative, Vector2);
    PROPERTY(velocity, Vector2);
    PROPERTY(screen_velocity, Vector2);
    METHOD(void, set_tilt);
    METHOD(Vector2, get_tilt);
    METHOD(void, set_pressure);
    METHOD(double, get_pressure);
    METHOD(void, set_pen_inverted);
    METHOD(bool, get_pen_inverted);
    METHOD(void, set_relative);
    METHOD(Vector2, get_relative);
    METHOD(void, set_screen_relative);
    METHOD(Vector2, get_screen_relative);
    METHOD(void, set_velocity);
    METHOD(Vector2, get_velocity);
    METHOD(void, set_screen_velocity);
    METHOD(Vector2, get_screen_velocity);
};
struct LightmapperRD : public Lightmapper {
    using Lightmapper::Lightmapper;
};
struct MobileVRInterface : public XRInterface {
    using XRInterface::XRInterface;
    PROPERTY(eye_height, double);
    PROPERTY(iod, double);
    PROPERTY(display_width, double);
    PROPERTY(display_to_lens, double);
    PROPERTY(offset_rect, Rect2);
    PROPERTY(oversample, double);
    PROPERTY(k1, double);
    PROPERTY(k2, double);
    PROPERTY(vrs_min_radius, double);
    PROPERTY(vrs_strength, double);
    METHOD(void, set_eye_height);
    METHOD(double, get_eye_height);
    METHOD(void, set_iod);
    METHOD(double, get_iod);
    METHOD(void, set_display_width);
    METHOD(double, get_display_width);
    METHOD(void, set_display_to_lens);
    METHOD(double, get_display_to_lens);
    METHOD(void, set_offset_rect);
    METHOD(Rect2, get_offset_rect);
    METHOD(void, set_oversample);
    METHOD(double, get_oversample);
    METHOD(void, set_k1);
    METHOD(double, get_k1);
    METHOD(void, set_k2);
    METHOD(double, get_k2);
    METHOD(double, get_vrs_min_radius);
    METHOD(void, set_vrs_min_radius);
    METHOD(double, get_vrs_strength);
    METHOD(void, set_vrs_strength);
};
struct OpenXRInterface : public XRInterface {
    using XRInterface::XRInterface;
    PROPERTY(display_refresh_rate, double);
    PROPERTY(render_target_size_multiplier, double);
    PROPERTY(foveation_level, int64_t);
    PROPERTY(foveation_dynamic, bool);
    PROPERTY(vrs_min_radius, double);
    PROPERTY(vrs_strength, double);
    METHOD(double, get_display_refresh_rate);
    METHOD(void, set_display_refresh_rate);
    METHOD(double, get_render_target_size_multiplier);
    METHOD(void, set_render_target_size_multiplier);
    METHOD(bool, is_foveation_supported);
    METHOD(int64_t, get_foveation_level);
    METHOD(void, set_foveation_level);
    METHOD(bool, get_foveation_dynamic);
    METHOD(void, set_foveation_dynamic);
    METHOD(bool, is_action_set_active);
    METHOD(void, set_action_set_active);
    METHOD(Array, get_action_sets);
    METHOD(Array, get_available_display_refresh_rates);
    METHOD(void, set_motion_range);
    METHOD(int64_t, get_motion_range);
    METHOD(int64_t, get_hand_tracking_source);
    METHOD(int64_t, get_hand_joint_flags);
    METHOD(Quaternion, get_hand_joint_rotation);
    METHOD(Vector3, get_hand_joint_position);
    METHOD(double, get_hand_joint_radius);
    METHOD(Vector3, get_hand_joint_linear_velocity);
    METHOD(Vector3, get_hand_joint_angular_velocity);
    METHOD(bool, is_hand_tracking_supported);
    METHOD(bool, is_hand_interaction_supported);
    METHOD(bool, is_eye_gaze_interaction_supported);
    METHOD(double, get_vrs_min_radius);
    METHOD(void, set_vrs_min_radius);
    METHOD(double, get_vrs_strength);
    METHOD(void, set_vrs_strength);
    static constexpr int64_t HAND_LEFT = 0;
    static constexpr int64_t HAND_RIGHT = 1;
    static constexpr int64_t HAND_MAX = 2;
    static constexpr int64_t HAND_MOTION_RANGE_UNOBSTRUCTED = 0;
    static constexpr int64_t HAND_MOTION_RANGE_CONFORM_TO_CONTROLLER = 1;
    static constexpr int64_t HAND_MOTION_RANGE_MAX = 2;
    static constexpr int64_t HAND_TRACKED_SOURCE_UNKNOWN = 0;
    static constexpr int64_t HAND_TRACKED_SOURCE_UNOBSTRUCTED = 1;
    static constexpr int64_t HAND_TRACKED_SOURCE_CONTROLLER = 2;
    static constexpr int64_t HAND_TRACKED_SOURCE_MAX = 3;
    static constexpr int64_t HAND_JOINT_PALM = 0;
    static constexpr int64_t HAND_JOINT_WRIST = 1;
    static constexpr int64_t HAND_JOINT_THUMB_METACARPAL = 2;
    static constexpr int64_t HAND_JOINT_THUMB_PROXIMAL = 3;
    static constexpr int64_t HAND_JOINT_THUMB_DISTAL = 4;
    static constexpr int64_t HAND_JOINT_THUMB_TIP = 5;
    static constexpr int64_t HAND_JOINT_INDEX_METACARPAL = 6;
    static constexpr int64_t HAND_JOINT_INDEX_PROXIMAL = 7;
    static constexpr int64_t HAND_JOINT_INDEX_INTERMEDIATE = 8;
    static constexpr int64_t HAND_JOINT_INDEX_DISTAL = 9;
    static constexpr int64_t HAND_JOINT_INDEX_TIP = 10;
    static constexpr int64_t HAND_JOINT_MIDDLE_METACARPAL = 11;
    static constexpr int64_t HAND_JOINT_MIDDLE_PROXIMAL = 12;
    static constexpr int64_t HAND_JOINT_MIDDLE_INTERMEDIATE = 13;
    static constexpr int64_t HAND_JOINT_MIDDLE_DISTAL = 14;
    static constexpr int64_t HAND_JOINT_MIDDLE_TIP = 15;
    static constexpr int64_t HAND_JOINT_RING_METACARPAL = 16;
    static constexpr int64_t HAND_JOINT_RING_PROXIMAL = 17;
    static constexpr int64_t HAND_JOINT_RING_INTERMEDIATE = 18;
    static constexpr int64_t HAND_JOINT_RING_DISTAL = 19;
    static constexpr int64_t HAND_JOINT_RING_TIP = 20;
    static constexpr int64_t HAND_JOINT_LITTLE_METACARPAL = 21;
    static constexpr int64_t HAND_JOINT_LITTLE_PROXIMAL = 22;
    static constexpr int64_t HAND_JOINT_LITTLE_INTERMEDIATE = 23;
    static constexpr int64_t HAND_JOINT_LITTLE_DISTAL = 24;
    static constexpr int64_t HAND_JOINT_LITTLE_TIP = 25;
    static constexpr int64_t HAND_JOINT_MAX = 26;
    static constexpr int64_t HAND_JOINT_NONE = 0;
    static constexpr int64_t HAND_JOINT_ORIENTATION_VALID = 1;
    static constexpr int64_t HAND_JOINT_ORIENTATION_TRACKED = 2;
    static constexpr int64_t HAND_JOINT_POSITION_VALID = 4;
    static constexpr int64_t HAND_JOINT_POSITION_TRACKED = 8;
    static constexpr int64_t HAND_JOINT_LINEAR_VELOCITY_VALID = 16;
    static constexpr int64_t HAND_JOINT_ANGULAR_VELOCITY_VALID = 32;
};
struct WebXRInterface : public XRInterface {
    using XRInterface::XRInterface;
    PROPERTY(session_mode, String);
    PROPERTY(required_features, String);
    PROPERTY(optional_features, String);
    PROPERTY(requested_reference_space_types, String);
    PROPERTY(reference_space_type, String);
    PROPERTY(enabled_features, String);
    PROPERTY(visibility_state, String);
    METHOD(Variant, is_session_supported);
    METHOD(void, set_session_mode);
    METHOD(String, get_session_mode);
    METHOD(void, set_required_features);
    METHOD(String, get_required_features);
    METHOD(void, set_optional_features);
    METHOD(String, get_optional_features);
    METHOD(String, get_reference_space_type);
    METHOD(String, get_enabled_features);
    METHOD(void, set_requested_reference_space_types);
    METHOD(String, get_requested_reference_space_types);
    METHOD(bool, is_input_source_active);
    METHOD(Object, get_input_source_tracker);
    METHOD(int64_t, get_input_source_target_ray_mode);
    METHOD(String, get_visibility_state);
    METHOD(double, get_display_refresh_rate);
    METHOD(void, set_display_refresh_rate);
    METHOD(Array, get_available_display_refresh_rates);
    static constexpr int64_t TARGET_RAY_MODE_UNKNOWN = 0;
    static constexpr int64_t TARGET_RAY_MODE_GAZE = 1;
    static constexpr int64_t TARGET_RAY_MODE_TRACKED_POINTER = 2;
    static constexpr int64_t TARGET_RAY_MODE_SCREEN = 3;
};
struct ORMMaterial3D : public BaseMaterial3D {
    using BaseMaterial3D::BaseMaterial3D;
};
struct StandardMaterial3D : public BaseMaterial3D {
    using BaseMaterial3D::BaseMaterial3D;
};
struct OptimizedTranslation : public Translation {
    using Translation::Translation;
    METHOD(Variant, generate);
};
struct PhysicalBone2D : public RigidBody2D {
    using RigidBody2D::RigidBody2D;
    PROPERTY(bone2d_nodepath, String);
    PROPERTY(bone2d_index, int64_t);
    PROPERTY(auto_configure_joint, bool);
    PROPERTY(simulate_physics, bool);
    PROPERTY(follow_bone_when_simulating, bool);
    METHOD(Object, get_joint);
    METHOD(bool, get_auto_configure_joint);
    METHOD(void, set_auto_configure_joint);
    METHOD(void, set_simulate_physics);
    METHOD(bool, get_simulate_physics);
    METHOD(bool, is_simulating_physics);
    METHOD(void, set_bone2d_nodepath);
    METHOD(String, get_bone2d_nodepath);
    METHOD(void, set_bone2d_index);
    METHOD(int64_t, get_bone2d_index);
    METHOD(void, set_follow_bone_when_simulating);
    METHOD(bool, get_follow_bone_when_simulating);
};
struct PhysicalBoneSimulator3D : public SkeletonModifier3D {
    using SkeletonModifier3D::SkeletonModifier3D;
    METHOD(bool, is_simulating_physics);
    METHOD(Variant, physical_bones_stop_simulation);
    METHOD(Variant, physical_bones_start_simulation);
    METHOD(Variant, physical_bones_add_collision_exception);
    METHOD(Variant, physical_bones_remove_collision_exception);
};
struct SkeletonIK3D : public SkeletonModifier3D {
    using SkeletonModifier3D::SkeletonModifier3D;
    PROPERTY(root_bone, String);
    PROPERTY(tip_bone, String);
    PROPERTY(target, Transform3D);
    PROPERTY(override_tip_basis, bool);
    PROPERTY(use_magnet, bool);
    PROPERTY(magnet, Vector3);
    PROPERTY(target_node, String);
    PROPERTY(min_distance, double);
    PROPERTY(max_iterations, int64_t);
    PROPERTY(interpolation, double);
    METHOD(void, set_root_bone);
    METHOD(String, get_root_bone);
    METHOD(void, set_tip_bone);
    METHOD(String, get_tip_bone);
    METHOD(void, set_target_transform);
    METHOD(Transform3D, get_target_transform);
    METHOD(void, set_target_node);
    METHOD(String, get_target_node);
    METHOD(void, set_override_tip_basis);
    METHOD(bool, is_override_tip_basis);
    METHOD(void, set_use_magnet);
    METHOD(bool, is_using_magnet);
    METHOD(void, set_magnet_position);
    METHOD(Vector3, get_magnet_position);
    METHOD(Object, get_parent_skeleton);
    METHOD(bool, is_running);
    METHOD(void, set_min_distance);
    METHOD(double, get_min_distance);
    METHOD(void, set_max_iterations);
    METHOD(int64_t, get_max_iterations);
    METHOD(Variant, start);
    METHOD(Variant, stop);
    METHOD(void, set_interpolation);
    METHOD(double, get_interpolation);
};
struct PlaceholderCubemap : public PlaceholderTextureLayered {
    using PlaceholderTextureLayered::PlaceholderTextureLayered;
};
struct PlaceholderCubemapArray : public PlaceholderTextureLayered {
    using PlaceholderTextureLayered::PlaceholderTextureLayered;
};
struct PlaceholderTexture2DArray : public PlaceholderTextureLayered {
    using PlaceholderTextureLayered::PlaceholderTextureLayered;
};
struct PopupMenu : public Popup {
    using Popup::Popup;
    PROPERTY(hide_on_item_selection, bool);
    PROPERTY(hide_on_checkable_item_selection, bool);
    PROPERTY(hide_on_state_item_selection, bool);
    PROPERTY(submenu_popup_delay, double);
    PROPERTY(allow_search, bool);
    PROPERTY(system_menu_id, int64_t);
    PROPERTY(prefer_native_menu, bool);
    PROPERTY(item_count, int64_t);
    METHOD(bool, activate_item_by_event);
    METHOD(void, set_prefer_native_menu);
    METHOD(bool, is_prefer_native_menu);
    METHOD(bool, is_native_menu);
    METHOD(Variant, add_item);
    METHOD(Variant, add_icon_item);
    METHOD(Variant, add_check_item);
    METHOD(Variant, add_icon_check_item);
    METHOD(Variant, add_radio_check_item);
    METHOD(Variant, add_icon_radio_check_item);
    METHOD(Variant, add_multistate_item);
    METHOD(Variant, add_shortcut);
    METHOD(Variant, add_icon_shortcut);
    METHOD(Variant, add_check_shortcut);
    METHOD(Variant, add_icon_check_shortcut);
    METHOD(Variant, add_radio_check_shortcut);
    METHOD(Variant, add_icon_radio_check_shortcut);
    METHOD(Variant, add_submenu_item);
    METHOD(Variant, add_submenu_node_item);
    METHOD(void, set_item_text);
    METHOD(void, set_item_text_direction);
    METHOD(void, set_item_language);
    METHOD(void, set_item_icon);
    METHOD(void, set_item_icon_max_width);
    METHOD(void, set_item_icon_modulate);
    METHOD(void, set_item_checked);
    METHOD(void, set_item_id);
    METHOD(void, set_item_accelerator);
    METHOD(void, set_item_metadata);
    METHOD(void, set_item_disabled);
    METHOD(void, set_item_submenu);
    METHOD(void, set_item_submenu_node);
    METHOD(void, set_item_as_separator);
    METHOD(void, set_item_as_checkable);
    METHOD(void, set_item_as_radio_checkable);
    METHOD(void, set_item_tooltip);
    METHOD(void, set_item_shortcut);
    METHOD(void, set_item_indent);
    METHOD(void, set_item_multistate);
    METHOD(void, set_item_multistate_max);
    METHOD(void, set_item_shortcut_disabled);
    METHOD(Variant, toggle_item_checked);
    METHOD(Variant, toggle_item_multistate);
    METHOD(String, get_item_text);
    METHOD(int64_t, get_item_text_direction);
    METHOD(String, get_item_language);
    METHOD(Object, get_item_icon);
    METHOD(int64_t, get_item_icon_max_width);
    METHOD(Color, get_item_icon_modulate);
    METHOD(bool, is_item_checked);
    METHOD(int64_t, get_item_id);
    METHOD(int64_t, get_item_index);
    METHOD(int64_t, get_item_accelerator);
    METHOD(Variant, get_item_metadata);
    METHOD(bool, is_item_disabled);
    METHOD(String, get_item_submenu);
    METHOD(Object, get_item_submenu_node);
    METHOD(bool, is_item_separator);
    METHOD(bool, is_item_checkable);
    METHOD(bool, is_item_radio_checkable);
    METHOD(bool, is_item_shortcut_disabled);
    METHOD(String, get_item_tooltip);
    METHOD(Object, get_item_shortcut);
    METHOD(int64_t, get_item_indent);
    METHOD(int64_t, get_item_multistate_max);
    METHOD(int64_t, get_item_multistate);
    METHOD(void, set_focused_item);
    METHOD(int64_t, get_focused_item);
    METHOD(void, set_item_count);
    METHOD(int64_t, get_item_count);
    METHOD(Variant, scroll_to_item);
    METHOD(Variant, remove_item);
    METHOD(Variant, add_separator);
    METHOD(Variant, clear);
    METHOD(void, set_hide_on_item_selection);
    METHOD(bool, is_hide_on_item_selection);
    METHOD(void, set_hide_on_checkable_item_selection);
    METHOD(bool, is_hide_on_checkable_item_selection);
    METHOD(void, set_hide_on_state_item_selection);
    METHOD(bool, is_hide_on_state_item_selection);
    METHOD(void, set_submenu_popup_delay);
    METHOD(double, get_submenu_popup_delay);
    METHOD(void, set_allow_search);
    METHOD(bool, get_allow_search);
    METHOD(bool, is_system_menu);
    METHOD(void, set_system_menu);
    METHOD(int64_t, get_system_menu);
};
struct PopupPanel : public Popup {
    using Popup::Popup;
};
struct DockContextPopup : public PopupPanel {
    using PopupPanel::PopupPanel;
};
struct ProgressDialog : public PopupPanel {
    using PopupPanel::PopupPanel;
};
struct QuadMesh : public PlaneMesh {
    using PlaneMesh::PlaneMesh;
};
struct SectionedInspector : public HSplitContainer {
    using HSplitContainer::HSplitContainer;
    METHOD(Variant, update_category_list);
};
struct SoftBody3D : public MeshInstance3D {
    using MeshInstance3D::MeshInstance3D;
    PROPERTY(collision_layer, int64_t);
    PROPERTY(collision_mask, int64_t);
    PROPERTY(parent_collision_ignore, String);
    PROPERTY(simulation_precision, int64_t);
    PROPERTY(total_mass, double);
    PROPERTY(linear_stiffness, double);
    PROPERTY(pressure_coefficient, double);
    PROPERTY(damping_coefficient, double);
    PROPERTY(drag_coefficient, double);
    PROPERTY(ray_pickable, bool);
    PROPERTY(disable_mode, int64_t);
    METHOD(::RID, get_physics_rid);
    METHOD(void, set_collision_mask);
    METHOD(int64_t, get_collision_mask);
    METHOD(void, set_collision_layer);
    METHOD(int64_t, get_collision_layer);
    METHOD(void, set_collision_mask_value);
    METHOD(bool, get_collision_mask_value);
    METHOD(void, set_collision_layer_value);
    METHOD(bool, get_collision_layer_value);
    METHOD(void, set_parent_collision_ignore);
    METHOD(String, get_parent_collision_ignore);
    METHOD(void, set_disable_mode);
    METHOD(int64_t, get_disable_mode);
    METHOD(Array, get_collision_exceptions);
    METHOD(Variant, add_collision_exception_with);
    METHOD(Variant, remove_collision_exception_with);
    METHOD(void, set_simulation_precision);
    METHOD(int64_t, get_simulation_precision);
    METHOD(void, set_total_mass);
    METHOD(double, get_total_mass);
    METHOD(void, set_linear_stiffness);
    METHOD(double, get_linear_stiffness);
    METHOD(void, set_pressure_coefficient);
    METHOD(double, get_pressure_coefficient);
    METHOD(void, set_damping_coefficient);
    METHOD(double, get_damping_coefficient);
    METHOD(void, set_drag_coefficient);
    METHOD(double, get_drag_coefficient);
    METHOD(Vector3, get_point_transform);
    METHOD(void, set_point_pinned);
    METHOD(bool, is_point_pinned);
    METHOD(void, set_ray_pickable);
    METHOD(bool, is_ray_pickable);
    static constexpr int64_t DISABLE_MODE_REMOVE = 0;
    static constexpr int64_t DISABLE_MODE_KEEP_ACTIVE = 1;
};
struct SubViewport : public Viewport {
    using Viewport::Viewport;
    PROPERTY(size, Vector2i);
    PROPERTY(size_2d_override, Vector2i);
    PROPERTY(size_2d_override_stretch, bool);
    PROPERTY(render_target_clear_mode, int64_t);
    PROPERTY(render_target_update_mode, int64_t);
    METHOD(void, set_size);
    METHOD(Vector2i, get_size);
    METHOD(void, set_size_2d_override);
    METHOD(Vector2i, get_size_2d_override);
    METHOD(void, set_size_2d_override_stretch);
    METHOD(bool, is_size_2d_override_stretch_enabled);
    METHOD(void, set_update_mode);
    METHOD(int64_t, get_update_mode);
    METHOD(void, set_clear_mode);
    METHOD(int64_t, get_clear_mode);
    static constexpr int64_t CLEAR_MODE_ALWAYS = 0;
    static constexpr int64_t CLEAR_MODE_NEVER = 1;
    static constexpr int64_t CLEAR_MODE_ONCE = 2;
    static constexpr int64_t UPDATE_DISABLED = 0;
    static constexpr int64_t UPDATE_ONCE = 1;
    static constexpr int64_t UPDATE_WHEN_VISIBLE = 2;
    static constexpr int64_t UPDATE_WHEN_PARENT_VISIBLE = 3;
    static constexpr int64_t UPDATE_ALWAYS = 4;
};
struct TextServerAdvanced : public TextServerExtension {
    using TextServerExtension::TextServerExtension;
};
struct TextServerDummy : public TextServerExtension {
    using TextServerExtension::TextServerExtension;
};
struct Texture2DArrayRD : public TextureLayeredRD {
    using TextureLayeredRD::TextureLayeredRD;
};
struct TextureCubemapArrayRD : public TextureLayeredRD {
    using TextureLayeredRD::TextureLayeredRD;
};
struct TextureCubemapRD : public TextureLayeredRD {
    using TextureLayeredRD::TextureLayeredRD;
};
struct TileSetAtlasSource : public TileSetSource {
    using TileSetSource::TileSetSource;
    PROPERTY(texture, Object);
    PROPERTY(margins, Vector2i);
    PROPERTY(separation, Vector2i);
    PROPERTY(texture_region_size, Vector2i);
    PROPERTY(use_texture_padding, bool);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
    METHOD(void, set_margins);
    METHOD(Vector2i, get_margins);
    METHOD(void, set_separation);
    METHOD(Vector2i, get_separation);
    METHOD(void, set_texture_region_size);
    METHOD(Vector2i, get_texture_region_size);
    METHOD(void, set_use_texture_padding);
    METHOD(bool, get_use_texture_padding);
    METHOD(Variant, create_tile);
    METHOD(Variant, remove_tile);
    METHOD(Variant, move_tile_in_atlas);
    METHOD(Vector2i, get_tile_size_in_atlas);
    METHOD(bool, has_room_for_tile);
    METHOD(PackedArray<Vector2>, get_tiles_to_be_removed_on_change);
    METHOD(Vector2i, get_tile_at_coords);
    METHOD(bool, has_tiles_outside_texture);
    METHOD(Variant, clear_tiles_outside_texture);
    METHOD(void, set_tile_animation_columns);
    METHOD(int64_t, get_tile_animation_columns);
    METHOD(void, set_tile_animation_separation);
    METHOD(Vector2i, get_tile_animation_separation);
    METHOD(void, set_tile_animation_speed);
    METHOD(double, get_tile_animation_speed);
    METHOD(void, set_tile_animation_mode);
    METHOD(int64_t, get_tile_animation_mode);
    METHOD(void, set_tile_animation_frames_count);
    METHOD(int64_t, get_tile_animation_frames_count);
    METHOD(void, set_tile_animation_frame_duration);
    METHOD(double, get_tile_animation_frame_duration);
    METHOD(double, get_tile_animation_total_duration);
    METHOD(int64_t, create_alternative_tile);
    METHOD(Variant, remove_alternative_tile);
    METHOD(void, set_alternative_tile_id);
    METHOD(int64_t, get_next_alternative_tile_id);
    METHOD(Object, get_tile_data);
    METHOD(Vector2i, get_atlas_grid_size);
    METHOD(Rect2i, get_tile_texture_region);
    METHOD(Object, get_runtime_texture);
    METHOD(Rect2i, get_runtime_tile_texture_region);
    static constexpr int64_t TILE_ANIMATION_MODE_DEFAULT = 0;
    static constexpr int64_t TILE_ANIMATION_MODE_RANDOM_START_TIMES = 1;
    static constexpr int64_t TILE_ANIMATION_MODE_MAX = 2;
    static constexpr int64_t TRANSFORM_FLIP_H = 4096;
    static constexpr int64_t TRANSFORM_FLIP_V = 8192;
    static constexpr int64_t TRANSFORM_TRANSPOSE = 16384;
};
struct TileSetScenesCollectionSource : public TileSetSource {
    using TileSetSource::TileSetSource;
    METHOD(int64_t, get_scene_tiles_count);
    METHOD(int64_t, get_scene_tile_id);
    METHOD(bool, has_scene_tile_id);
    METHOD(int64_t, create_scene_tile);
    METHOD(void, set_scene_tile_id);
    METHOD(void, set_scene_tile_scene);
    METHOD(Object, get_scene_tile_scene);
    METHOD(void, set_scene_tile_display_placeholder);
    METHOD(bool, get_scene_tile_display_placeholder);
    METHOD(Variant, remove_scene_tile);
    METHOD(int64_t, get_next_scene_tile_id);
};
struct VisibleOnScreenEnabler2D : public VisibleOnScreenNotifier2D {
    using VisibleOnScreenNotifier2D::VisibleOnScreenNotifier2D;
    PROPERTY(enable_mode, int64_t);
    PROPERTY(enable_node_path, String);
    METHOD(void, set_enable_mode);
    METHOD(int64_t, get_enable_mode);
    METHOD(void, set_enable_node_path);
    METHOD(String, get_enable_node_path);
    static constexpr int64_t ENABLE_MODE_INHERIT = 0;
    static constexpr int64_t ENABLE_MODE_ALWAYS = 1;
    static constexpr int64_t ENABLE_MODE_WHEN_PAUSED = 2;
};
struct VisibleOnScreenEnabler3D : public VisibleOnScreenNotifier3D {
    using VisibleOnScreenNotifier3D::VisibleOnScreenNotifier3D;
    PROPERTY(enable_mode, int64_t);
    PROPERTY(enable_node_path, String);
    METHOD(void, set_enable_mode);
    METHOD(int64_t, get_enable_mode);
    METHOD(void, set_enable_node_path);
    METHOD(String, get_enable_node_path);
    static constexpr int64_t ENABLE_MODE_INHERIT = 0;
    static constexpr int64_t ENABLE_MODE_ALWAYS = 1;
    static constexpr int64_t ENABLE_MODE_WHEN_PAUSED = 2;
};
struct VisualShaderNodeBooleanConstant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, bool);
    METHOD(void, set_constant);
    METHOD(bool, get_constant);
};
struct VisualShaderNodeColorConstant : public VisualShaderNodeConstant {
    using VisualShaderNodeConstant::VisualShaderNodeConstant;
    PROPERTY(constant, Color);
    METHOD(void, set_constant);
    METHOD(Color, get_constant);
};
struct VisualShaderNodeBooleanParameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, bool);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(bool, get_default_value);
};
struct VisualShaderNodeColorParameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, Color);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(Color, get_default_value);
};
struct VisualShaderNodeFloatParameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(hint, int64_t);
    PROPERTY(min, double);
    PROPERTY(max, double);
    PROPERTY(step, double);
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, double);
    METHOD(void, set_hint);
    METHOD(int64_t, get_hint);
    METHOD(void, set_min);
    METHOD(double, get_min);
    METHOD(void, set_max);
    METHOD(double, get_max);
    METHOD(void, set_step);
    METHOD(double, get_step);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(double, get_default_value);
    static constexpr int64_t HINT_NONE = 0;
    static constexpr int64_t HINT_RANGE = 1;
    static constexpr int64_t HINT_RANGE_STEP = 2;
    static constexpr int64_t HINT_MAX = 3;
};
struct VisualShaderNodeIntParameter : public VisualShaderNodeParameter {
    using VisualShaderNodeParameter::VisualShaderNodeParameter;
    PROPERTY(hint, int64_t);
    PROPERTY(min, int64_t);
    PROPERTY(max, int64_t);
    PROPERTY(step, int64_t);
    PROPERTY(default_value_enabled, bool);
    PROPERTY(default_value, int64_t);
    METHOD(void, set_hint);
    METHOD(int64_t, get_hint);
    METHOD(void, set_min);
    METHOD(int64_t, get_min);
    METHOD(void, set_max);
    METHOD(int64_t, get_max);
    METHOD(void, set_step);
    METHOD(int64_t, get_step);
    METHOD(void, set_default_value_enabled);
    METHOD(bool, is_default_value_enabled);
    METHOD(void, set_default_value);
    METHOD(int64_t, get_default_value);
    static constexpr int64_t HINT_NONE = 0;
    static constexpr int64_t HINT_RANGE = 1;
    static constexpr int64_t HINT_RANGE_STEP = 2;
    static constexpr int64_t HINT_MAX = 3;
};
struct VisualShaderNodeCubemapParameter : public VisualShaderNodeTextureParameter {
    using VisualShaderNodeTextureParameter::VisualShaderNodeTextureParameter;
};
struct VisualShaderNodeTexture2DArrayParameter : public VisualShaderNodeTextureParameter {
    using VisualShaderNodeTextureParameter::VisualShaderNodeTextureParameter;
};
struct VisualShaderNodeTexture2DParameter : public VisualShaderNodeTextureParameter {
    using VisualShaderNodeTextureParameter::VisualShaderNodeTextureParameter;
};
struct VisualShaderNodeTexture3DParameter : public VisualShaderNodeTextureParameter {
    using VisualShaderNodeTextureParameter::VisualShaderNodeTextureParameter;
};
struct VisualShaderNodeCurveTexture : public VisualShaderNodeResizableBase {
    using VisualShaderNodeResizableBase::VisualShaderNodeResizableBase;
    PROPERTY(texture, Object);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
};
struct VisualShaderNodeCurveXYZTexture : public VisualShaderNodeResizableBase {
    using VisualShaderNodeResizableBase::VisualShaderNodeResizableBase;
    PROPERTY(texture, Object);
    METHOD(void, set_texture);
    METHOD(Object, get_texture);
};
struct VisualShaderNodeFrame : public VisualShaderNodeResizableBase {
    using VisualShaderNodeResizableBase::VisualShaderNodeResizableBase;
    PROPERTY(title, String);
    PROPERTY(tint_color_enabled, bool);
    PROPERTY(tint_color, Color);
    PROPERTY(autoshrink, bool);
    PROPERTY(attached_nodes, PackedArray<int32_t>);
    METHOD(void, set_title);
    METHOD(String, get_title);
    METHOD(void, set_tint_color_enabled);
    METHOD(bool, is_tint_color_enabled);
    METHOD(void, set_tint_color);
    METHOD(Color, get_tint_color);
    METHOD(void, set_autoshrink_enabled);
    METHOD(bool, is_autoshrink_enabled);
    METHOD(Variant, add_attached_node);
    METHOD(Variant, remove_attached_node);
    METHOD(void, set_attached_nodes);
    METHOD(PackedArray<int32_t>, get_attached_nodes);
};
struct VisualShaderNodeGroupBase : public VisualShaderNodeResizableBase {
    using VisualShaderNodeResizableBase::VisualShaderNodeResizableBase;
    METHOD(void, set_inputs);
    METHOD(String, get_inputs);
    METHOD(void, set_outputs);
    METHOD(String, get_outputs);
    METHOD(bool, is_valid_port_name);
    METHOD(Variant, add_input_port);
    METHOD(Variant, remove_input_port);
    METHOD(int64_t, get_input_port_count);
    METHOD(bool, has_input_port);
    METHOD(Variant, clear_input_ports);
    METHOD(Variant, add_output_port);
    METHOD(Variant, remove_output_port);
    METHOD(int64_t, get_output_port_count);
    METHOD(bool, has_output_port);
    METHOD(Variant, clear_output_ports);
    METHOD(void, set_input_port_name);
    METHOD(void, set_input_port_type);
    METHOD(void, set_output_port_name);
    METHOD(void, set_output_port_type);
    METHOD(int64_t, get_free_input_port_id);
    METHOD(int64_t, get_free_output_port_id);
};
struct VisualShaderNodeComment : public VisualShaderNodeFrame {
    using VisualShaderNodeFrame::VisualShaderNodeFrame;
    PROPERTY(description, String);
    METHOD(void, set_description);
    METHOD(String, get_description);
};
struct VisualShaderNodeExpression : public VisualShaderNodeGroupBase {
    using VisualShaderNodeGroupBase::VisualShaderNodeGroupBase;
    PROPERTY(expression, String);
    METHOD(void, set_expression);
    METHOD(String, get_expression);
};
struct VisualShaderNodeFaceForward : public VisualShaderNodeVectorBase {
    using VisualShaderNodeVectorBase::VisualShaderNodeVectorBase;
};
struct VisualShaderNodeGlobalExpression : public VisualShaderNodeExpression {
    using VisualShaderNodeExpression::VisualShaderNodeExpression;
};
struct VisualShaderNodeParticleBoxEmitter : public VisualShaderNodeParticleEmitter {
    using VisualShaderNodeParticleEmitter::VisualShaderNodeParticleEmitter;
};
struct WindowWrapper : public MarginContainer {
    using MarginContainer::MarginContainer;
};
struct XRAnchor3D : public XRNode3D {
    using XRNode3D::XRNode3D;
    METHOD(Vector3, get_size);
    METHOD(Plane, get_plane);
};
struct XRController3D : public XRNode3D {
    using XRNode3D::XRNode3D;
    METHOD(bool, is_button_pressed);
    METHOD(Variant, get_input);
    METHOD(double, get_float);
    METHOD(Vector2, get_vector2);
    METHOD(int64_t, get_tracker_hand);
};
struct XRFaceTracker : public XRTracker {
    using XRTracker::XRTracker;
    PROPERTY(blend_shapes, PackedArray<float>);
    METHOD(double, get_blend_shape);
    METHOD(void, set_blend_shape);
    METHOD(PackedArray<float>, get_blend_shapes);
    METHOD(void, set_blend_shapes);
    static constexpr int64_t FT_EYE_LOOK_OUT_RIGHT = 0;
    static constexpr int64_t FT_EYE_LOOK_IN_RIGHT = 1;
    static constexpr int64_t FT_EYE_LOOK_UP_RIGHT = 2;
    static constexpr int64_t FT_EYE_LOOK_DOWN_RIGHT = 3;
    static constexpr int64_t FT_EYE_LOOK_OUT_LEFT = 4;
    static constexpr int64_t FT_EYE_LOOK_IN_LEFT = 5;
    static constexpr int64_t FT_EYE_LOOK_UP_LEFT = 6;
    static constexpr int64_t FT_EYE_LOOK_DOWN_LEFT = 7;
    static constexpr int64_t FT_EYE_CLOSED_RIGHT = 8;
    static constexpr int64_t FT_EYE_CLOSED_LEFT = 9;
    static constexpr int64_t FT_EYE_SQUINT_RIGHT = 10;
    static constexpr int64_t FT_EYE_SQUINT_LEFT = 11;
    static constexpr int64_t FT_EYE_WIDE_RIGHT = 12;
    static constexpr int64_t FT_EYE_WIDE_LEFT = 13;
    static constexpr int64_t FT_EYE_DILATION_RIGHT = 14;
    static constexpr int64_t FT_EYE_DILATION_LEFT = 15;
    static constexpr int64_t FT_EYE_CONSTRICT_RIGHT = 16;
    static constexpr int64_t FT_EYE_CONSTRICT_LEFT = 17;
    static constexpr int64_t FT_BROW_PINCH_RIGHT = 18;
    static constexpr int64_t FT_BROW_PINCH_LEFT = 19;
    static constexpr int64_t FT_BROW_LOWERER_RIGHT = 20;
    static constexpr int64_t FT_BROW_LOWERER_LEFT = 21;
    static constexpr int64_t FT_BROW_INNER_UP_RIGHT = 22;
    static constexpr int64_t FT_BROW_INNER_UP_LEFT = 23;
    static constexpr int64_t FT_BROW_OUTER_UP_RIGHT = 24;
    static constexpr int64_t FT_BROW_OUTER_UP_LEFT = 25;
    static constexpr int64_t FT_NOSE_SNEER_RIGHT = 26;
    static constexpr int64_t FT_NOSE_SNEER_LEFT = 27;
    static constexpr int64_t FT_NASAL_DILATION_RIGHT = 28;
    static constexpr int64_t FT_NASAL_DILATION_LEFT = 29;
    static constexpr int64_t FT_NASAL_CONSTRICT_RIGHT = 30;
    static constexpr int64_t FT_NASAL_CONSTRICT_LEFT = 31;
    static constexpr int64_t FT_CHEEK_SQUINT_RIGHT = 32;
    static constexpr int64_t FT_CHEEK_SQUINT_LEFT = 33;
    static constexpr int64_t FT_CHEEK_PUFF_RIGHT = 34;
    static constexpr int64_t FT_CHEEK_PUFF_LEFT = 35;
    static constexpr int64_t FT_CHEEK_SUCK_RIGHT = 36;
    static constexpr int64_t FT_CHEEK_SUCK_LEFT = 37;
    static constexpr int64_t FT_JAW_OPEN = 38;
    static constexpr int64_t FT_MOUTH_CLOSED = 39;
    static constexpr int64_t FT_JAW_RIGHT = 40;
    static constexpr int64_t FT_JAW_LEFT = 41;
    static constexpr int64_t FT_JAW_FORWARD = 42;
    static constexpr int64_t FT_JAW_BACKWARD = 43;
    static constexpr int64_t FT_JAW_CLENCH = 44;
    static constexpr int64_t FT_JAW_MANDIBLE_RAISE = 45;
    static constexpr int64_t FT_LIP_SUCK_UPPER_RIGHT = 46;
    static constexpr int64_t FT_LIP_SUCK_UPPER_LEFT = 47;
    static constexpr int64_t FT_LIP_SUCK_LOWER_RIGHT = 48;
    static constexpr int64_t FT_LIP_SUCK_LOWER_LEFT = 49;
    static constexpr int64_t FT_LIP_SUCK_CORNER_RIGHT = 50;
    static constexpr int64_t FT_LIP_SUCK_CORNER_LEFT = 51;
    static constexpr int64_t FT_LIP_FUNNEL_UPPER_RIGHT = 52;
    static constexpr int64_t FT_LIP_FUNNEL_UPPER_LEFT = 53;
    static constexpr int64_t FT_LIP_FUNNEL_LOWER_RIGHT = 54;
    static constexpr int64_t FT_LIP_FUNNEL_LOWER_LEFT = 55;
    static constexpr int64_t FT_LIP_PUCKER_UPPER_RIGHT = 56;
    static constexpr int64_t FT_LIP_PUCKER_UPPER_LEFT = 57;
    static constexpr int64_t FT_LIP_PUCKER_LOWER_RIGHT = 58;
    static constexpr int64_t FT_LIP_PUCKER_LOWER_LEFT = 59;
    static constexpr int64_t FT_MOUTH_UPPER_UP_RIGHT = 60;
    static constexpr int64_t FT_MOUTH_UPPER_UP_LEFT = 61;
    static constexpr int64_t FT_MOUTH_LOWER_DOWN_RIGHT = 62;
    static constexpr int64_t FT_MOUTH_LOWER_DOWN_LEFT = 63;
    static constexpr int64_t FT_MOUTH_UPPER_DEEPEN_RIGHT = 64;
    static constexpr int64_t FT_MOUTH_UPPER_DEEPEN_LEFT = 65;
    static constexpr int64_t FT_MOUTH_UPPER_RIGHT = 66;
    static constexpr int64_t FT_MOUTH_UPPER_LEFT = 67;
    static constexpr int64_t FT_MOUTH_LOWER_RIGHT = 68;
    static constexpr int64_t FT_MOUTH_LOWER_LEFT = 69;
    static constexpr int64_t FT_MOUTH_CORNER_PULL_RIGHT = 70;
    static constexpr int64_t FT_MOUTH_CORNER_PULL_LEFT = 71;
    static constexpr int64_t FT_MOUTH_CORNER_SLANT_RIGHT = 72;
    static constexpr int64_t FT_MOUTH_CORNER_SLANT_LEFT = 73;
    static constexpr int64_t FT_MOUTH_FROWN_RIGHT = 74;
    static constexpr int64_t FT_MOUTH_FROWN_LEFT = 75;
    static constexpr int64_t FT_MOUTH_STRETCH_RIGHT = 76;
    static constexpr int64_t FT_MOUTH_STRETCH_LEFT = 77;
    static constexpr int64_t FT_MOUTH_DIMPLE_RIGHT = 78;
    static constexpr int64_t FT_MOUTH_DIMPLE_LEFT = 79;
    static constexpr int64_t FT_MOUTH_RAISER_UPPER = 80;
    static constexpr int64_t FT_MOUTH_RAISER_LOWER = 81;
    static constexpr int64_t FT_MOUTH_PRESS_RIGHT = 82;
    static constexpr int64_t FT_MOUTH_PRESS_LEFT = 83;
    static constexpr int64_t FT_MOUTH_TIGHTENER_RIGHT = 84;
    static constexpr int64_t FT_MOUTH_TIGHTENER_LEFT = 85;
    static constexpr int64_t FT_TONGUE_OUT = 86;
    static constexpr int64_t FT_TONGUE_UP = 87;
    static constexpr int64_t FT_TONGUE_DOWN = 88;
    static constexpr int64_t FT_TONGUE_RIGHT = 89;
    static constexpr int64_t FT_TONGUE_LEFT = 90;
    static constexpr int64_t FT_TONGUE_ROLL = 91;
    static constexpr int64_t FT_TONGUE_BLEND_DOWN = 92;
    static constexpr int64_t FT_TONGUE_CURL_UP = 93;
    static constexpr int64_t FT_TONGUE_SQUISH = 94;
    static constexpr int64_t FT_TONGUE_FLAT = 95;
    static constexpr int64_t FT_TONGUE_TWIST_RIGHT = 96;
    static constexpr int64_t FT_TONGUE_TWIST_LEFT = 97;
    static constexpr int64_t FT_SOFT_PALATE_CLOSE = 98;
    static constexpr int64_t FT_THROAT_SWALLOW = 99;
    static constexpr int64_t FT_NECK_FLEX_RIGHT = 100;
    static constexpr int64_t FT_NECK_FLEX_LEFT = 101;
    static constexpr int64_t FT_EYE_CLOSED = 102;
    static constexpr int64_t FT_EYE_WIDE = 103;
    static constexpr int64_t FT_EYE_SQUINT = 104;
    static constexpr int64_t FT_EYE_DILATION = 105;
    static constexpr int64_t FT_EYE_CONSTRICT = 106;
    static constexpr int64_t FT_BROW_DOWN_RIGHT = 107;
    static constexpr int64_t FT_BROW_DOWN_LEFT = 108;
    static constexpr int64_t FT_BROW_DOWN = 109;
    static constexpr int64_t FT_BROW_UP_RIGHT = 110;
    static constexpr int64_t FT_BROW_UP_LEFT = 111;
    static constexpr int64_t FT_BROW_UP = 112;
    static constexpr int64_t FT_NOSE_SNEER = 113;
    static constexpr int64_t FT_NASAL_DILATION = 114;
    static constexpr int64_t FT_NASAL_CONSTRICT = 115;
    static constexpr int64_t FT_CHEEK_PUFF = 116;
    static constexpr int64_t FT_CHEEK_SUCK = 117;
    static constexpr int64_t FT_CHEEK_SQUINT = 118;
    static constexpr int64_t FT_LIP_SUCK_UPPER = 119;
    static constexpr int64_t FT_LIP_SUCK_LOWER = 120;
    static constexpr int64_t FT_LIP_SUCK = 121;
    static constexpr int64_t FT_LIP_FUNNEL_UPPER = 122;
    static constexpr int64_t FT_LIP_FUNNEL_LOWER = 123;
    static constexpr int64_t FT_LIP_FUNNEL = 124;
    static constexpr int64_t FT_LIP_PUCKER_UPPER = 125;
    static constexpr int64_t FT_LIP_PUCKER_LOWER = 126;
    static constexpr int64_t FT_LIP_PUCKER = 127;
    static constexpr int64_t FT_MOUTH_UPPER_UP = 128;
    static constexpr int64_t FT_MOUTH_LOWER_DOWN = 129;
    static constexpr int64_t FT_MOUTH_OPEN = 130;
    static constexpr int64_t FT_MOUTH_RIGHT = 131;
    static constexpr int64_t FT_MOUTH_LEFT = 132;
    static constexpr int64_t FT_MOUTH_SMILE_RIGHT = 133;
    static constexpr int64_t FT_MOUTH_SMILE_LEFT = 134;
    static constexpr int64_t FT_MOUTH_SMILE = 135;
    static constexpr int64_t FT_MOUTH_SAD_RIGHT = 136;
    static constexpr int64_t FT_MOUTH_SAD_LEFT = 137;
    static constexpr int64_t FT_MOUTH_SAD = 138;
    static constexpr int64_t FT_MOUTH_STRETCH = 139;
    static constexpr int64_t FT_MOUTH_DIMPLE = 140;
    static constexpr int64_t FT_MOUTH_TIGHTENER = 141;
    static constexpr int64_t FT_MOUTH_PRESS = 142;
    static constexpr int64_t FT_MAX = 143;
};
struct XRPositionalTracker : public XRTracker {
    using XRTracker::XRTracker;
    PROPERTY(profile, String);
    PROPERTY(hand, int64_t);
    METHOD(String, get_tracker_profile);
    METHOD(void, set_tracker_profile);
    METHOD(int64_t, get_tracker_hand);
    METHOD(void, set_tracker_hand);
    METHOD(bool, has_pose);
    METHOD(Object, get_pose);
    METHOD(Variant, invalidate_pose);
    METHOD(void, set_pose);
    METHOD(Variant, get_input);
    METHOD(void, set_input);
    static constexpr int64_t TRACKER_HAND_UNKNOWN = 0;
    static constexpr int64_t TRACKER_HAND_LEFT = 1;
    static constexpr int64_t TRACKER_HAND_RIGHT = 2;
    static constexpr int64_t TRACKER_HAND_MAX = 3;
};
struct XRBodyTracker : public XRPositionalTracker {
    using XRPositionalTracker::XRPositionalTracker;
    PROPERTY(has_tracking_data, bool);
    PROPERTY(body_flags, int64_t);
    METHOD(void, set_has_tracking_data);
    METHOD(bool, get_has_tracking_data);
    METHOD(void, set_body_flags);
    METHOD(int64_t, get_body_flags);
    METHOD(void, set_joint_flags);
    METHOD(int64_t, get_joint_flags);
    METHOD(void, set_joint_transform);
    METHOD(Transform3D, get_joint_transform);
    static constexpr int64_t BODY_FLAG_UPPER_BODY_SUPPORTED = 1;
    static constexpr int64_t BODY_FLAG_LOWER_BODY_SUPPORTED = 2;
    static constexpr int64_t BODY_FLAG_HANDS_SUPPORTED = 4;
    static constexpr int64_t JOINT_ROOT = 0;
    static constexpr int64_t JOINT_HIPS = 1;
    static constexpr int64_t JOINT_SPINE = 2;
    static constexpr int64_t JOINT_CHEST = 3;
    static constexpr int64_t JOINT_UPPER_CHEST = 4;
    static constexpr int64_t JOINT_NECK = 5;
    static constexpr int64_t JOINT_HEAD = 6;
    static constexpr int64_t JOINT_HEAD_TIP = 7;
    static constexpr int64_t JOINT_LEFT_SHOULDER = 8;
    static constexpr int64_t JOINT_LEFT_UPPER_ARM = 9;
    static constexpr int64_t JOINT_LEFT_LOWER_ARM = 10;
    static constexpr int64_t JOINT_RIGHT_SHOULDER = 11;
    static constexpr int64_t JOINT_RIGHT_UPPER_ARM = 12;
    static constexpr int64_t JOINT_RIGHT_LOWER_ARM = 13;
    static constexpr int64_t JOINT_LEFT_UPPER_LEG = 14;
    static constexpr int64_t JOINT_LEFT_LOWER_LEG = 15;
    static constexpr int64_t JOINT_LEFT_FOOT = 16;
    static constexpr int64_t JOINT_LEFT_TOES = 17;
    static constexpr int64_t JOINT_RIGHT_UPPER_LEG = 18;
    static constexpr int64_t JOINT_RIGHT_LOWER_LEG = 19;
    static constexpr int64_t JOINT_RIGHT_FOOT = 20;
    static constexpr int64_t JOINT_RIGHT_TOES = 21;
    static constexpr int64_t JOINT_LEFT_HAND = 22;
    static constexpr int64_t JOINT_LEFT_PALM = 23;
    static constexpr int64_t JOINT_LEFT_WRIST = 24;
    static constexpr int64_t JOINT_LEFT_THUMB_METACARPAL = 25;
    static constexpr int64_t JOINT_LEFT_THUMB_PHALANX_PROXIMAL = 26;
    static constexpr int64_t JOINT_LEFT_THUMB_PHALANX_DISTAL = 27;
    static constexpr int64_t JOINT_LEFT_THUMB_TIP = 28;
    static constexpr int64_t JOINT_LEFT_INDEX_FINGER_METACARPAL = 29;
    static constexpr int64_t JOINT_LEFT_INDEX_FINGER_PHALANX_PROXIMAL = 30;
    static constexpr int64_t JOINT_LEFT_INDEX_FINGER_PHALANX_INTERMEDIATE = 31;
    static constexpr int64_t JOINT_LEFT_INDEX_FINGER_PHALANX_DISTAL = 32;
    static constexpr int64_t JOINT_LEFT_INDEX_FINGER_TIP = 33;
    static constexpr int64_t JOINT_LEFT_MIDDLE_FINGER_METACARPAL = 34;
    static constexpr int64_t JOINT_LEFT_MIDDLE_FINGER_PHALANX_PROXIMAL = 35;
    static constexpr int64_t JOINT_LEFT_MIDDLE_FINGER_PHALANX_INTERMEDIATE = 36;
    static constexpr int64_t JOINT_LEFT_MIDDLE_FINGER_PHALANX_DISTAL = 37;
    static constexpr int64_t JOINT_LEFT_MIDDLE_FINGER_TIP = 38;
    static constexpr int64_t JOINT_LEFT_RING_FINGER_METACARPAL = 39;
    static constexpr int64_t JOINT_LEFT_RING_FINGER_PHALANX_PROXIMAL = 40;
    static constexpr int64_t JOINT_LEFT_RING_FINGER_PHALANX_INTERMEDIATE = 41;
    static constexpr int64_t JOINT_LEFT_RING_FINGER_PHALANX_DISTAL = 42;
    static constexpr int64_t JOINT_LEFT_RING_FINGER_TIP = 43;
    static constexpr int64_t JOINT_LEFT_PINKY_FINGER_METACARPAL = 44;
    static constexpr int64_t JOINT_LEFT_PINKY_FINGER_PHALANX_PROXIMAL = 45;
    static constexpr int64_t JOINT_LEFT_PINKY_FINGER_PHALANX_INTERMEDIATE = 46;
    static constexpr int64_t JOINT_LEFT_PINKY_FINGER_PHALANX_DISTAL = 47;
    static constexpr int64_t JOINT_LEFT_PINKY_FINGER_TIP = 48;
    static constexpr int64_t JOINT_RIGHT_HAND = 49;
    static constexpr int64_t JOINT_RIGHT_PALM = 50;
    static constexpr int64_t JOINT_RIGHT_WRIST = 51;
    static constexpr int64_t JOINT_RIGHT_THUMB_METACARPAL = 52;
    static constexpr int64_t JOINT_RIGHT_THUMB_PHALANX_PROXIMAL = 53;
    static constexpr int64_t JOINT_RIGHT_THUMB_PHALANX_DISTAL = 54;
    static constexpr int64_t JOINT_RIGHT_THUMB_TIP = 55;
    static constexpr int64_t JOINT_RIGHT_INDEX_FINGER_METACARPAL = 56;
    static constexpr int64_t JOINT_RIGHT_INDEX_FINGER_PHALANX_PROXIMAL = 57;
    static constexpr int64_t JOINT_RIGHT_INDEX_FINGER_PHALANX_INTERMEDIATE = 58;
    static constexpr int64_t JOINT_RIGHT_INDEX_FINGER_PHALANX_DISTAL = 59;
    static constexpr int64_t JOINT_RIGHT_INDEX_FINGER_TIP = 60;
    static constexpr int64_t JOINT_RIGHT_MIDDLE_FINGER_METACARPAL = 61;
    static constexpr int64_t JOINT_RIGHT_MIDDLE_FINGER_PHALANX_PROXIMAL = 62;
    static constexpr int64_t JOINT_RIGHT_MIDDLE_FINGER_PHALANX_INTERMEDIATE = 63;
    static constexpr int64_t JOINT_RIGHT_MIDDLE_FINGER_PHALANX_DISTAL = 64;
    static constexpr int64_t JOINT_RIGHT_MIDDLE_FINGER_TIP = 65;
    static constexpr int64_t JOINT_RIGHT_RING_FINGER_METACARPAL = 66;
    static constexpr int64_t JOINT_RIGHT_RING_FINGER_PHALANX_PROXIMAL = 67;
    static constexpr int64_t JOINT_RIGHT_RING_FINGER_PHALANX_INTERMEDIATE = 68;
    static constexpr int64_t JOINT_RIGHT_RING_FINGER_PHALANX_DISTAL = 69;
    static constexpr int64_t JOINT_RIGHT_RING_FINGER_TIP = 70;
    static constexpr int64_t JOINT_RIGHT_PINKY_FINGER_METACARPAL = 71;
    static constexpr int64_t JOINT_RIGHT_PINKY_FINGER_PHALANX_PROXIMAL = 72;
    static constexpr int64_t JOINT_RIGHT_PINKY_FINGER_PHALANX_INTERMEDIATE = 73;
    static constexpr int64_t JOINT_RIGHT_PINKY_FINGER_PHALANX_DISTAL = 74;
    static constexpr int64_t JOINT_RIGHT_PINKY_FINGER_TIP = 75;
    static constexpr int64_t JOINT_MAX = 76;
    static constexpr int64_t JOINT_FLAG_ORIENTATION_VALID = 1;
    static constexpr int64_t JOINT_FLAG_ORIENTATION_TRACKED = 2;
    static constexpr int64_t JOINT_FLAG_POSITION_VALID = 4;
    static constexpr int64_t JOINT_FLAG_POSITION_TRACKED = 8;
};
struct XRControllerTracker : public XRPositionalTracker {
    using XRPositionalTracker::XRPositionalTracker;
};
struct XRHandTracker : public XRPositionalTracker {
    using XRPositionalTracker::XRPositionalTracker;
    PROPERTY(has_tracking_data, bool);
    PROPERTY(hand_tracking_source, int64_t);
    METHOD(void, set_has_tracking_data);
    METHOD(bool, get_has_tracking_data);
    METHOD(void, set_hand_tracking_source);
    METHOD(int64_t, get_hand_tracking_source);
    METHOD(void, set_hand_joint_flags);
    METHOD(int64_t, get_hand_joint_flags);
    METHOD(void, set_hand_joint_transform);
    METHOD(Transform3D, get_hand_joint_transform);
    METHOD(void, set_hand_joint_radius);
    METHOD(double, get_hand_joint_radius);
    METHOD(void, set_hand_joint_linear_velocity);
    METHOD(Vector3, get_hand_joint_linear_velocity);
    METHOD(void, set_hand_joint_angular_velocity);
    METHOD(Vector3, get_hand_joint_angular_velocity);
    static constexpr int64_t HAND_TRACKING_SOURCE_UNKNOWN = 0;
    static constexpr int64_t HAND_TRACKING_SOURCE_UNOBSTRUCTED = 1;
    static constexpr int64_t HAND_TRACKING_SOURCE_CONTROLLER = 2;
    static constexpr int64_t HAND_TRACKING_SOURCE_MAX = 3;
    static constexpr int64_t HAND_JOINT_PALM = 0;
    static constexpr int64_t HAND_JOINT_WRIST = 1;
    static constexpr int64_t HAND_JOINT_THUMB_METACARPAL = 2;
    static constexpr int64_t HAND_JOINT_THUMB_PHALANX_PROXIMAL = 3;
    static constexpr int64_t HAND_JOINT_THUMB_PHALANX_DISTAL = 4;
    static constexpr int64_t HAND_JOINT_THUMB_TIP = 5;
    static constexpr int64_t HAND_JOINT_INDEX_FINGER_METACARPAL = 6;
    static constexpr int64_t HAND_JOINT_INDEX_FINGER_PHALANX_PROXIMAL = 7;
    static constexpr int64_t HAND_JOINT_INDEX_FINGER_PHALANX_INTERMEDIATE = 8;
    static constexpr int64_t HAND_JOINT_INDEX_FINGER_PHALANX_DISTAL = 9;
    static constexpr int64_t HAND_JOINT_INDEX_FINGER_TIP = 10;
    static constexpr int64_t HAND_JOINT_MIDDLE_FINGER_METACARPAL = 11;
    static constexpr int64_t HAND_JOINT_MIDDLE_FINGER_PHALANX_PROXIMAL = 12;
    static constexpr int64_t HAND_JOINT_MIDDLE_FINGER_PHALANX_INTERMEDIATE = 13;
    static constexpr int64_t HAND_JOINT_MIDDLE_FINGER_PHALANX_DISTAL = 14;
    static constexpr int64_t HAND_JOINT_MIDDLE_FINGER_TIP = 15;
    static constexpr int64_t HAND_JOINT_RING_FINGER_METACARPAL = 16;
    static constexpr int64_t HAND_JOINT_RING_FINGER_PHALANX_PROXIMAL = 17;
    static constexpr int64_t HAND_JOINT_RING_FINGER_PHALANX_INTERMEDIATE = 18;
    static constexpr int64_t HAND_JOINT_RING_FINGER_PHALANX_DISTAL = 19;
    static constexpr int64_t HAND_JOINT_RING_FINGER_TIP = 20;
    static constexpr int64_t HAND_JOINT_PINKY_FINGER_METACARPAL = 21;
    static constexpr int64_t HAND_JOINT_PINKY_FINGER_PHALANX_PROXIMAL = 22;
    static constexpr int64_t HAND_JOINT_PINKY_FINGER_PHALANX_INTERMEDIATE = 23;
    static constexpr int64_t HAND_JOINT_PINKY_FINGER_PHALANX_DISTAL = 24;
    static constexpr int64_t HAND_JOINT_PINKY_FINGER_TIP = 25;
    static constexpr int64_t HAND_JOINT_MAX = 26;
    static constexpr int64_t HAND_JOINT_FLAG_ORIENTATION_VALID = 1;
    static constexpr int64_t HAND_JOINT_FLAG_ORIENTATION_TRACKED = 2;
    static constexpr int64_t HAND_JOINT_FLAG_POSITION_VALID = 4;
    static constexpr int64_t HAND_JOINT_FLAG_POSITION_TRACKED = 8;
    static constexpr int64_t HAND_JOINT_FLAG_LINEAR_VELOCITY_VALID = 16;
    static constexpr int64_t HAND_JOINT_FLAG_ANGULAR_VELOCITY_VALID = 32;
};
